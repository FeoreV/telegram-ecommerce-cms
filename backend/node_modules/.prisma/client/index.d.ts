
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model StoreAdmin
 * 
 */
export type StoreAdmin = $Result.DefaultSelection<Prisma.$StoreAdminPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductVariant
 * 
 */
export type ProductVariant = $Result.DefaultSelection<Prisma.$ProductVariantPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model AdminLog
 * 
 */
export type AdminLog = $Result.DefaultSelection<Prisma.$AdminLogPayload>
/**
 * Model IntegrationMapping
 * 
 */
export type IntegrationMapping = $Result.DefaultSelection<Prisma.$IntegrationMappingPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model RevokedToken
 * 
 */
export type RevokedToken = $Result.DefaultSelection<Prisma.$RevokedTokenPayload>
/**
 * Model StoreVendor
 * 
 */
export type StoreVendor = $Result.DefaultSelection<Prisma.$StoreVendorPayload>
/**
 * Model StockLog
 * 
 */
export type StockLog = $Result.DefaultSelection<Prisma.$StockLogPayload>
/**
 * Model EmployeeInvitation
 * 
 */
export type EmployeeInvitation = $Result.DefaultSelection<Prisma.$EmployeeInvitationPayload>
/**
 * Model EmployeeActivity
 * 
 */
export type EmployeeActivity = $Result.DefaultSelection<Prisma.$EmployeeActivityPayload>
/**
 * Model InviteLink
 * 
 */
export type InviteLink = $Result.DefaultSelection<Prisma.$InviteLinkPayload>
/**
 * Model CustomRole
 * 
 */
export type CustomRole = $Result.DefaultSelection<Prisma.$CustomRolePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs>;

  /**
   * `prisma.storeAdmin`: Exposes CRUD operations for the **StoreAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreAdmins
    * const storeAdmins = await prisma.storeAdmin.findMany()
    * ```
    */
  get storeAdmin(): Prisma.StoreAdminDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariants
    * const productVariants = await prisma.productVariant.findMany()
    * ```
    */
  get productVariant(): Prisma.ProductVariantDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.adminLog`: Exposes CRUD operations for the **AdminLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminLogs
    * const adminLogs = await prisma.adminLog.findMany()
    * ```
    */
  get adminLog(): Prisma.AdminLogDelegate<ExtArgs>;

  /**
   * `prisma.integrationMapping`: Exposes CRUD operations for the **IntegrationMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegrationMappings
    * const integrationMappings = await prisma.integrationMapping.findMany()
    * ```
    */
  get integrationMapping(): Prisma.IntegrationMappingDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs>;

  /**
   * `prisma.revokedToken`: Exposes CRUD operations for the **RevokedToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RevokedTokens
    * const revokedTokens = await prisma.revokedToken.findMany()
    * ```
    */
  get revokedToken(): Prisma.RevokedTokenDelegate<ExtArgs>;

  /**
   * `prisma.storeVendor`: Exposes CRUD operations for the **StoreVendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreVendors
    * const storeVendors = await prisma.storeVendor.findMany()
    * ```
    */
  get storeVendor(): Prisma.StoreVendorDelegate<ExtArgs>;

  /**
   * `prisma.stockLog`: Exposes CRUD operations for the **StockLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockLogs
    * const stockLogs = await prisma.stockLog.findMany()
    * ```
    */
  get stockLog(): Prisma.StockLogDelegate<ExtArgs>;

  /**
   * `prisma.employeeInvitation`: Exposes CRUD operations for the **EmployeeInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeInvitations
    * const employeeInvitations = await prisma.employeeInvitation.findMany()
    * ```
    */
  get employeeInvitation(): Prisma.EmployeeInvitationDelegate<ExtArgs>;

  /**
   * `prisma.employeeActivity`: Exposes CRUD operations for the **EmployeeActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeActivities
    * const employeeActivities = await prisma.employeeActivity.findMany()
    * ```
    */
  get employeeActivity(): Prisma.EmployeeActivityDelegate<ExtArgs>;

  /**
   * `prisma.inviteLink`: Exposes CRUD operations for the **InviteLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InviteLinks
    * const inviteLinks = await prisma.inviteLink.findMany()
    * ```
    */
  get inviteLink(): Prisma.InviteLinkDelegate<ExtArgs>;

  /**
   * `prisma.customRole`: Exposes CRUD operations for the **CustomRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomRoles
    * const customRoles = await prisma.customRole.findMany()
    * ```
    */
  get customRole(): Prisma.CustomRoleDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Store: 'Store',
    StoreAdmin: 'StoreAdmin',
    Category: 'Category',
    Product: 'Product',
    ProductVariant: 'ProductVariant',
    Order: 'Order',
    OrderItem: 'OrderItem',
    AdminLog: 'AdminLog',
    IntegrationMapping: 'IntegrationMapping',
    Notification: 'Notification',
    UserSession: 'UserSession',
    RevokedToken: 'RevokedToken',
    StoreVendor: 'StoreVendor',
    StockLog: 'StockLog',
    EmployeeInvitation: 'EmployeeInvitation',
    EmployeeActivity: 'EmployeeActivity',
    InviteLink: 'InviteLink',
    CustomRole: 'CustomRole'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "store" | "storeAdmin" | "category" | "product" | "productVariant" | "order" | "orderItem" | "adminLog" | "integrationMapping" | "notification" | "userSession" | "revokedToken" | "storeVendor" | "stockLog" | "employeeInvitation" | "employeeActivity" | "inviteLink" | "customRole"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      StoreAdmin: {
        payload: Prisma.$StoreAdminPayload<ExtArgs>
        fields: Prisma.StoreAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload>
          }
          findFirst: {
            args: Prisma.StoreAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload>
          }
          findMany: {
            args: Prisma.StoreAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload>[]
          }
          create: {
            args: Prisma.StoreAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload>
          }
          createMany: {
            args: Prisma.StoreAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload>[]
          }
          delete: {
            args: Prisma.StoreAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload>
          }
          update: {
            args: Prisma.StoreAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload>
          }
          deleteMany: {
            args: Prisma.StoreAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAdminPayload>
          }
          aggregate: {
            args: Prisma.StoreAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreAdmin>
          }
          groupBy: {
            args: Prisma.StoreAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreAdminCountArgs<ExtArgs>
            result: $Utils.Optional<StoreAdminCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductVariant: {
        payload: Prisma.$ProductVariantPayload<ExtArgs>
        fields: Prisma.ProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findFirst: {
            args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findMany: {
            args: Prisma.ProductVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          create: {
            args: Prisma.ProductVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          createMany: {
            args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          delete: {
            args: Prisma.ProductVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          update: {
            args: Prisma.ProductVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          aggregate: {
            args: Prisma.ProductVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariant>
          }
          groupBy: {
            args: Prisma.ProductVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      AdminLog: {
        payload: Prisma.$AdminLogPayload<ExtArgs>
        fields: Prisma.AdminLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          findFirst: {
            args: Prisma.AdminLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          findMany: {
            args: Prisma.AdminLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>[]
          }
          create: {
            args: Prisma.AdminLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          createMany: {
            args: Prisma.AdminLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>[]
          }
          delete: {
            args: Prisma.AdminLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          update: {
            args: Prisma.AdminLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          aggregate: {
            args: Prisma.AdminLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminLog>
          }
          groupBy: {
            args: Prisma.AdminLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminLogCountAggregateOutputType> | number
          }
        }
      }
      IntegrationMapping: {
        payload: Prisma.$IntegrationMappingPayload<ExtArgs>
        fields: Prisma.IntegrationMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload>
          }
          findFirst: {
            args: Prisma.IntegrationMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload>
          }
          findMany: {
            args: Prisma.IntegrationMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload>[]
          }
          create: {
            args: Prisma.IntegrationMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload>
          }
          createMany: {
            args: Prisma.IntegrationMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload>[]
          }
          delete: {
            args: Prisma.IntegrationMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload>
          }
          update: {
            args: Prisma.IntegrationMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationMappingPayload>
          }
          aggregate: {
            args: Prisma.IntegrationMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegrationMapping>
          }
          groupBy: {
            args: Prisma.IntegrationMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationMappingCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationMappingCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      RevokedToken: {
        payload: Prisma.$RevokedTokenPayload<ExtArgs>
        fields: Prisma.RevokedTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevokedTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevokedTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload>
          }
          findFirst: {
            args: Prisma.RevokedTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevokedTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload>
          }
          findMany: {
            args: Prisma.RevokedTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload>[]
          }
          create: {
            args: Prisma.RevokedTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload>
          }
          createMany: {
            args: Prisma.RevokedTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevokedTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload>[]
          }
          delete: {
            args: Prisma.RevokedTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload>
          }
          update: {
            args: Prisma.RevokedTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload>
          }
          deleteMany: {
            args: Prisma.RevokedTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevokedTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RevokedTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevokedTokenPayload>
          }
          aggregate: {
            args: Prisma.RevokedTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevokedToken>
          }
          groupBy: {
            args: Prisma.RevokedTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevokedTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevokedTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RevokedTokenCountAggregateOutputType> | number
          }
        }
      }
      StoreVendor: {
        payload: Prisma.$StoreVendorPayload<ExtArgs>
        fields: Prisma.StoreVendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreVendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreVendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload>
          }
          findFirst: {
            args: Prisma.StoreVendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreVendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload>
          }
          findMany: {
            args: Prisma.StoreVendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload>[]
          }
          create: {
            args: Prisma.StoreVendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload>
          }
          createMany: {
            args: Prisma.StoreVendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreVendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload>[]
          }
          delete: {
            args: Prisma.StoreVendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload>
          }
          update: {
            args: Prisma.StoreVendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload>
          }
          deleteMany: {
            args: Prisma.StoreVendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreVendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreVendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreVendorPayload>
          }
          aggregate: {
            args: Prisma.StoreVendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreVendor>
          }
          groupBy: {
            args: Prisma.StoreVendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreVendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreVendorCountArgs<ExtArgs>
            result: $Utils.Optional<StoreVendorCountAggregateOutputType> | number
          }
        }
      }
      StockLog: {
        payload: Prisma.$StockLogPayload<ExtArgs>
        fields: Prisma.StockLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          findFirst: {
            args: Prisma.StockLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          findMany: {
            args: Prisma.StockLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>[]
          }
          create: {
            args: Prisma.StockLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          createMany: {
            args: Prisma.StockLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>[]
          }
          delete: {
            args: Prisma.StockLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          update: {
            args: Prisma.StockLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          deleteMany: {
            args: Prisma.StockLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          aggregate: {
            args: Prisma.StockLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockLog>
          }
          groupBy: {
            args: Prisma.StockLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockLogCountArgs<ExtArgs>
            result: $Utils.Optional<StockLogCountAggregateOutputType> | number
          }
        }
      }
      EmployeeInvitation: {
        payload: Prisma.$EmployeeInvitationPayload<ExtArgs>
        fields: Prisma.EmployeeInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload>
          }
          findFirst: {
            args: Prisma.EmployeeInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload>
          }
          findMany: {
            args: Prisma.EmployeeInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload>[]
          }
          create: {
            args: Prisma.EmployeeInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload>
          }
          createMany: {
            args: Prisma.EmployeeInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload>[]
          }
          delete: {
            args: Prisma.EmployeeInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload>
          }
          update: {
            args: Prisma.EmployeeInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeInvitationPayload>
          }
          aggregate: {
            args: Prisma.EmployeeInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeInvitation>
          }
          groupBy: {
            args: Prisma.EmployeeInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeInvitationCountAggregateOutputType> | number
          }
        }
      }
      EmployeeActivity: {
        payload: Prisma.$EmployeeActivityPayload<ExtArgs>
        fields: Prisma.EmployeeActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload>
          }
          findFirst: {
            args: Prisma.EmployeeActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload>
          }
          findMany: {
            args: Prisma.EmployeeActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload>[]
          }
          create: {
            args: Prisma.EmployeeActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload>
          }
          createMany: {
            args: Prisma.EmployeeActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload>[]
          }
          delete: {
            args: Prisma.EmployeeActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload>
          }
          update: {
            args: Prisma.EmployeeActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeActivityPayload>
          }
          aggregate: {
            args: Prisma.EmployeeActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeActivity>
          }
          groupBy: {
            args: Prisma.EmployeeActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeActivityCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeActivityCountAggregateOutputType> | number
          }
        }
      }
      InviteLink: {
        payload: Prisma.$InviteLinkPayload<ExtArgs>
        fields: Prisma.InviteLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          findFirst: {
            args: Prisma.InviteLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          findMany: {
            args: Prisma.InviteLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>[]
          }
          create: {
            args: Prisma.InviteLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          createMany: {
            args: Prisma.InviteLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>[]
          }
          delete: {
            args: Prisma.InviteLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          update: {
            args: Prisma.InviteLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          deleteMany: {
            args: Prisma.InviteLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InviteLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          aggregate: {
            args: Prisma.InviteLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInviteLink>
          }
          groupBy: {
            args: Prisma.InviteLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteLinkCountArgs<ExtArgs>
            result: $Utils.Optional<InviteLinkCountAggregateOutputType> | number
          }
        }
      }
      CustomRole: {
        payload: Prisma.$CustomRolePayload<ExtArgs>
        fields: Prisma.CustomRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          findFirst: {
            args: Prisma.CustomRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          findMany: {
            args: Prisma.CustomRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>[]
          }
          create: {
            args: Prisma.CustomRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          createMany: {
            args: Prisma.CustomRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>[]
          }
          delete: {
            args: Prisma.CustomRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          update: {
            args: Prisma.CustomRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          deleteMany: {
            args: Prisma.CustomRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          aggregate: {
            args: Prisma.CustomRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomRole>
          }
          groupBy: {
            args: Prisma.CustomRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomRoleCountArgs<ExtArgs>
            result: $Utils.Optional<CustomRoleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    adminLogs: number
    orders: number
    managedStores: number
    assignedAdmins: number
    ownedStores: number
    vendorStores: number
    sessions: number
    notifications: number
    receivedInvitations: number
    sentInvitations: number
    employeeActivities: number
    createdInviteLinks: number
    createdCustomRoles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminLogs?: boolean | UserCountOutputTypeCountAdminLogsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    managedStores?: boolean | UserCountOutputTypeCountManagedStoresArgs
    assignedAdmins?: boolean | UserCountOutputTypeCountAssignedAdminsArgs
    ownedStores?: boolean | UserCountOutputTypeCountOwnedStoresArgs
    vendorStores?: boolean | UserCountOutputTypeCountVendorStoresArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    receivedInvitations?: boolean | UserCountOutputTypeCountReceivedInvitationsArgs
    sentInvitations?: boolean | UserCountOutputTypeCountSentInvitationsArgs
    employeeActivities?: boolean | UserCountOutputTypeCountEmployeeActivitiesArgs
    createdInviteLinks?: boolean | UserCountOutputTypeCountCreatedInviteLinksArgs
    createdCustomRoles?: boolean | UserCountOutputTypeCountCreatedCustomRolesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreAdminWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreAdminWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVendorStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreVendorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeeActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteLinkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCustomRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomRoleWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    integrationMappings: number
    orders: number
    products: number
    admins: number
    vendors: number
    stockLogs: number
    notifications: number
    employeeInvitations: number
    employeeActivities: number
    inviteLinks: number
    customRoles: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integrationMappings?: boolean | StoreCountOutputTypeCountIntegrationMappingsArgs
    orders?: boolean | StoreCountOutputTypeCountOrdersArgs
    products?: boolean | StoreCountOutputTypeCountProductsArgs
    admins?: boolean | StoreCountOutputTypeCountAdminsArgs
    vendors?: boolean | StoreCountOutputTypeCountVendorsArgs
    stockLogs?: boolean | StoreCountOutputTypeCountStockLogsArgs
    notifications?: boolean | StoreCountOutputTypeCountNotificationsArgs
    employeeInvitations?: boolean | StoreCountOutputTypeCountEmployeeInvitationsArgs
    employeeActivities?: boolean | StoreCountOutputTypeCountEmployeeActivitiesArgs
    inviteLinks?: boolean | StoreCountOutputTypeCountInviteLinksArgs
    customRoles?: boolean | StoreCountOutputTypeCountCustomRolesArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountIntegrationMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationMappingWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreAdminWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreVendorWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountStockLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLogWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountEmployeeInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeInvitationWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountEmployeeActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeActivityWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteLinkWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountCustomRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomRoleWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
    variants: number
    stockLogs: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
    stockLogs?: boolean | ProductCountOutputTypeCountStockLogsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLogWhereInput
  }


  /**
   * Count Type ProductVariantCountOutputType
   */

  export type ProductVariantCountOutputType = {
    orderItems: number
    stockLogs: number
  }

  export type ProductVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductVariantCountOutputTypeCountOrderItemsArgs
    stockLogs?: boolean | ProductVariantCountOutputTypeCountStockLogsArgs
  }

  // Custom InputTypes
  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantCountOutputType
     */
    select?: ProductVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountStockLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLogWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    adminLogs: number
    items: number
    notifications: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminLogs?: boolean | OrderCountOutputTypeCountAdminLogsArgs
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    notifications?: boolean | OrderCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountAdminLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLogWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type InviteLinkCountOutputType
   */

  export type InviteLinkCountOutputType = {
    invitations: number
  }

  export type InviteLinkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitations?: boolean | InviteLinkCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * InviteLinkCountOutputType without action
   */
  export type InviteLinkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLinkCountOutputType
     */
    select?: InviteLinkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InviteLinkCountOutputType without action
   */
  export type InviteLinkCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeInvitationWhereInput
  }


  /**
   * Count Type CustomRoleCountOutputType
   */

  export type CustomRoleCountOutputType = {
    vendors: number
    inviteLinks: number
  }

  export type CustomRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendors?: boolean | CustomRoleCountOutputTypeCountVendorsArgs
    inviteLinks?: boolean | CustomRoleCountOutputTypeCountInviteLinksArgs
  }

  // Custom InputTypes
  /**
   * CustomRoleCountOutputType without action
   */
  export type CustomRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRoleCountOutputType
     */
    select?: CustomRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomRoleCountOutputType without action
   */
  export type CustomRoleCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreVendorWhereInput
  }

  /**
   * CustomRoleCountOutputType without action
   */
  export type CustomRoleCountOutputTypeCountInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteLinkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    balance: number | null
  }

  export type UserSumAggregateOutputType = {
    balance: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    role: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    profilePhoto: string | null
    balance: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    role: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    profilePhoto: string | null
    balance: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    telegramId: number
    username: number
    firstName: number
    lastName: number
    email: number
    password: number
    phone: number
    role: number
    isActive: number
    lastLoginAt: number
    profilePhoto: number
    balance: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    balance?: true
  }

  export type UserSumAggregateInputType = {
    balance?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    profilePhoto?: true
    balance?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    profilePhoto?: true
    balance?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    profilePhoto?: true
    balance?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    telegramId: string
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    role: string
    isActive: boolean
    lastLoginAt: Date | null
    profilePhoto: string | null
    balance: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    profilePhoto?: boolean
    balance?: boolean
    adminLogs?: boolean | User$adminLogsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    managedStores?: boolean | User$managedStoresArgs<ExtArgs>
    assignedAdmins?: boolean | User$assignedAdminsArgs<ExtArgs>
    ownedStores?: boolean | User$ownedStoresArgs<ExtArgs>
    vendorStores?: boolean | User$vendorStoresArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    receivedInvitations?: boolean | User$receivedInvitationsArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    employeeActivities?: boolean | User$employeeActivitiesArgs<ExtArgs>
    createdInviteLinks?: boolean | User$createdInviteLinksArgs<ExtArgs>
    createdCustomRoles?: boolean | User$createdCustomRolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    profilePhoto?: boolean
    balance?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    profilePhoto?: boolean
    balance?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminLogs?: boolean | User$adminLogsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    managedStores?: boolean | User$managedStoresArgs<ExtArgs>
    assignedAdmins?: boolean | User$assignedAdminsArgs<ExtArgs>
    ownedStores?: boolean | User$ownedStoresArgs<ExtArgs>
    vendorStores?: boolean | User$vendorStoresArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    receivedInvitations?: boolean | User$receivedInvitationsArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    employeeActivities?: boolean | User$employeeActivitiesArgs<ExtArgs>
    createdInviteLinks?: boolean | User$createdInviteLinksArgs<ExtArgs>
    createdCustomRoles?: boolean | User$createdCustomRolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      adminLogs: Prisma.$AdminLogPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      managedStores: Prisma.$StoreAdminPayload<ExtArgs>[]
      assignedAdmins: Prisma.$StoreAdminPayload<ExtArgs>[]
      ownedStores: Prisma.$StorePayload<ExtArgs>[]
      vendorStores: Prisma.$StoreVendorPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      receivedInvitations: Prisma.$EmployeeInvitationPayload<ExtArgs>[]
      sentInvitations: Prisma.$EmployeeInvitationPayload<ExtArgs>[]
      employeeActivities: Prisma.$EmployeeActivityPayload<ExtArgs>[]
      createdInviteLinks: Prisma.$InviteLinkPayload<ExtArgs>[]
      createdCustomRoles: Prisma.$CustomRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      telegramId: string
      username: string | null
      firstName: string | null
      lastName: string | null
      email: string | null
      password: string | null
      phone: string | null
      role: string
      isActive: boolean
      lastLoginAt: Date | null
      profilePhoto: string | null
      balance: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminLogs<T extends User$adminLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$adminLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    managedStores<T extends User$managedStoresArgs<ExtArgs> = {}>(args?: Subset<T, User$managedStoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "findMany"> | Null>
    assignedAdmins<T extends User$assignedAdminsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedAdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "findMany"> | Null>
    ownedStores<T extends User$ownedStoresArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedStoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany"> | Null>
    vendorStores<T extends User$vendorStoresArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorStoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    receivedInvitations<T extends User$receivedInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    sentInvitations<T extends User$sentInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    employeeActivities<T extends User$employeeActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "findMany"> | Null>
    createdInviteLinks<T extends User$createdInviteLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdInviteLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findMany"> | Null>
    createdCustomRoles<T extends User$createdCustomRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCustomRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly telegramId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly profilePhoto: FieldRef<"User", 'String'>
    readonly balance: FieldRef<"User", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.adminLogs
   */
  export type User$adminLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    where?: AdminLogWhereInput
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    cursor?: AdminLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminLogScalarFieldEnum | AdminLogScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.managedStores
   */
  export type User$managedStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    where?: StoreAdminWhereInput
    orderBy?: StoreAdminOrderByWithRelationInput | StoreAdminOrderByWithRelationInput[]
    cursor?: StoreAdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreAdminScalarFieldEnum | StoreAdminScalarFieldEnum[]
  }

  /**
   * User.assignedAdmins
   */
  export type User$assignedAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    where?: StoreAdminWhereInput
    orderBy?: StoreAdminOrderByWithRelationInput | StoreAdminOrderByWithRelationInput[]
    cursor?: StoreAdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreAdminScalarFieldEnum | StoreAdminScalarFieldEnum[]
  }

  /**
   * User.ownedStores
   */
  export type User$ownedStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    cursor?: StoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * User.vendorStores
   */
  export type User$vendorStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    where?: StoreVendorWhereInput
    orderBy?: StoreVendorOrderByWithRelationInput | StoreVendorOrderByWithRelationInput[]
    cursor?: StoreVendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreVendorScalarFieldEnum | StoreVendorScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.receivedInvitations
   */
  export type User$receivedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    where?: EmployeeInvitationWhereInput
    orderBy?: EmployeeInvitationOrderByWithRelationInput | EmployeeInvitationOrderByWithRelationInput[]
    cursor?: EmployeeInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeInvitationScalarFieldEnum | EmployeeInvitationScalarFieldEnum[]
  }

  /**
   * User.sentInvitations
   */
  export type User$sentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    where?: EmployeeInvitationWhereInput
    orderBy?: EmployeeInvitationOrderByWithRelationInput | EmployeeInvitationOrderByWithRelationInput[]
    cursor?: EmployeeInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeInvitationScalarFieldEnum | EmployeeInvitationScalarFieldEnum[]
  }

  /**
   * User.employeeActivities
   */
  export type User$employeeActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    where?: EmployeeActivityWhereInput
    orderBy?: EmployeeActivityOrderByWithRelationInput | EmployeeActivityOrderByWithRelationInput[]
    cursor?: EmployeeActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeActivityScalarFieldEnum | EmployeeActivityScalarFieldEnum[]
  }

  /**
   * User.createdInviteLinks
   */
  export type User$createdInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    where?: InviteLinkWhereInput
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    cursor?: InviteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * User.createdCustomRoles
   */
  export type User$createdCustomRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    where?: CustomRoleWhereInput
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    cursor?: CustomRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomRoleScalarFieldEnum | CustomRoleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreAvgAggregateOutputType = {
    lowStockThreshold: number | null
    criticalStockThreshold: number | null
  }

  export type StoreSumAggregateOutputType = {
    lowStockThreshold: number | null
    criticalStockThreshold: number | null
  }

  export type StoreMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    slug: string | null
    status: string | null
    currency: string | null
    domain: string | null
    contactInfo: string | null
    contactPhone: string | null
    settings: string | null
    logoUrl: string | null
    bannerUrl: string | null
    lowStockThreshold: number | null
    criticalStockThreshold: number | null
    enableStockAlerts: boolean | null
    botToken: string | null
    botUsername: string | null
    botStatus: string | null
    botWebhookUrl: string | null
    botSettings: string | null
    botCreatedAt: Date | null
    botLastActive: Date | null
    ownerId: string | null
  }

  export type StoreMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    slug: string | null
    status: string | null
    currency: string | null
    domain: string | null
    contactInfo: string | null
    contactPhone: string | null
    settings: string | null
    logoUrl: string | null
    bannerUrl: string | null
    lowStockThreshold: number | null
    criticalStockThreshold: number | null
    enableStockAlerts: boolean | null
    botToken: string | null
    botUsername: string | null
    botStatus: string | null
    botWebhookUrl: string | null
    botSettings: string | null
    botCreatedAt: Date | null
    botLastActive: Date | null
    ownerId: string | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    slug: number
    status: number
    currency: number
    domain: number
    contactInfo: number
    contactPhone: number
    settings: number
    logoUrl: number
    bannerUrl: number
    lowStockThreshold: number
    criticalStockThreshold: number
    enableStockAlerts: number
    botToken: number
    botUsername: number
    botStatus: number
    botWebhookUrl: number
    botSettings: number
    botCreatedAt: number
    botLastActive: number
    ownerId: number
    _all: number
  }


  export type StoreAvgAggregateInputType = {
    lowStockThreshold?: true
    criticalStockThreshold?: true
  }

  export type StoreSumAggregateInputType = {
    lowStockThreshold?: true
    criticalStockThreshold?: true
  }

  export type StoreMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    slug?: true
    status?: true
    currency?: true
    domain?: true
    contactInfo?: true
    contactPhone?: true
    settings?: true
    logoUrl?: true
    bannerUrl?: true
    lowStockThreshold?: true
    criticalStockThreshold?: true
    enableStockAlerts?: true
    botToken?: true
    botUsername?: true
    botStatus?: true
    botWebhookUrl?: true
    botSettings?: true
    botCreatedAt?: true
    botLastActive?: true
    ownerId?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    slug?: true
    status?: true
    currency?: true
    domain?: true
    contactInfo?: true
    contactPhone?: true
    settings?: true
    logoUrl?: true
    bannerUrl?: true
    lowStockThreshold?: true
    criticalStockThreshold?: true
    enableStockAlerts?: true
    botToken?: true
    botUsername?: true
    botStatus?: true
    botWebhookUrl?: true
    botSettings?: true
    botCreatedAt?: true
    botLastActive?: true
    ownerId?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    slug?: true
    status?: true
    currency?: true
    domain?: true
    contactInfo?: true
    contactPhone?: true
    settings?: true
    logoUrl?: true
    bannerUrl?: true
    lowStockThreshold?: true
    criticalStockThreshold?: true
    enableStockAlerts?: true
    botToken?: true
    botUsername?: true
    botStatus?: true
    botWebhookUrl?: true
    botSettings?: true
    botCreatedAt?: true
    botLastActive?: true
    ownerId?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _avg?: StoreAvgAggregateInputType
    _sum?: StoreSumAggregateInputType
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    slug: string
    status: string
    currency: string
    domain: string | null
    contactInfo: string | null
    contactPhone: string | null
    settings: string | null
    logoUrl: string | null
    bannerUrl: string | null
    lowStockThreshold: number
    criticalStockThreshold: number
    enableStockAlerts: boolean
    botToken: string | null
    botUsername: string | null
    botStatus: string
    botWebhookUrl: string | null
    botSettings: string | null
    botCreatedAt: Date | null
    botLastActive: Date | null
    ownerId: string
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    status?: boolean
    currency?: boolean
    domain?: boolean
    contactInfo?: boolean
    contactPhone?: boolean
    settings?: boolean
    logoUrl?: boolean
    bannerUrl?: boolean
    lowStockThreshold?: boolean
    criticalStockThreshold?: boolean
    enableStockAlerts?: boolean
    botToken?: boolean
    botUsername?: boolean
    botStatus?: boolean
    botWebhookUrl?: boolean
    botSettings?: boolean
    botCreatedAt?: boolean
    botLastActive?: boolean
    ownerId?: boolean
    integrationMappings?: boolean | Store$integrationMappingsArgs<ExtArgs>
    orders?: boolean | Store$ordersArgs<ExtArgs>
    products?: boolean | Store$productsArgs<ExtArgs>
    admins?: boolean | Store$adminsArgs<ExtArgs>
    vendors?: boolean | Store$vendorsArgs<ExtArgs>
    stockLogs?: boolean | Store$stockLogsArgs<ExtArgs>
    notifications?: boolean | Store$notificationsArgs<ExtArgs>
    employeeInvitations?: boolean | Store$employeeInvitationsArgs<ExtArgs>
    employeeActivities?: boolean | Store$employeeActivitiesArgs<ExtArgs>
    inviteLinks?: boolean | Store$inviteLinksArgs<ExtArgs>
    customRoles?: boolean | Store$customRolesArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    status?: boolean
    currency?: boolean
    domain?: boolean
    contactInfo?: boolean
    contactPhone?: boolean
    settings?: boolean
    logoUrl?: boolean
    bannerUrl?: boolean
    lowStockThreshold?: boolean
    criticalStockThreshold?: boolean
    enableStockAlerts?: boolean
    botToken?: boolean
    botUsername?: boolean
    botStatus?: boolean
    botWebhookUrl?: boolean
    botSettings?: boolean
    botCreatedAt?: boolean
    botLastActive?: boolean
    ownerId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    status?: boolean
    currency?: boolean
    domain?: boolean
    contactInfo?: boolean
    contactPhone?: boolean
    settings?: boolean
    logoUrl?: boolean
    bannerUrl?: boolean
    lowStockThreshold?: boolean
    criticalStockThreshold?: boolean
    enableStockAlerts?: boolean
    botToken?: boolean
    botUsername?: boolean
    botStatus?: boolean
    botWebhookUrl?: boolean
    botSettings?: boolean
    botCreatedAt?: boolean
    botLastActive?: boolean
    ownerId?: boolean
  }

  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integrationMappings?: boolean | Store$integrationMappingsArgs<ExtArgs>
    orders?: boolean | Store$ordersArgs<ExtArgs>
    products?: boolean | Store$productsArgs<ExtArgs>
    admins?: boolean | Store$adminsArgs<ExtArgs>
    vendors?: boolean | Store$vendorsArgs<ExtArgs>
    stockLogs?: boolean | Store$stockLogsArgs<ExtArgs>
    notifications?: boolean | Store$notificationsArgs<ExtArgs>
    employeeInvitations?: boolean | Store$employeeInvitationsArgs<ExtArgs>
    employeeActivities?: boolean | Store$employeeActivitiesArgs<ExtArgs>
    inviteLinks?: boolean | Store$inviteLinksArgs<ExtArgs>
    customRoles?: boolean | Store$customRolesArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      integrationMappings: Prisma.$IntegrationMappingPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      admins: Prisma.$StoreAdminPayload<ExtArgs>[]
      vendors: Prisma.$StoreVendorPayload<ExtArgs>[]
      stockLogs: Prisma.$StockLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      employeeInvitations: Prisma.$EmployeeInvitationPayload<ExtArgs>[]
      employeeActivities: Prisma.$EmployeeActivityPayload<ExtArgs>[]
      inviteLinks: Prisma.$InviteLinkPayload<ExtArgs>[]
      customRoles: Prisma.$CustomRolePayload<ExtArgs>[]
      owner: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
      slug: string
      status: string
      currency: string
      domain: string | null
      contactInfo: string | null
      contactPhone: string | null
      settings: string | null
      logoUrl: string | null
      bannerUrl: string | null
      lowStockThreshold: number
      criticalStockThreshold: number
      enableStockAlerts: boolean
      botToken: string | null
      botUsername: string | null
      botStatus: string
      botWebhookUrl: string | null
      botSettings: string | null
      botCreatedAt: Date | null
      botLastActive: Date | null
      ownerId: string
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    integrationMappings<T extends Store$integrationMappingsArgs<ExtArgs> = {}>(args?: Subset<T, Store$integrationMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Store$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Store$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Store$productsArgs<ExtArgs> = {}>(args?: Subset<T, Store$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    admins<T extends Store$adminsArgs<ExtArgs> = {}>(args?: Subset<T, Store$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "findMany"> | Null>
    vendors<T extends Store$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Store$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "findMany"> | Null>
    stockLogs<T extends Store$stockLogsArgs<ExtArgs> = {}>(args?: Subset<T, Store$stockLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Store$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Store$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    employeeInvitations<T extends Store$employeeInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, Store$employeeInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    employeeActivities<T extends Store$employeeActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Store$employeeActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "findMany"> | Null>
    inviteLinks<T extends Store$inviteLinksArgs<ExtArgs> = {}>(args?: Subset<T, Store$inviteLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findMany"> | Null>
    customRoles<T extends Store$customRolesArgs<ExtArgs> = {}>(args?: Subset<T, Store$customRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findMany"> | Null>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */ 
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'String'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
    readonly name: FieldRef<"Store", 'String'>
    readonly description: FieldRef<"Store", 'String'>
    readonly slug: FieldRef<"Store", 'String'>
    readonly status: FieldRef<"Store", 'String'>
    readonly currency: FieldRef<"Store", 'String'>
    readonly domain: FieldRef<"Store", 'String'>
    readonly contactInfo: FieldRef<"Store", 'String'>
    readonly contactPhone: FieldRef<"Store", 'String'>
    readonly settings: FieldRef<"Store", 'String'>
    readonly logoUrl: FieldRef<"Store", 'String'>
    readonly bannerUrl: FieldRef<"Store", 'String'>
    readonly lowStockThreshold: FieldRef<"Store", 'Int'>
    readonly criticalStockThreshold: FieldRef<"Store", 'Int'>
    readonly enableStockAlerts: FieldRef<"Store", 'Boolean'>
    readonly botToken: FieldRef<"Store", 'String'>
    readonly botUsername: FieldRef<"Store", 'String'>
    readonly botStatus: FieldRef<"Store", 'String'>
    readonly botWebhookUrl: FieldRef<"Store", 'String'>
    readonly botSettings: FieldRef<"Store", 'String'>
    readonly botCreatedAt: FieldRef<"Store", 'DateTime'>
    readonly botLastActive: FieldRef<"Store", 'DateTime'>
    readonly ownerId: FieldRef<"Store", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
  }

  /**
   * Store.integrationMappings
   */
  export type Store$integrationMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    where?: IntegrationMappingWhereInput
    orderBy?: IntegrationMappingOrderByWithRelationInput | IntegrationMappingOrderByWithRelationInput[]
    cursor?: IntegrationMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationMappingScalarFieldEnum | IntegrationMappingScalarFieldEnum[]
  }

  /**
   * Store.orders
   */
  export type Store$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Store.products
   */
  export type Store$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Store.admins
   */
  export type Store$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    where?: StoreAdminWhereInput
    orderBy?: StoreAdminOrderByWithRelationInput | StoreAdminOrderByWithRelationInput[]
    cursor?: StoreAdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreAdminScalarFieldEnum | StoreAdminScalarFieldEnum[]
  }

  /**
   * Store.vendors
   */
  export type Store$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    where?: StoreVendorWhereInput
    orderBy?: StoreVendorOrderByWithRelationInput | StoreVendorOrderByWithRelationInput[]
    cursor?: StoreVendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreVendorScalarFieldEnum | StoreVendorScalarFieldEnum[]
  }

  /**
   * Store.stockLogs
   */
  export type Store$stockLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    where?: StockLogWhereInput
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    cursor?: StockLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * Store.notifications
   */
  export type Store$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Store.employeeInvitations
   */
  export type Store$employeeInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    where?: EmployeeInvitationWhereInput
    orderBy?: EmployeeInvitationOrderByWithRelationInput | EmployeeInvitationOrderByWithRelationInput[]
    cursor?: EmployeeInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeInvitationScalarFieldEnum | EmployeeInvitationScalarFieldEnum[]
  }

  /**
   * Store.employeeActivities
   */
  export type Store$employeeActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    where?: EmployeeActivityWhereInput
    orderBy?: EmployeeActivityOrderByWithRelationInput | EmployeeActivityOrderByWithRelationInput[]
    cursor?: EmployeeActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeActivityScalarFieldEnum | EmployeeActivityScalarFieldEnum[]
  }

  /**
   * Store.inviteLinks
   */
  export type Store$inviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    where?: InviteLinkWhereInput
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    cursor?: InviteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * Store.customRoles
   */
  export type Store$customRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    where?: CustomRoleWhereInput
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    cursor?: CustomRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomRoleScalarFieldEnum | CustomRoleScalarFieldEnum[]
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model StoreAdmin
   */

  export type AggregateStoreAdmin = {
    _count: StoreAdminCountAggregateOutputType | null
    _min: StoreAdminMinAggregateOutputType | null
    _max: StoreAdminMaxAggregateOutputType | null
  }

  export type StoreAdminMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    storeId: string | null
    userId: string | null
    assignedBy: string | null
  }

  export type StoreAdminMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    storeId: string | null
    userId: string | null
    assignedBy: string | null
  }

  export type StoreAdminCountAggregateOutputType = {
    id: number
    createdAt: number
    storeId: number
    userId: number
    assignedBy: number
    _all: number
  }


  export type StoreAdminMinAggregateInputType = {
    id?: true
    createdAt?: true
    storeId?: true
    userId?: true
    assignedBy?: true
  }

  export type StoreAdminMaxAggregateInputType = {
    id?: true
    createdAt?: true
    storeId?: true
    userId?: true
    assignedBy?: true
  }

  export type StoreAdminCountAggregateInputType = {
    id?: true
    createdAt?: true
    storeId?: true
    userId?: true
    assignedBy?: true
    _all?: true
  }

  export type StoreAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreAdmin to aggregate.
     */
    where?: StoreAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAdmins to fetch.
     */
    orderBy?: StoreAdminOrderByWithRelationInput | StoreAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreAdmins
    **/
    _count?: true | StoreAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreAdminMaxAggregateInputType
  }

  export type GetStoreAdminAggregateType<T extends StoreAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreAdmin[P]>
      : GetScalarType<T[P], AggregateStoreAdmin[P]>
  }




  export type StoreAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreAdminWhereInput
    orderBy?: StoreAdminOrderByWithAggregationInput | StoreAdminOrderByWithAggregationInput[]
    by: StoreAdminScalarFieldEnum[] | StoreAdminScalarFieldEnum
    having?: StoreAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreAdminCountAggregateInputType | true
    _min?: StoreAdminMinAggregateInputType
    _max?: StoreAdminMaxAggregateInputType
  }

  export type StoreAdminGroupByOutputType = {
    id: string
    createdAt: Date
    storeId: string
    userId: string
    assignedBy: string | null
    _count: StoreAdminCountAggregateOutputType | null
    _min: StoreAdminMinAggregateOutputType | null
    _max: StoreAdminMaxAggregateOutputType | null
  }

  type GetStoreAdminGroupByPayload<T extends StoreAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreAdminGroupByOutputType[P]>
            : GetScalarType<T[P], StoreAdminGroupByOutputType[P]>
        }
      >
    >


  export type StoreAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    storeId?: boolean
    userId?: boolean
    assignedBy?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedByUser?: boolean | StoreAdmin$assignedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["storeAdmin"]>

  export type StoreAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    storeId?: boolean
    userId?: boolean
    assignedBy?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedByUser?: boolean | StoreAdmin$assignedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["storeAdmin"]>

  export type StoreAdminSelectScalar = {
    id?: boolean
    createdAt?: boolean
    storeId?: boolean
    userId?: boolean
    assignedBy?: boolean
  }

  export type StoreAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedByUser?: boolean | StoreAdmin$assignedByUserArgs<ExtArgs>
  }
  export type StoreAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedByUser?: boolean | StoreAdmin$assignedByUserArgs<ExtArgs>
  }

  export type $StoreAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreAdmin"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      assignedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      storeId: string
      userId: string
      assignedBy: string | null
    }, ExtArgs["result"]["storeAdmin"]>
    composites: {}
  }

  type StoreAdminGetPayload<S extends boolean | null | undefined | StoreAdminDefaultArgs> = $Result.GetResult<Prisma.$StoreAdminPayload, S>

  type StoreAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreAdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreAdminCountAggregateInputType | true
    }

  export interface StoreAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreAdmin'], meta: { name: 'StoreAdmin' } }
    /**
     * Find zero or one StoreAdmin that matches the filter.
     * @param {StoreAdminFindUniqueArgs} args - Arguments to find a StoreAdmin
     * @example
     * // Get one StoreAdmin
     * const storeAdmin = await prisma.storeAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreAdminFindUniqueArgs>(args: SelectSubset<T, StoreAdminFindUniqueArgs<ExtArgs>>): Prisma__StoreAdminClient<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreAdmin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreAdminFindUniqueOrThrowArgs} args - Arguments to find a StoreAdmin
     * @example
     * // Get one StoreAdmin
     * const storeAdmin = await prisma.storeAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreAdminClient<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAdminFindFirstArgs} args - Arguments to find a StoreAdmin
     * @example
     * // Get one StoreAdmin
     * const storeAdmin = await prisma.storeAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreAdminFindFirstArgs>(args?: SelectSubset<T, StoreAdminFindFirstArgs<ExtArgs>>): Prisma__StoreAdminClient<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAdminFindFirstOrThrowArgs} args - Arguments to find a StoreAdmin
     * @example
     * // Get one StoreAdmin
     * const storeAdmin = await prisma.storeAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreAdminClient<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreAdmins
     * const storeAdmins = await prisma.storeAdmin.findMany()
     * 
     * // Get first 10 StoreAdmins
     * const storeAdmins = await prisma.storeAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeAdminWithIdOnly = await prisma.storeAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreAdminFindManyArgs>(args?: SelectSubset<T, StoreAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreAdmin.
     * @param {StoreAdminCreateArgs} args - Arguments to create a StoreAdmin.
     * @example
     * // Create one StoreAdmin
     * const StoreAdmin = await prisma.storeAdmin.create({
     *   data: {
     *     // ... data to create a StoreAdmin
     *   }
     * })
     * 
     */
    create<T extends StoreAdminCreateArgs>(args: SelectSubset<T, StoreAdminCreateArgs<ExtArgs>>): Prisma__StoreAdminClient<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreAdmins.
     * @param {StoreAdminCreateManyArgs} args - Arguments to create many StoreAdmins.
     * @example
     * // Create many StoreAdmins
     * const storeAdmin = await prisma.storeAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreAdminCreateManyArgs>(args?: SelectSubset<T, StoreAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreAdmins and returns the data saved in the database.
     * @param {StoreAdminCreateManyAndReturnArgs} args - Arguments to create many StoreAdmins.
     * @example
     * // Create many StoreAdmins
     * const storeAdmin = await prisma.storeAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreAdmins and only return the `id`
     * const storeAdminWithIdOnly = await prisma.storeAdmin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreAdmin.
     * @param {StoreAdminDeleteArgs} args - Arguments to delete one StoreAdmin.
     * @example
     * // Delete one StoreAdmin
     * const StoreAdmin = await prisma.storeAdmin.delete({
     *   where: {
     *     // ... filter to delete one StoreAdmin
     *   }
     * })
     * 
     */
    delete<T extends StoreAdminDeleteArgs>(args: SelectSubset<T, StoreAdminDeleteArgs<ExtArgs>>): Prisma__StoreAdminClient<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreAdmin.
     * @param {StoreAdminUpdateArgs} args - Arguments to update one StoreAdmin.
     * @example
     * // Update one StoreAdmin
     * const storeAdmin = await prisma.storeAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreAdminUpdateArgs>(args: SelectSubset<T, StoreAdminUpdateArgs<ExtArgs>>): Prisma__StoreAdminClient<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreAdmins.
     * @param {StoreAdminDeleteManyArgs} args - Arguments to filter StoreAdmins to delete.
     * @example
     * // Delete a few StoreAdmins
     * const { count } = await prisma.storeAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreAdminDeleteManyArgs>(args?: SelectSubset<T, StoreAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreAdmins
     * const storeAdmin = await prisma.storeAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreAdminUpdateManyArgs>(args: SelectSubset<T, StoreAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreAdmin.
     * @param {StoreAdminUpsertArgs} args - Arguments to update or create a StoreAdmin.
     * @example
     * // Update or create a StoreAdmin
     * const storeAdmin = await prisma.storeAdmin.upsert({
     *   create: {
     *     // ... data to create a StoreAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreAdmin we want to update
     *   }
     * })
     */
    upsert<T extends StoreAdminUpsertArgs>(args: SelectSubset<T, StoreAdminUpsertArgs<ExtArgs>>): Prisma__StoreAdminClient<$Result.GetResult<Prisma.$StoreAdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAdminCountArgs} args - Arguments to filter StoreAdmins to count.
     * @example
     * // Count the number of StoreAdmins
     * const count = await prisma.storeAdmin.count({
     *   where: {
     *     // ... the filter for the StoreAdmins we want to count
     *   }
     * })
    **/
    count<T extends StoreAdminCountArgs>(
      args?: Subset<T, StoreAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAdminAggregateArgs>(args: Subset<T, StoreAdminAggregateArgs>): Prisma.PrismaPromise<GetStoreAdminAggregateType<T>>

    /**
     * Group by StoreAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreAdminGroupByArgs['orderBy'] }
        : { orderBy?: StoreAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreAdmin model
   */
  readonly fields: StoreAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedByUser<T extends StoreAdmin$assignedByUserArgs<ExtArgs> = {}>(args?: Subset<T, StoreAdmin$assignedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreAdmin model
   */ 
  interface StoreAdminFieldRefs {
    readonly id: FieldRef<"StoreAdmin", 'String'>
    readonly createdAt: FieldRef<"StoreAdmin", 'DateTime'>
    readonly storeId: FieldRef<"StoreAdmin", 'String'>
    readonly userId: FieldRef<"StoreAdmin", 'String'>
    readonly assignedBy: FieldRef<"StoreAdmin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StoreAdmin findUnique
   */
  export type StoreAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    /**
     * Filter, which StoreAdmin to fetch.
     */
    where: StoreAdminWhereUniqueInput
  }

  /**
   * StoreAdmin findUniqueOrThrow
   */
  export type StoreAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    /**
     * Filter, which StoreAdmin to fetch.
     */
    where: StoreAdminWhereUniqueInput
  }

  /**
   * StoreAdmin findFirst
   */
  export type StoreAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    /**
     * Filter, which StoreAdmin to fetch.
     */
    where?: StoreAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAdmins to fetch.
     */
    orderBy?: StoreAdminOrderByWithRelationInput | StoreAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreAdmins.
     */
    cursor?: StoreAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreAdmins.
     */
    distinct?: StoreAdminScalarFieldEnum | StoreAdminScalarFieldEnum[]
  }

  /**
   * StoreAdmin findFirstOrThrow
   */
  export type StoreAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    /**
     * Filter, which StoreAdmin to fetch.
     */
    where?: StoreAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAdmins to fetch.
     */
    orderBy?: StoreAdminOrderByWithRelationInput | StoreAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreAdmins.
     */
    cursor?: StoreAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreAdmins.
     */
    distinct?: StoreAdminScalarFieldEnum | StoreAdminScalarFieldEnum[]
  }

  /**
   * StoreAdmin findMany
   */
  export type StoreAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    /**
     * Filter, which StoreAdmins to fetch.
     */
    where?: StoreAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAdmins to fetch.
     */
    orderBy?: StoreAdminOrderByWithRelationInput | StoreAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreAdmins.
     */
    cursor?: StoreAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAdmins.
     */
    skip?: number
    distinct?: StoreAdminScalarFieldEnum | StoreAdminScalarFieldEnum[]
  }

  /**
   * StoreAdmin create
   */
  export type StoreAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreAdmin.
     */
    data: XOR<StoreAdminCreateInput, StoreAdminUncheckedCreateInput>
  }

  /**
   * StoreAdmin createMany
   */
  export type StoreAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreAdmins.
     */
    data: StoreAdminCreateManyInput | StoreAdminCreateManyInput[]
  }

  /**
   * StoreAdmin createManyAndReturn
   */
  export type StoreAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreAdmins.
     */
    data: StoreAdminCreateManyInput | StoreAdminCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreAdmin update
   */
  export type StoreAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreAdmin.
     */
    data: XOR<StoreAdminUpdateInput, StoreAdminUncheckedUpdateInput>
    /**
     * Choose, which StoreAdmin to update.
     */
    where: StoreAdminWhereUniqueInput
  }

  /**
   * StoreAdmin updateMany
   */
  export type StoreAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreAdmins.
     */
    data: XOR<StoreAdminUpdateManyMutationInput, StoreAdminUncheckedUpdateManyInput>
    /**
     * Filter which StoreAdmins to update
     */
    where?: StoreAdminWhereInput
  }

  /**
   * StoreAdmin upsert
   */
  export type StoreAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreAdmin to update in case it exists.
     */
    where: StoreAdminWhereUniqueInput
    /**
     * In case the StoreAdmin found by the `where` argument doesn't exist, create a new StoreAdmin with this data.
     */
    create: XOR<StoreAdminCreateInput, StoreAdminUncheckedCreateInput>
    /**
     * In case the StoreAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreAdminUpdateInput, StoreAdminUncheckedUpdateInput>
  }

  /**
   * StoreAdmin delete
   */
  export type StoreAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
    /**
     * Filter which StoreAdmin to delete.
     */
    where: StoreAdminWhereUniqueInput
  }

  /**
   * StoreAdmin deleteMany
   */
  export type StoreAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreAdmins to delete
     */
    where?: StoreAdminWhereInput
  }

  /**
   * StoreAdmin.assignedByUser
   */
  export type StoreAdmin$assignedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StoreAdmin without action
   */
  export type StoreAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAdmin
     */
    select?: StoreAdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAdminInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    slug: string | null
    parentId: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    slug: string | null
    parentId: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    slug: number
    parentId: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    slug?: true
    parentId?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    slug?: true
    parentId?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    slug?: true
    parentId?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    slug: string
    parentId: string | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      slug: string
      parentId: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    sku: string | null
    price: number | null
    stock: number | null
    trackStock: boolean | null
    isActive: boolean | null
    images: string | null
    storeId: string | null
    categoryId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    sku: string | null
    price: number | null
    stock: number | null
    trackStock: boolean | null
    isActive: boolean | null
    images: string | null
    storeId: string | null
    categoryId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    sku: number
    price: number
    stock: number
    trackStock: number
    isActive: number
    images: number
    storeId: number
    categoryId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    sku?: true
    price?: true
    stock?: true
    trackStock?: true
    isActive?: true
    images?: true
    storeId?: true
    categoryId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    sku?: true
    price?: true
    stock?: true
    trackStock?: true
    isActive?: true
    images?: true
    storeId?: true
    categoryId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    sku?: true
    price?: true
    stock?: true
    trackStock?: true
    isActive?: true
    images?: true
    storeId?: true
    categoryId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    sku: string | null
    price: number
    stock: number
    trackStock: boolean
    isActive: boolean
    images: string | null
    storeId: string
    categoryId: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    price?: boolean
    stock?: boolean
    trackStock?: boolean
    isActive?: boolean
    images?: boolean
    storeId?: boolean
    categoryId?: boolean
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    stockLogs?: boolean | Product$stockLogsArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    price?: boolean
    stock?: boolean
    trackStock?: boolean
    isActive?: boolean
    images?: boolean
    storeId?: boolean
    categoryId?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    price?: boolean
    stock?: boolean
    trackStock?: boolean
    isActive?: boolean
    images?: boolean
    storeId?: boolean
    categoryId?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    stockLogs?: boolean | Product$stockLogsArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      variants: Prisma.$ProductVariantPayload<ExtArgs>[]
      stockLogs: Prisma.$StockLogPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
      sku: string | null
      price: number
      stock: number
      trackStock: boolean
      isActive: boolean
      images: string | null
      storeId: string
      categoryId: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany"> | Null>
    stockLogs<T extends Product$stockLogsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findMany"> | Null>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly trackStock: FieldRef<"Product", 'Boolean'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly images: FieldRef<"Product", 'String'>
    readonly storeId: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    cursor?: ProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * Product.stockLogs
   */
  export type Product$stockLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    where?: StockLogWhereInput
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    cursor?: StockLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariant
   */

  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  export type ProductVariantAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductVariantSumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductVariantMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    value: string | null
    price: number | null
    stock: number | null
    sku: string | null
    productId: string | null
  }

  export type ProductVariantMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    value: string | null
    price: number | null
    stock: number | null
    sku: string | null
    productId: string | null
  }

  export type ProductVariantCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    value: number
    price: number
    stock: number
    sku: number
    productId: number
    _all: number
  }


  export type ProductVariantAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductVariantSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductVariantMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    value?: true
    price?: true
    stock?: true
    sku?: true
    productId?: true
  }

  export type ProductVariantMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    value?: true
    price?: true
    stock?: true
    sku?: true
    productId?: true
  }

  export type ProductVariantCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    value?: true
    price?: true
    stock?: true
    sku?: true
    productId?: true
    _all?: true
  }

  export type ProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariants
    **/
    _count?: true | ProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantMaxAggregateInputType
  }

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>
  }




  export type ProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithAggregationInput | ProductVariantOrderByWithAggregationInput[]
    by: ProductVariantScalarFieldEnum[] | ProductVariantScalarFieldEnum
    having?: ProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantCountAggregateInputType | true
    _avg?: ProductVariantAvgAggregateInputType
    _sum?: ProductVariantSumAggregateInputType
    _min?: ProductVariantMinAggregateInputType
    _max?: ProductVariantMaxAggregateInputType
  }

  export type ProductVariantGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    value: string
    price: number | null
    stock: number | null
    sku: string | null
    productId: string
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    value?: boolean
    price?: boolean
    stock?: boolean
    sku?: boolean
    productId?: boolean
    orderItems?: boolean | ProductVariant$orderItemsArgs<ExtArgs>
    stockLogs?: boolean | ProductVariant$stockLogsArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    value?: boolean
    price?: boolean
    stock?: boolean
    sku?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    value?: boolean
    price?: boolean
    stock?: boolean
    sku?: boolean
    productId?: boolean
  }

  export type ProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductVariant$orderItemsArgs<ExtArgs>
    stockLogs?: boolean | ProductVariant$stockLogsArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariant"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      stockLogs: Prisma.$StockLogPayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      value: string
      price: number | null
      stock: number | null
      sku: string | null
      productId: string
    }, ExtArgs["result"]["productVariant"]>
    composites: {}
  }

  type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantPayload, S>

  type ProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductVariantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductVariantCountAggregateInputType | true
    }

  export interface ProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariant'], meta: { name: 'ProductVariant' } }
    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantFindUniqueArgs>(args: SelectSubset<T, ProductVariantFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductVariant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantFindFirstArgs>(args?: SelectSubset<T, ProductVariantFindFirstArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     * 
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantFindManyArgs>(args?: SelectSubset<T, ProductVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     * 
     */
    create<T extends ProductVariantCreateArgs>(args: SelectSubset<T, ProductVariantCreateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductVariants.
     * @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantCreateManyArgs>(args?: SelectSubset<T, ProductVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariants and returns the data saved in the database.
     * @param {ProductVariantCreateManyAndReturnArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantDeleteArgs>(args: SelectSubset<T, ProductVariantDeleteArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantUpdateArgs>(args: SelectSubset<T, ProductVariantUpdateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantDeleteManyArgs>(args?: SelectSubset<T, ProductVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantUpdateManyArgs>(args: SelectSubset<T, ProductVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantUpsertArgs>(args: SelectSubset<T, ProductVariantUpsertArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantAggregateArgs>(args: Subset<T, ProductVariantAggregateArgs>): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariant model
   */
  readonly fields: ProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends ProductVariant$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    stockLogs<T extends ProductVariant$stockLogsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$stockLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findMany"> | Null>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariant model
   */ 
  interface ProductVariantFieldRefs {
    readonly id: FieldRef<"ProductVariant", 'String'>
    readonly createdAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly name: FieldRef<"ProductVariant", 'String'>
    readonly value: FieldRef<"ProductVariant", 'String'>
    readonly price: FieldRef<"ProductVariant", 'Float'>
    readonly stock: FieldRef<"ProductVariant", 'Int'>
    readonly sku: FieldRef<"ProductVariant", 'String'>
    readonly productId: FieldRef<"ProductVariant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariant findUnique
   */
  export type ProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findFirst
   */
  export type ProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
  }

  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
  }

  /**
   * ProductVariant createManyAndReturn
   */
  export type ProductVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
  }

  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
  }

  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput
  }

  /**
   * ProductVariant.orderItems
   */
  export type ProductVariant$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * ProductVariant.stockLogs
   */
  export type ProductVariant$stockLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    where?: StockLogWhereInput
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    cursor?: StockLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * ProductVariant without action
   */
  export type ProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    orderNumber: string | null
    status: string | null
    totalAmount: number | null
    currency: string | null
    customerInfo: string | null
    notes: string | null
    paidAt: Date | null
    rejectedAt: Date | null
    rejectionReason: string | null
    shippedAt: Date | null
    deliveredAt: Date | null
    cancelledAt: Date | null
    trackingNumber: string | null
    carrier: string | null
    deliveryNotes: string | null
    cancellationReason: string | null
    paymentProof: string | null
    clientRequestId: string | null
    customerId: string | null
    storeId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    orderNumber: string | null
    status: string | null
    totalAmount: number | null
    currency: string | null
    customerInfo: string | null
    notes: string | null
    paidAt: Date | null
    rejectedAt: Date | null
    rejectionReason: string | null
    shippedAt: Date | null
    deliveredAt: Date | null
    cancelledAt: Date | null
    trackingNumber: string | null
    carrier: string | null
    deliveryNotes: string | null
    cancellationReason: string | null
    paymentProof: string | null
    clientRequestId: string | null
    customerId: string | null
    storeId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    orderNumber: number
    status: number
    totalAmount: number
    currency: number
    customerInfo: number
    notes: number
    paidAt: number
    rejectedAt: number
    rejectionReason: number
    shippedAt: number
    deliveredAt: number
    cancelledAt: number
    trackingNumber: number
    carrier: number
    deliveryNotes: number
    cancellationReason: number
    paymentProof: number
    clientRequestId: number
    customerId: number
    storeId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalAmount?: true
  }

  export type OrderSumAggregateInputType = {
    totalAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderNumber?: true
    status?: true
    totalAmount?: true
    currency?: true
    customerInfo?: true
    notes?: true
    paidAt?: true
    rejectedAt?: true
    rejectionReason?: true
    shippedAt?: true
    deliveredAt?: true
    cancelledAt?: true
    trackingNumber?: true
    carrier?: true
    deliveryNotes?: true
    cancellationReason?: true
    paymentProof?: true
    clientRequestId?: true
    customerId?: true
    storeId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderNumber?: true
    status?: true
    totalAmount?: true
    currency?: true
    customerInfo?: true
    notes?: true
    paidAt?: true
    rejectedAt?: true
    rejectionReason?: true
    shippedAt?: true
    deliveredAt?: true
    cancelledAt?: true
    trackingNumber?: true
    carrier?: true
    deliveryNotes?: true
    cancellationReason?: true
    paymentProof?: true
    clientRequestId?: true
    customerId?: true
    storeId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderNumber?: true
    status?: true
    totalAmount?: true
    currency?: true
    customerInfo?: true
    notes?: true
    paidAt?: true
    rejectedAt?: true
    rejectionReason?: true
    shippedAt?: true
    deliveredAt?: true
    cancelledAt?: true
    trackingNumber?: true
    carrier?: true
    deliveryNotes?: true
    cancellationReason?: true
    paymentProof?: true
    clientRequestId?: true
    customerId?: true
    storeId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    orderNumber: string
    status: string
    totalAmount: number
    currency: string
    customerInfo: string
    notes: string | null
    paidAt: Date | null
    rejectedAt: Date | null
    rejectionReason: string | null
    shippedAt: Date | null
    deliveredAt: Date | null
    cancelledAt: Date | null
    trackingNumber: string | null
    carrier: string | null
    deliveryNotes: string | null
    cancellationReason: string | null
    paymentProof: string | null
    clientRequestId: string | null
    customerId: string
    storeId: string
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNumber?: boolean
    status?: boolean
    totalAmount?: boolean
    currency?: boolean
    customerInfo?: boolean
    notes?: boolean
    paidAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    cancelledAt?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    deliveryNotes?: boolean
    cancellationReason?: boolean
    paymentProof?: boolean
    clientRequestId?: boolean
    customerId?: boolean
    storeId?: boolean
    adminLogs?: boolean | Order$adminLogsArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    notifications?: boolean | Order$notificationsArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNumber?: boolean
    status?: boolean
    totalAmount?: boolean
    currency?: boolean
    customerInfo?: boolean
    notes?: boolean
    paidAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    cancelledAt?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    deliveryNotes?: boolean
    cancellationReason?: boolean
    paymentProof?: boolean
    clientRequestId?: boolean
    customerId?: boolean
    storeId?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNumber?: boolean
    status?: boolean
    totalAmount?: boolean
    currency?: boolean
    customerInfo?: boolean
    notes?: boolean
    paidAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    cancelledAt?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    deliveryNotes?: boolean
    cancellationReason?: boolean
    paymentProof?: boolean
    clientRequestId?: boolean
    customerId?: boolean
    storeId?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminLogs?: boolean | Order$adminLogsArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    notifications?: boolean | Order$notificationsArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      adminLogs: Prisma.$AdminLogPayload<ExtArgs>[]
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      customer: Prisma.$UserPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      orderNumber: string
      status: string
      totalAmount: number
      currency: string
      customerInfo: string
      notes: string | null
      paidAt: Date | null
      rejectedAt: Date | null
      rejectionReason: string | null
      shippedAt: Date | null
      deliveredAt: Date | null
      cancelledAt: Date | null
      trackingNumber: string | null
      carrier: string | null
      deliveryNotes: string | null
      cancellationReason: string | null
      paymentProof: string | null
      clientRequestId: string | null
      customerId: string
      storeId: string
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminLogs<T extends Order$adminLogsArgs<ExtArgs> = {}>(args?: Subset<T, Order$adminLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findMany"> | Null>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Order$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Order$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly totalAmount: FieldRef<"Order", 'Float'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly customerInfo: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly paidAt: FieldRef<"Order", 'DateTime'>
    readonly rejectedAt: FieldRef<"Order", 'DateTime'>
    readonly rejectionReason: FieldRef<"Order", 'String'>
    readonly shippedAt: FieldRef<"Order", 'DateTime'>
    readonly deliveredAt: FieldRef<"Order", 'DateTime'>
    readonly cancelledAt: FieldRef<"Order", 'DateTime'>
    readonly trackingNumber: FieldRef<"Order", 'String'>
    readonly carrier: FieldRef<"Order", 'String'>
    readonly deliveryNotes: FieldRef<"Order", 'String'>
    readonly cancellationReason: FieldRef<"Order", 'String'>
    readonly paymentProof: FieldRef<"Order", 'String'>
    readonly clientRequestId: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly storeId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.adminLogs
   */
  export type Order$adminLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    where?: AdminLogWhereInput
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    cursor?: AdminLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminLogScalarFieldEnum | AdminLogScalarFieldEnum[]
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.notifications
   */
  export type Order$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    quantity: number | null
    price: number | null
    orderId: string | null
    productId: string | null
    variantId: string | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    quantity: number | null
    price: number | null
    orderId: string | null
    productId: string | null
    variantId: string | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    createdAt: number
    quantity: number
    price: number
    orderId: number
    productId: number
    variantId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    quantity?: true
    price?: true
    orderId?: true
    productId?: true
    variantId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    quantity?: true
    price?: true
    orderId?: true
    productId?: true
    variantId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    quantity?: true
    price?: true
    orderId?: true
    productId?: true
    variantId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    createdAt: Date
    quantity: number
    price: number
    orderId: string
    productId: string
    variantId: string | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    productId?: boolean
    variantId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    productId?: boolean
    variantId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    productId?: boolean
    variantId?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    variant?: boolean | OrderItem$variantArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      quantity: number
      price: number
      orderId: string
      productId: string
      variantId: string | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variant<T extends OrderItem$variantArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$variantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Float'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly variantId: FieldRef<"OrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem.variant
   */
  export type OrderItem$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model AdminLog
   */

  export type AggregateAdminLog = {
    _count: AdminLogCountAggregateOutputType | null
    _min: AdminLogMinAggregateOutputType | null
    _max: AdminLogMaxAggregateOutputType | null
  }

  export type AdminLogMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    action: string | null
    details: string | null
    adminId: string | null
    orderId: string | null
  }

  export type AdminLogMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    action: string | null
    details: string | null
    adminId: string | null
    orderId: string | null
  }

  export type AdminLogCountAggregateOutputType = {
    id: number
    createdAt: number
    action: number
    details: number
    adminId: number
    orderId: number
    _all: number
  }


  export type AdminLogMinAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    details?: true
    adminId?: true
    orderId?: true
  }

  export type AdminLogMaxAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    details?: true
    adminId?: true
    orderId?: true
  }

  export type AdminLogCountAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    details?: true
    adminId?: true
    orderId?: true
    _all?: true
  }

  export type AdminLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLog to aggregate.
     */
    where?: AdminLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLogs to fetch.
     */
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminLogs
    **/
    _count?: true | AdminLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminLogMaxAggregateInputType
  }

  export type GetAdminLogAggregateType<T extends AdminLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminLog[P]>
      : GetScalarType<T[P], AggregateAdminLog[P]>
  }




  export type AdminLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLogWhereInput
    orderBy?: AdminLogOrderByWithAggregationInput | AdminLogOrderByWithAggregationInput[]
    by: AdminLogScalarFieldEnum[] | AdminLogScalarFieldEnum
    having?: AdminLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminLogCountAggregateInputType | true
    _min?: AdminLogMinAggregateInputType
    _max?: AdminLogMaxAggregateInputType
  }

  export type AdminLogGroupByOutputType = {
    id: string
    createdAt: Date
    action: string
    details: string | null
    adminId: string
    orderId: string | null
    _count: AdminLogCountAggregateOutputType | null
    _min: AdminLogMinAggregateOutputType | null
    _max: AdminLogMaxAggregateOutputType | null
  }

  type GetAdminLogGroupByPayload<T extends AdminLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    details?: boolean
    adminId?: boolean
    orderId?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | AdminLog$orderArgs<ExtArgs>
  }, ExtArgs["result"]["adminLog"]>

  export type AdminLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    details?: boolean
    adminId?: boolean
    orderId?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | AdminLog$orderArgs<ExtArgs>
  }, ExtArgs["result"]["adminLog"]>

  export type AdminLogSelectScalar = {
    id?: boolean
    createdAt?: boolean
    action?: boolean
    details?: boolean
    adminId?: boolean
    orderId?: boolean
  }

  export type AdminLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | AdminLog$orderArgs<ExtArgs>
  }
  export type AdminLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | AdminLog$orderArgs<ExtArgs>
  }

  export type $AdminLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      action: string
      details: string | null
      adminId: string
      orderId: string | null
    }, ExtArgs["result"]["adminLog"]>
    composites: {}
  }

  type AdminLogGetPayload<S extends boolean | null | undefined | AdminLogDefaultArgs> = $Result.GetResult<Prisma.$AdminLogPayload, S>

  type AdminLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminLogCountAggregateInputType | true
    }

  export interface AdminLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminLog'], meta: { name: 'AdminLog' } }
    /**
     * Find zero or one AdminLog that matches the filter.
     * @param {AdminLogFindUniqueArgs} args - Arguments to find a AdminLog
     * @example
     * // Get one AdminLog
     * const adminLog = await prisma.adminLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminLogFindUniqueArgs>(args: SelectSubset<T, AdminLogFindUniqueArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminLogFindUniqueOrThrowArgs} args - Arguments to find a AdminLog
     * @example
     * // Get one AdminLog
     * const adminLog = await prisma.adminLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogFindFirstArgs} args - Arguments to find a AdminLog
     * @example
     * // Get one AdminLog
     * const adminLog = await prisma.adminLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminLogFindFirstArgs>(args?: SelectSubset<T, AdminLogFindFirstArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogFindFirstOrThrowArgs} args - Arguments to find a AdminLog
     * @example
     * // Get one AdminLog
     * const adminLog = await prisma.adminLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminLogs
     * const adminLogs = await prisma.adminLog.findMany()
     * 
     * // Get first 10 AdminLogs
     * const adminLogs = await prisma.adminLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminLogWithIdOnly = await prisma.adminLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminLogFindManyArgs>(args?: SelectSubset<T, AdminLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminLog.
     * @param {AdminLogCreateArgs} args - Arguments to create a AdminLog.
     * @example
     * // Create one AdminLog
     * const AdminLog = await prisma.adminLog.create({
     *   data: {
     *     // ... data to create a AdminLog
     *   }
     * })
     * 
     */
    create<T extends AdminLogCreateArgs>(args: SelectSubset<T, AdminLogCreateArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminLogs.
     * @param {AdminLogCreateManyArgs} args - Arguments to create many AdminLogs.
     * @example
     * // Create many AdminLogs
     * const adminLog = await prisma.adminLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminLogCreateManyArgs>(args?: SelectSubset<T, AdminLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminLogs and returns the data saved in the database.
     * @param {AdminLogCreateManyAndReturnArgs} args - Arguments to create many AdminLogs.
     * @example
     * // Create many AdminLogs
     * const adminLog = await prisma.adminLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminLogs and only return the `id`
     * const adminLogWithIdOnly = await prisma.adminLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminLog.
     * @param {AdminLogDeleteArgs} args - Arguments to delete one AdminLog.
     * @example
     * // Delete one AdminLog
     * const AdminLog = await prisma.adminLog.delete({
     *   where: {
     *     // ... filter to delete one AdminLog
     *   }
     * })
     * 
     */
    delete<T extends AdminLogDeleteArgs>(args: SelectSubset<T, AdminLogDeleteArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminLog.
     * @param {AdminLogUpdateArgs} args - Arguments to update one AdminLog.
     * @example
     * // Update one AdminLog
     * const adminLog = await prisma.adminLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminLogUpdateArgs>(args: SelectSubset<T, AdminLogUpdateArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminLogs.
     * @param {AdminLogDeleteManyArgs} args - Arguments to filter AdminLogs to delete.
     * @example
     * // Delete a few AdminLogs
     * const { count } = await prisma.adminLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminLogDeleteManyArgs>(args?: SelectSubset<T, AdminLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminLogs
     * const adminLog = await prisma.adminLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminLogUpdateManyArgs>(args: SelectSubset<T, AdminLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminLog.
     * @param {AdminLogUpsertArgs} args - Arguments to update or create a AdminLog.
     * @example
     * // Update or create a AdminLog
     * const adminLog = await prisma.adminLog.upsert({
     *   create: {
     *     // ... data to create a AdminLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminLogUpsertArgs>(args: SelectSubset<T, AdminLogUpsertArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogCountArgs} args - Arguments to filter AdminLogs to count.
     * @example
     * // Count the number of AdminLogs
     * const count = await prisma.adminLog.count({
     *   where: {
     *     // ... the filter for the AdminLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminLogCountArgs>(
      args?: Subset<T, AdminLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminLogAggregateArgs>(args: Subset<T, AdminLogAggregateArgs>): Prisma.PrismaPromise<GetAdminLogAggregateType<T>>

    /**
     * Group by AdminLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminLog model
   */
  readonly fields: AdminLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order<T extends AdminLog$orderArgs<ExtArgs> = {}>(args?: Subset<T, AdminLog$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminLog model
   */ 
  interface AdminLogFieldRefs {
    readonly id: FieldRef<"AdminLog", 'String'>
    readonly createdAt: FieldRef<"AdminLog", 'DateTime'>
    readonly action: FieldRef<"AdminLog", 'String'>
    readonly details: FieldRef<"AdminLog", 'String'>
    readonly adminId: FieldRef<"AdminLog", 'String'>
    readonly orderId: FieldRef<"AdminLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminLog findUnique
   */
  export type AdminLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLog to fetch.
     */
    where: AdminLogWhereUniqueInput
  }

  /**
   * AdminLog findUniqueOrThrow
   */
  export type AdminLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLog to fetch.
     */
    where: AdminLogWhereUniqueInput
  }

  /**
   * AdminLog findFirst
   */
  export type AdminLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLog to fetch.
     */
    where?: AdminLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLogs to fetch.
     */
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLogs.
     */
    cursor?: AdminLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLogs.
     */
    distinct?: AdminLogScalarFieldEnum | AdminLogScalarFieldEnum[]
  }

  /**
   * AdminLog findFirstOrThrow
   */
  export type AdminLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLog to fetch.
     */
    where?: AdminLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLogs to fetch.
     */
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLogs.
     */
    cursor?: AdminLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLogs.
     */
    distinct?: AdminLogScalarFieldEnum | AdminLogScalarFieldEnum[]
  }

  /**
   * AdminLog findMany
   */
  export type AdminLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLogs to fetch.
     */
    where?: AdminLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLogs to fetch.
     */
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminLogs.
     */
    cursor?: AdminLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLogs.
     */
    skip?: number
    distinct?: AdminLogScalarFieldEnum | AdminLogScalarFieldEnum[]
  }

  /**
   * AdminLog create
   */
  export type AdminLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminLog.
     */
    data: XOR<AdminLogCreateInput, AdminLogUncheckedCreateInput>
  }

  /**
   * AdminLog createMany
   */
  export type AdminLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminLogs.
     */
    data: AdminLogCreateManyInput | AdminLogCreateManyInput[]
  }

  /**
   * AdminLog createManyAndReturn
   */
  export type AdminLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminLogs.
     */
    data: AdminLogCreateManyInput | AdminLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminLog update
   */
  export type AdminLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminLog.
     */
    data: XOR<AdminLogUpdateInput, AdminLogUncheckedUpdateInput>
    /**
     * Choose, which AdminLog to update.
     */
    where: AdminLogWhereUniqueInput
  }

  /**
   * AdminLog updateMany
   */
  export type AdminLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminLogs.
     */
    data: XOR<AdminLogUpdateManyMutationInput, AdminLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminLogs to update
     */
    where?: AdminLogWhereInput
  }

  /**
   * AdminLog upsert
   */
  export type AdminLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminLog to update in case it exists.
     */
    where: AdminLogWhereUniqueInput
    /**
     * In case the AdminLog found by the `where` argument doesn't exist, create a new AdminLog with this data.
     */
    create: XOR<AdminLogCreateInput, AdminLogUncheckedCreateInput>
    /**
     * In case the AdminLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminLogUpdateInput, AdminLogUncheckedUpdateInput>
  }

  /**
   * AdminLog delete
   */
  export type AdminLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter which AdminLog to delete.
     */
    where: AdminLogWhereUniqueInput
  }

  /**
   * AdminLog deleteMany
   */
  export type AdminLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLogs to delete
     */
    where?: AdminLogWhereInput
  }

  /**
   * AdminLog.order
   */
  export type AdminLog$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * AdminLog without action
   */
  export type AdminLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
  }


  /**
   * Model IntegrationMapping
   */

  export type AggregateIntegrationMapping = {
    _count: IntegrationMappingCountAggregateOutputType | null
    _min: IntegrationMappingMinAggregateOutputType | null
    _max: IntegrationMappingMaxAggregateOutputType | null
  }

  export type IntegrationMappingMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    source: string | null
    entityType: string | null
    localId: string | null
    externalId: string | null
    storeId: string | null
  }

  export type IntegrationMappingMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    source: string | null
    entityType: string | null
    localId: string | null
    externalId: string | null
    storeId: string | null
  }

  export type IntegrationMappingCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    source: number
    entityType: number
    localId: number
    externalId: number
    storeId: number
    _all: number
  }


  export type IntegrationMappingMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    source?: true
    entityType?: true
    localId?: true
    externalId?: true
    storeId?: true
  }

  export type IntegrationMappingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    source?: true
    entityType?: true
    localId?: true
    externalId?: true
    storeId?: true
  }

  export type IntegrationMappingCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    source?: true
    entityType?: true
    localId?: true
    externalId?: true
    storeId?: true
    _all?: true
  }

  export type IntegrationMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationMapping to aggregate.
     */
    where?: IntegrationMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationMappings to fetch.
     */
    orderBy?: IntegrationMappingOrderByWithRelationInput | IntegrationMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegrationMappings
    **/
    _count?: true | IntegrationMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMappingMaxAggregateInputType
  }

  export type GetIntegrationMappingAggregateType<T extends IntegrationMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegrationMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegrationMapping[P]>
      : GetScalarType<T[P], AggregateIntegrationMapping[P]>
  }




  export type IntegrationMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationMappingWhereInput
    orderBy?: IntegrationMappingOrderByWithAggregationInput | IntegrationMappingOrderByWithAggregationInput[]
    by: IntegrationMappingScalarFieldEnum[] | IntegrationMappingScalarFieldEnum
    having?: IntegrationMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationMappingCountAggregateInputType | true
    _min?: IntegrationMappingMinAggregateInputType
    _max?: IntegrationMappingMaxAggregateInputType
  }

  export type IntegrationMappingGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    source: string
    entityType: string
    localId: string
    externalId: string
    storeId: string | null
    _count: IntegrationMappingCountAggregateOutputType | null
    _min: IntegrationMappingMinAggregateOutputType | null
    _max: IntegrationMappingMaxAggregateOutputType | null
  }

  type GetIntegrationMappingGroupByPayload<T extends IntegrationMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationMappingGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationMappingGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean
    entityType?: boolean
    localId?: boolean
    externalId?: boolean
    storeId?: boolean
    store?: boolean | IntegrationMapping$storeArgs<ExtArgs>
  }, ExtArgs["result"]["integrationMapping"]>

  export type IntegrationMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean
    entityType?: boolean
    localId?: boolean
    externalId?: boolean
    storeId?: boolean
    store?: boolean | IntegrationMapping$storeArgs<ExtArgs>
  }, ExtArgs["result"]["integrationMapping"]>

  export type IntegrationMappingSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean
    entityType?: boolean
    localId?: boolean
    externalId?: boolean
    storeId?: boolean
  }

  export type IntegrationMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | IntegrationMapping$storeArgs<ExtArgs>
  }
  export type IntegrationMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | IntegrationMapping$storeArgs<ExtArgs>
  }

  export type $IntegrationMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegrationMapping"
    objects: {
      store: Prisma.$StorePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      source: string
      entityType: string
      localId: string
      externalId: string
      storeId: string | null
    }, ExtArgs["result"]["integrationMapping"]>
    composites: {}
  }

  type IntegrationMappingGetPayload<S extends boolean | null | undefined | IntegrationMappingDefaultArgs> = $Result.GetResult<Prisma.$IntegrationMappingPayload, S>

  type IntegrationMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegrationMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegrationMappingCountAggregateInputType | true
    }

  export interface IntegrationMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegrationMapping'], meta: { name: 'IntegrationMapping' } }
    /**
     * Find zero or one IntegrationMapping that matches the filter.
     * @param {IntegrationMappingFindUniqueArgs} args - Arguments to find a IntegrationMapping
     * @example
     * // Get one IntegrationMapping
     * const integrationMapping = await prisma.integrationMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationMappingFindUniqueArgs>(args: SelectSubset<T, IntegrationMappingFindUniqueArgs<ExtArgs>>): Prisma__IntegrationMappingClient<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IntegrationMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegrationMappingFindUniqueOrThrowArgs} args - Arguments to find a IntegrationMapping
     * @example
     * // Get one IntegrationMapping
     * const integrationMapping = await prisma.integrationMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationMappingClient<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IntegrationMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationMappingFindFirstArgs} args - Arguments to find a IntegrationMapping
     * @example
     * // Get one IntegrationMapping
     * const integrationMapping = await prisma.integrationMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationMappingFindFirstArgs>(args?: SelectSubset<T, IntegrationMappingFindFirstArgs<ExtArgs>>): Prisma__IntegrationMappingClient<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IntegrationMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationMappingFindFirstOrThrowArgs} args - Arguments to find a IntegrationMapping
     * @example
     * // Get one IntegrationMapping
     * const integrationMapping = await prisma.integrationMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationMappingClient<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IntegrationMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegrationMappings
     * const integrationMappings = await prisma.integrationMapping.findMany()
     * 
     * // Get first 10 IntegrationMappings
     * const integrationMappings = await prisma.integrationMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationMappingWithIdOnly = await prisma.integrationMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationMappingFindManyArgs>(args?: SelectSubset<T, IntegrationMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IntegrationMapping.
     * @param {IntegrationMappingCreateArgs} args - Arguments to create a IntegrationMapping.
     * @example
     * // Create one IntegrationMapping
     * const IntegrationMapping = await prisma.integrationMapping.create({
     *   data: {
     *     // ... data to create a IntegrationMapping
     *   }
     * })
     * 
     */
    create<T extends IntegrationMappingCreateArgs>(args: SelectSubset<T, IntegrationMappingCreateArgs<ExtArgs>>): Prisma__IntegrationMappingClient<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IntegrationMappings.
     * @param {IntegrationMappingCreateManyArgs} args - Arguments to create many IntegrationMappings.
     * @example
     * // Create many IntegrationMappings
     * const integrationMapping = await prisma.integrationMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationMappingCreateManyArgs>(args?: SelectSubset<T, IntegrationMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntegrationMappings and returns the data saved in the database.
     * @param {IntegrationMappingCreateManyAndReturnArgs} args - Arguments to create many IntegrationMappings.
     * @example
     * // Create many IntegrationMappings
     * const integrationMapping = await prisma.integrationMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntegrationMappings and only return the `id`
     * const integrationMappingWithIdOnly = await prisma.integrationMapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IntegrationMapping.
     * @param {IntegrationMappingDeleteArgs} args - Arguments to delete one IntegrationMapping.
     * @example
     * // Delete one IntegrationMapping
     * const IntegrationMapping = await prisma.integrationMapping.delete({
     *   where: {
     *     // ... filter to delete one IntegrationMapping
     *   }
     * })
     * 
     */
    delete<T extends IntegrationMappingDeleteArgs>(args: SelectSubset<T, IntegrationMappingDeleteArgs<ExtArgs>>): Prisma__IntegrationMappingClient<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IntegrationMapping.
     * @param {IntegrationMappingUpdateArgs} args - Arguments to update one IntegrationMapping.
     * @example
     * // Update one IntegrationMapping
     * const integrationMapping = await prisma.integrationMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationMappingUpdateArgs>(args: SelectSubset<T, IntegrationMappingUpdateArgs<ExtArgs>>): Prisma__IntegrationMappingClient<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IntegrationMappings.
     * @param {IntegrationMappingDeleteManyArgs} args - Arguments to filter IntegrationMappings to delete.
     * @example
     * // Delete a few IntegrationMappings
     * const { count } = await prisma.integrationMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationMappingDeleteManyArgs>(args?: SelectSubset<T, IntegrationMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegrationMappings
     * const integrationMapping = await prisma.integrationMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationMappingUpdateManyArgs>(args: SelectSubset<T, IntegrationMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntegrationMapping.
     * @param {IntegrationMappingUpsertArgs} args - Arguments to update or create a IntegrationMapping.
     * @example
     * // Update or create a IntegrationMapping
     * const integrationMapping = await prisma.integrationMapping.upsert({
     *   create: {
     *     // ... data to create a IntegrationMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegrationMapping we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationMappingUpsertArgs>(args: SelectSubset<T, IntegrationMappingUpsertArgs<ExtArgs>>): Prisma__IntegrationMappingClient<$Result.GetResult<Prisma.$IntegrationMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IntegrationMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationMappingCountArgs} args - Arguments to filter IntegrationMappings to count.
     * @example
     * // Count the number of IntegrationMappings
     * const count = await prisma.integrationMapping.count({
     *   where: {
     *     // ... the filter for the IntegrationMappings we want to count
     *   }
     * })
    **/
    count<T extends IntegrationMappingCountArgs>(
      args?: Subset<T, IntegrationMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegrationMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationMappingAggregateArgs>(args: Subset<T, IntegrationMappingAggregateArgs>): Prisma.PrismaPromise<GetIntegrationMappingAggregateType<T>>

    /**
     * Group by IntegrationMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationMappingGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegrationMapping model
   */
  readonly fields: IntegrationMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegrationMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends IntegrationMapping$storeArgs<ExtArgs> = {}>(args?: Subset<T, IntegrationMapping$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegrationMapping model
   */ 
  interface IntegrationMappingFieldRefs {
    readonly id: FieldRef<"IntegrationMapping", 'String'>
    readonly createdAt: FieldRef<"IntegrationMapping", 'DateTime'>
    readonly updatedAt: FieldRef<"IntegrationMapping", 'DateTime'>
    readonly source: FieldRef<"IntegrationMapping", 'String'>
    readonly entityType: FieldRef<"IntegrationMapping", 'String'>
    readonly localId: FieldRef<"IntegrationMapping", 'String'>
    readonly externalId: FieldRef<"IntegrationMapping", 'String'>
    readonly storeId: FieldRef<"IntegrationMapping", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IntegrationMapping findUnique
   */
  export type IntegrationMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationMapping to fetch.
     */
    where: IntegrationMappingWhereUniqueInput
  }

  /**
   * IntegrationMapping findUniqueOrThrow
   */
  export type IntegrationMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationMapping to fetch.
     */
    where: IntegrationMappingWhereUniqueInput
  }

  /**
   * IntegrationMapping findFirst
   */
  export type IntegrationMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationMapping to fetch.
     */
    where?: IntegrationMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationMappings to fetch.
     */
    orderBy?: IntegrationMappingOrderByWithRelationInput | IntegrationMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationMappings.
     */
    cursor?: IntegrationMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationMappings.
     */
    distinct?: IntegrationMappingScalarFieldEnum | IntegrationMappingScalarFieldEnum[]
  }

  /**
   * IntegrationMapping findFirstOrThrow
   */
  export type IntegrationMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationMapping to fetch.
     */
    where?: IntegrationMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationMappings to fetch.
     */
    orderBy?: IntegrationMappingOrderByWithRelationInput | IntegrationMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationMappings.
     */
    cursor?: IntegrationMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationMappings.
     */
    distinct?: IntegrationMappingScalarFieldEnum | IntegrationMappingScalarFieldEnum[]
  }

  /**
   * IntegrationMapping findMany
   */
  export type IntegrationMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationMappings to fetch.
     */
    where?: IntegrationMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationMappings to fetch.
     */
    orderBy?: IntegrationMappingOrderByWithRelationInput | IntegrationMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegrationMappings.
     */
    cursor?: IntegrationMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationMappings.
     */
    skip?: number
    distinct?: IntegrationMappingScalarFieldEnum | IntegrationMappingScalarFieldEnum[]
  }

  /**
   * IntegrationMapping create
   */
  export type IntegrationMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegrationMapping.
     */
    data: XOR<IntegrationMappingCreateInput, IntegrationMappingUncheckedCreateInput>
  }

  /**
   * IntegrationMapping createMany
   */
  export type IntegrationMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegrationMappings.
     */
    data: IntegrationMappingCreateManyInput | IntegrationMappingCreateManyInput[]
  }

  /**
   * IntegrationMapping createManyAndReturn
   */
  export type IntegrationMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IntegrationMappings.
     */
    data: IntegrationMappingCreateManyInput | IntegrationMappingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegrationMapping update
   */
  export type IntegrationMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegrationMapping.
     */
    data: XOR<IntegrationMappingUpdateInput, IntegrationMappingUncheckedUpdateInput>
    /**
     * Choose, which IntegrationMapping to update.
     */
    where: IntegrationMappingWhereUniqueInput
  }

  /**
   * IntegrationMapping updateMany
   */
  export type IntegrationMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegrationMappings.
     */
    data: XOR<IntegrationMappingUpdateManyMutationInput, IntegrationMappingUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationMappings to update
     */
    where?: IntegrationMappingWhereInput
  }

  /**
   * IntegrationMapping upsert
   */
  export type IntegrationMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegrationMapping to update in case it exists.
     */
    where: IntegrationMappingWhereUniqueInput
    /**
     * In case the IntegrationMapping found by the `where` argument doesn't exist, create a new IntegrationMapping with this data.
     */
    create: XOR<IntegrationMappingCreateInput, IntegrationMappingUncheckedCreateInput>
    /**
     * In case the IntegrationMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationMappingUpdateInput, IntegrationMappingUncheckedUpdateInput>
  }

  /**
   * IntegrationMapping delete
   */
  export type IntegrationMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
    /**
     * Filter which IntegrationMapping to delete.
     */
    where: IntegrationMappingWhereUniqueInput
  }

  /**
   * IntegrationMapping deleteMany
   */
  export type IntegrationMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationMappings to delete
     */
    where?: IntegrationMappingWhereInput
  }

  /**
   * IntegrationMapping.store
   */
  export type IntegrationMapping$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * IntegrationMapping without action
   */
  export type IntegrationMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationMapping
     */
    select?: IntegrationMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationMappingInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: string | null
    title: string | null
    message: string | null
    priority: string | null
    channels: string | null
    data: string | null
    readAt: Date | null
    storeId: string | null
    orderId: string | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: string | null
    title: string | null
    message: string | null
    priority: string | null
    channels: string | null
    data: string | null
    readAt: Date | null
    storeId: string | null
    orderId: string | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    type: number
    title: number
    message: number
    priority: number
    channels: number
    data: number
    readAt: number
    storeId: number
    orderId: number
    userId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    channels?: true
    data?: true
    readAt?: true
    storeId?: true
    orderId?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    channels?: true
    data?: true
    readAt?: true
    storeId?: true
    orderId?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    channels?: true
    data?: true
    readAt?: true
    storeId?: true
    orderId?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    type: string
    title: string
    message: string
    priority: string
    channels: string
    data: string | null
    readAt: Date | null
    storeId: string | null
    orderId: string | null
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channels?: boolean
    data?: boolean
    readAt?: boolean
    storeId?: boolean
    orderId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | Notification$storeArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channels?: boolean
    data?: boolean
    readAt?: boolean
    storeId?: boolean
    orderId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | Notification$storeArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channels?: boolean
    data?: boolean
    readAt?: boolean
    storeId?: boolean
    orderId?: boolean
    userId?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | Notification$storeArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | Notification$storeArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      type: string
      title: string
      message: string
      priority: string
      channels: string
      data: string | null
      readAt: Date | null
      storeId: string | null
      orderId: string | null
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    store<T extends Notification$storeArgs<ExtArgs> = {}>(args?: Subset<T, Notification$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order<T extends Notification$orderArgs<ExtArgs> = {}>(args?: Subset<T, Notification$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly priority: FieldRef<"Notification", 'String'>
    readonly channels: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'String'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly storeId: FieldRef<"Notification", 'String'>
    readonly orderId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.store
   */
  export type Notification$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * Notification.order
   */
  export type Notification$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    refreshToken: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    isRevoked: boolean | null
    revokedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    refreshToken: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    isRevoked: boolean | null
    revokedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    refreshToken: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    isRevoked: number
    revokedAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    refreshToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    isRevoked?: true
    revokedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    refreshToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    isRevoked?: true
    revokedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    refreshToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    isRevoked?: true
    revokedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    refreshToken: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    isRevoked: boolean
    revokedAt: Date | null
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
  }

  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      refreshToken: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      isRevoked: boolean
      revokedAt: Date | null
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */ 
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly refreshToken: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly isRevoked: FieldRef<"UserSession", 'Boolean'>
    readonly revokedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model RevokedToken
   */

  export type AggregateRevokedToken = {
    _count: RevokedTokenCountAggregateOutputType | null
    _min: RevokedTokenMinAggregateOutputType | null
    _max: RevokedTokenMaxAggregateOutputType | null
  }

  export type RevokedTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    reason: string | null
  }

  export type RevokedTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    reason: string | null
  }

  export type RevokedTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    revokedAt: number
    expiresAt: number
    reason: number
    _all: number
  }


  export type RevokedTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    revokedAt?: true
    expiresAt?: true
    reason?: true
  }

  export type RevokedTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    revokedAt?: true
    expiresAt?: true
    reason?: true
  }

  export type RevokedTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    revokedAt?: true
    expiresAt?: true
    reason?: true
    _all?: true
  }

  export type RevokedTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevokedToken to aggregate.
     */
    where?: RevokedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevokedTokens to fetch.
     */
    orderBy?: RevokedTokenOrderByWithRelationInput | RevokedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevokedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevokedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevokedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RevokedTokens
    **/
    _count?: true | RevokedTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevokedTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevokedTokenMaxAggregateInputType
  }

  export type GetRevokedTokenAggregateType<T extends RevokedTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRevokedToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevokedToken[P]>
      : GetScalarType<T[P], AggregateRevokedToken[P]>
  }




  export type RevokedTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevokedTokenWhereInput
    orderBy?: RevokedTokenOrderByWithAggregationInput | RevokedTokenOrderByWithAggregationInput[]
    by: RevokedTokenScalarFieldEnum[] | RevokedTokenScalarFieldEnum
    having?: RevokedTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevokedTokenCountAggregateInputType | true
    _min?: RevokedTokenMinAggregateInputType
    _max?: RevokedTokenMaxAggregateInputType
  }

  export type RevokedTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    revokedAt: Date
    expiresAt: Date
    reason: string | null
    _count: RevokedTokenCountAggregateOutputType | null
    _min: RevokedTokenMinAggregateOutputType | null
    _max: RevokedTokenMaxAggregateOutputType | null
  }

  type GetRevokedTokenGroupByPayload<T extends RevokedTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevokedTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevokedTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevokedTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RevokedTokenGroupByOutputType[P]>
        }
      >
    >


  export type RevokedTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    reason?: boolean
  }, ExtArgs["result"]["revokedToken"]>

  export type RevokedTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    reason?: boolean
  }, ExtArgs["result"]["revokedToken"]>

  export type RevokedTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    reason?: boolean
  }


  export type $RevokedTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RevokedToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      revokedAt: Date
      expiresAt: Date
      reason: string | null
    }, ExtArgs["result"]["revokedToken"]>
    composites: {}
  }

  type RevokedTokenGetPayload<S extends boolean | null | undefined | RevokedTokenDefaultArgs> = $Result.GetResult<Prisma.$RevokedTokenPayload, S>

  type RevokedTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RevokedTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RevokedTokenCountAggregateInputType | true
    }

  export interface RevokedTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RevokedToken'], meta: { name: 'RevokedToken' } }
    /**
     * Find zero or one RevokedToken that matches the filter.
     * @param {RevokedTokenFindUniqueArgs} args - Arguments to find a RevokedToken
     * @example
     * // Get one RevokedToken
     * const revokedToken = await prisma.revokedToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevokedTokenFindUniqueArgs>(args: SelectSubset<T, RevokedTokenFindUniqueArgs<ExtArgs>>): Prisma__RevokedTokenClient<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RevokedToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RevokedTokenFindUniqueOrThrowArgs} args - Arguments to find a RevokedToken
     * @example
     * // Get one RevokedToken
     * const revokedToken = await prisma.revokedToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevokedTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RevokedTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevokedTokenClient<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RevokedToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevokedTokenFindFirstArgs} args - Arguments to find a RevokedToken
     * @example
     * // Get one RevokedToken
     * const revokedToken = await prisma.revokedToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevokedTokenFindFirstArgs>(args?: SelectSubset<T, RevokedTokenFindFirstArgs<ExtArgs>>): Prisma__RevokedTokenClient<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RevokedToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevokedTokenFindFirstOrThrowArgs} args - Arguments to find a RevokedToken
     * @example
     * // Get one RevokedToken
     * const revokedToken = await prisma.revokedToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevokedTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RevokedTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevokedTokenClient<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RevokedTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevokedTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RevokedTokens
     * const revokedTokens = await prisma.revokedToken.findMany()
     * 
     * // Get first 10 RevokedTokens
     * const revokedTokens = await prisma.revokedToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revokedTokenWithIdOnly = await prisma.revokedToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevokedTokenFindManyArgs>(args?: SelectSubset<T, RevokedTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RevokedToken.
     * @param {RevokedTokenCreateArgs} args - Arguments to create a RevokedToken.
     * @example
     * // Create one RevokedToken
     * const RevokedToken = await prisma.revokedToken.create({
     *   data: {
     *     // ... data to create a RevokedToken
     *   }
     * })
     * 
     */
    create<T extends RevokedTokenCreateArgs>(args: SelectSubset<T, RevokedTokenCreateArgs<ExtArgs>>): Prisma__RevokedTokenClient<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RevokedTokens.
     * @param {RevokedTokenCreateManyArgs} args - Arguments to create many RevokedTokens.
     * @example
     * // Create many RevokedTokens
     * const revokedToken = await prisma.revokedToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevokedTokenCreateManyArgs>(args?: SelectSubset<T, RevokedTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RevokedTokens and returns the data saved in the database.
     * @param {RevokedTokenCreateManyAndReturnArgs} args - Arguments to create many RevokedTokens.
     * @example
     * // Create many RevokedTokens
     * const revokedToken = await prisma.revokedToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RevokedTokens and only return the `id`
     * const revokedTokenWithIdOnly = await prisma.revokedToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevokedTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RevokedTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RevokedToken.
     * @param {RevokedTokenDeleteArgs} args - Arguments to delete one RevokedToken.
     * @example
     * // Delete one RevokedToken
     * const RevokedToken = await prisma.revokedToken.delete({
     *   where: {
     *     // ... filter to delete one RevokedToken
     *   }
     * })
     * 
     */
    delete<T extends RevokedTokenDeleteArgs>(args: SelectSubset<T, RevokedTokenDeleteArgs<ExtArgs>>): Prisma__RevokedTokenClient<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RevokedToken.
     * @param {RevokedTokenUpdateArgs} args - Arguments to update one RevokedToken.
     * @example
     * // Update one RevokedToken
     * const revokedToken = await prisma.revokedToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevokedTokenUpdateArgs>(args: SelectSubset<T, RevokedTokenUpdateArgs<ExtArgs>>): Prisma__RevokedTokenClient<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RevokedTokens.
     * @param {RevokedTokenDeleteManyArgs} args - Arguments to filter RevokedTokens to delete.
     * @example
     * // Delete a few RevokedTokens
     * const { count } = await prisma.revokedToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevokedTokenDeleteManyArgs>(args?: SelectSubset<T, RevokedTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevokedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevokedTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RevokedTokens
     * const revokedToken = await prisma.revokedToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevokedTokenUpdateManyArgs>(args: SelectSubset<T, RevokedTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RevokedToken.
     * @param {RevokedTokenUpsertArgs} args - Arguments to update or create a RevokedToken.
     * @example
     * // Update or create a RevokedToken
     * const revokedToken = await prisma.revokedToken.upsert({
     *   create: {
     *     // ... data to create a RevokedToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RevokedToken we want to update
     *   }
     * })
     */
    upsert<T extends RevokedTokenUpsertArgs>(args: SelectSubset<T, RevokedTokenUpsertArgs<ExtArgs>>): Prisma__RevokedTokenClient<$Result.GetResult<Prisma.$RevokedTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RevokedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevokedTokenCountArgs} args - Arguments to filter RevokedTokens to count.
     * @example
     * // Count the number of RevokedTokens
     * const count = await prisma.revokedToken.count({
     *   where: {
     *     // ... the filter for the RevokedTokens we want to count
     *   }
     * })
    **/
    count<T extends RevokedTokenCountArgs>(
      args?: Subset<T, RevokedTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevokedTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RevokedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevokedTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevokedTokenAggregateArgs>(args: Subset<T, RevokedTokenAggregateArgs>): Prisma.PrismaPromise<GetRevokedTokenAggregateType<T>>

    /**
     * Group by RevokedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevokedTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevokedTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevokedTokenGroupByArgs['orderBy'] }
        : { orderBy?: RevokedTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevokedTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevokedTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RevokedToken model
   */
  readonly fields: RevokedTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RevokedToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevokedTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RevokedToken model
   */ 
  interface RevokedTokenFieldRefs {
    readonly id: FieldRef<"RevokedToken", 'String'>
    readonly token: FieldRef<"RevokedToken", 'String'>
    readonly userId: FieldRef<"RevokedToken", 'String'>
    readonly revokedAt: FieldRef<"RevokedToken", 'DateTime'>
    readonly expiresAt: FieldRef<"RevokedToken", 'DateTime'>
    readonly reason: FieldRef<"RevokedToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RevokedToken findUnique
   */
  export type RevokedTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
    /**
     * Filter, which RevokedToken to fetch.
     */
    where: RevokedTokenWhereUniqueInput
  }

  /**
   * RevokedToken findUniqueOrThrow
   */
  export type RevokedTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
    /**
     * Filter, which RevokedToken to fetch.
     */
    where: RevokedTokenWhereUniqueInput
  }

  /**
   * RevokedToken findFirst
   */
  export type RevokedTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
    /**
     * Filter, which RevokedToken to fetch.
     */
    where?: RevokedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevokedTokens to fetch.
     */
    orderBy?: RevokedTokenOrderByWithRelationInput | RevokedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevokedTokens.
     */
    cursor?: RevokedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevokedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevokedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevokedTokens.
     */
    distinct?: RevokedTokenScalarFieldEnum | RevokedTokenScalarFieldEnum[]
  }

  /**
   * RevokedToken findFirstOrThrow
   */
  export type RevokedTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
    /**
     * Filter, which RevokedToken to fetch.
     */
    where?: RevokedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevokedTokens to fetch.
     */
    orderBy?: RevokedTokenOrderByWithRelationInput | RevokedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevokedTokens.
     */
    cursor?: RevokedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevokedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevokedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevokedTokens.
     */
    distinct?: RevokedTokenScalarFieldEnum | RevokedTokenScalarFieldEnum[]
  }

  /**
   * RevokedToken findMany
   */
  export type RevokedTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
    /**
     * Filter, which RevokedTokens to fetch.
     */
    where?: RevokedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevokedTokens to fetch.
     */
    orderBy?: RevokedTokenOrderByWithRelationInput | RevokedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RevokedTokens.
     */
    cursor?: RevokedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevokedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevokedTokens.
     */
    skip?: number
    distinct?: RevokedTokenScalarFieldEnum | RevokedTokenScalarFieldEnum[]
  }

  /**
   * RevokedToken create
   */
  export type RevokedTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a RevokedToken.
     */
    data: XOR<RevokedTokenCreateInput, RevokedTokenUncheckedCreateInput>
  }

  /**
   * RevokedToken createMany
   */
  export type RevokedTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RevokedTokens.
     */
    data: RevokedTokenCreateManyInput | RevokedTokenCreateManyInput[]
  }

  /**
   * RevokedToken createManyAndReturn
   */
  export type RevokedTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RevokedTokens.
     */
    data: RevokedTokenCreateManyInput | RevokedTokenCreateManyInput[]
  }

  /**
   * RevokedToken update
   */
  export type RevokedTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a RevokedToken.
     */
    data: XOR<RevokedTokenUpdateInput, RevokedTokenUncheckedUpdateInput>
    /**
     * Choose, which RevokedToken to update.
     */
    where: RevokedTokenWhereUniqueInput
  }

  /**
   * RevokedToken updateMany
   */
  export type RevokedTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RevokedTokens.
     */
    data: XOR<RevokedTokenUpdateManyMutationInput, RevokedTokenUncheckedUpdateManyInput>
    /**
     * Filter which RevokedTokens to update
     */
    where?: RevokedTokenWhereInput
  }

  /**
   * RevokedToken upsert
   */
  export type RevokedTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the RevokedToken to update in case it exists.
     */
    where: RevokedTokenWhereUniqueInput
    /**
     * In case the RevokedToken found by the `where` argument doesn't exist, create a new RevokedToken with this data.
     */
    create: XOR<RevokedTokenCreateInput, RevokedTokenUncheckedCreateInput>
    /**
     * In case the RevokedToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevokedTokenUpdateInput, RevokedTokenUncheckedUpdateInput>
  }

  /**
   * RevokedToken delete
   */
  export type RevokedTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
    /**
     * Filter which RevokedToken to delete.
     */
    where: RevokedTokenWhereUniqueInput
  }

  /**
   * RevokedToken deleteMany
   */
  export type RevokedTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevokedTokens to delete
     */
    where?: RevokedTokenWhereInput
  }

  /**
   * RevokedToken without action
   */
  export type RevokedTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevokedToken
     */
    select?: RevokedTokenSelect<ExtArgs> | null
  }


  /**
   * Model StoreVendor
   */

  export type AggregateStoreVendor = {
    _count: StoreVendorCountAggregateOutputType | null
    _min: StoreVendorMinAggregateOutputType | null
    _max: StoreVendorMaxAggregateOutputType | null
  }

  export type StoreVendorMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: string | null
    userId: string | null
    assignedBy: string | null
    isActive: boolean | null
    permissions: string | null
    customRoleId: string | null
  }

  export type StoreVendorMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: string | null
    userId: string | null
    assignedBy: string | null
    isActive: boolean | null
    permissions: string | null
    customRoleId: string | null
  }

  export type StoreVendorCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    storeId: number
    userId: number
    assignedBy: number
    isActive: number
    permissions: number
    customRoleId: number
    _all: number
  }


  export type StoreVendorMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    userId?: true
    assignedBy?: true
    isActive?: true
    permissions?: true
    customRoleId?: true
  }

  export type StoreVendorMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    userId?: true
    assignedBy?: true
    isActive?: true
    permissions?: true
    customRoleId?: true
  }

  export type StoreVendorCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    userId?: true
    assignedBy?: true
    isActive?: true
    permissions?: true
    customRoleId?: true
    _all?: true
  }

  export type StoreVendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreVendor to aggregate.
     */
    where?: StoreVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreVendors to fetch.
     */
    orderBy?: StoreVendorOrderByWithRelationInput | StoreVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreVendors
    **/
    _count?: true | StoreVendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreVendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreVendorMaxAggregateInputType
  }

  export type GetStoreVendorAggregateType<T extends StoreVendorAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreVendor[P]>
      : GetScalarType<T[P], AggregateStoreVendor[P]>
  }




  export type StoreVendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreVendorWhereInput
    orderBy?: StoreVendorOrderByWithAggregationInput | StoreVendorOrderByWithAggregationInput[]
    by: StoreVendorScalarFieldEnum[] | StoreVendorScalarFieldEnum
    having?: StoreVendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreVendorCountAggregateInputType | true
    _min?: StoreVendorMinAggregateInputType
    _max?: StoreVendorMaxAggregateInputType
  }

  export type StoreVendorGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    storeId: string
    userId: string
    assignedBy: string | null
    isActive: boolean
    permissions: string | null
    customRoleId: string | null
    _count: StoreVendorCountAggregateOutputType | null
    _min: StoreVendorMinAggregateOutputType | null
    _max: StoreVendorMaxAggregateOutputType | null
  }

  type GetStoreVendorGroupByPayload<T extends StoreVendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreVendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreVendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreVendorGroupByOutputType[P]>
            : GetScalarType<T[P], StoreVendorGroupByOutputType[P]>
        }
      >
    >


  export type StoreVendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    userId?: boolean
    assignedBy?: boolean
    isActive?: boolean
    permissions?: boolean
    customRoleId?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customRole?: boolean | StoreVendor$customRoleArgs<ExtArgs>
  }, ExtArgs["result"]["storeVendor"]>

  export type StoreVendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    userId?: boolean
    assignedBy?: boolean
    isActive?: boolean
    permissions?: boolean
    customRoleId?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customRole?: boolean | StoreVendor$customRoleArgs<ExtArgs>
  }, ExtArgs["result"]["storeVendor"]>

  export type StoreVendorSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    userId?: boolean
    assignedBy?: boolean
    isActive?: boolean
    permissions?: boolean
    customRoleId?: boolean
  }

  export type StoreVendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customRole?: boolean | StoreVendor$customRoleArgs<ExtArgs>
  }
  export type StoreVendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customRole?: boolean | StoreVendor$customRoleArgs<ExtArgs>
  }

  export type $StoreVendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreVendor"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      customRole: Prisma.$CustomRolePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      storeId: string
      userId: string
      assignedBy: string | null
      isActive: boolean
      permissions: string | null
      customRoleId: string | null
    }, ExtArgs["result"]["storeVendor"]>
    composites: {}
  }

  type StoreVendorGetPayload<S extends boolean | null | undefined | StoreVendorDefaultArgs> = $Result.GetResult<Prisma.$StoreVendorPayload, S>

  type StoreVendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreVendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreVendorCountAggregateInputType | true
    }

  export interface StoreVendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreVendor'], meta: { name: 'StoreVendor' } }
    /**
     * Find zero or one StoreVendor that matches the filter.
     * @param {StoreVendorFindUniqueArgs} args - Arguments to find a StoreVendor
     * @example
     * // Get one StoreVendor
     * const storeVendor = await prisma.storeVendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreVendorFindUniqueArgs>(args: SelectSubset<T, StoreVendorFindUniqueArgs<ExtArgs>>): Prisma__StoreVendorClient<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreVendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreVendorFindUniqueOrThrowArgs} args - Arguments to find a StoreVendor
     * @example
     * // Get one StoreVendor
     * const storeVendor = await prisma.storeVendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreVendorFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreVendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreVendorClient<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreVendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreVendorFindFirstArgs} args - Arguments to find a StoreVendor
     * @example
     * // Get one StoreVendor
     * const storeVendor = await prisma.storeVendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreVendorFindFirstArgs>(args?: SelectSubset<T, StoreVendorFindFirstArgs<ExtArgs>>): Prisma__StoreVendorClient<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreVendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreVendorFindFirstOrThrowArgs} args - Arguments to find a StoreVendor
     * @example
     * // Get one StoreVendor
     * const storeVendor = await prisma.storeVendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreVendorFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreVendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreVendorClient<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreVendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreVendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreVendors
     * const storeVendors = await prisma.storeVendor.findMany()
     * 
     * // Get first 10 StoreVendors
     * const storeVendors = await prisma.storeVendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeVendorWithIdOnly = await prisma.storeVendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreVendorFindManyArgs>(args?: SelectSubset<T, StoreVendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreVendor.
     * @param {StoreVendorCreateArgs} args - Arguments to create a StoreVendor.
     * @example
     * // Create one StoreVendor
     * const StoreVendor = await prisma.storeVendor.create({
     *   data: {
     *     // ... data to create a StoreVendor
     *   }
     * })
     * 
     */
    create<T extends StoreVendorCreateArgs>(args: SelectSubset<T, StoreVendorCreateArgs<ExtArgs>>): Prisma__StoreVendorClient<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreVendors.
     * @param {StoreVendorCreateManyArgs} args - Arguments to create many StoreVendors.
     * @example
     * // Create many StoreVendors
     * const storeVendor = await prisma.storeVendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreVendorCreateManyArgs>(args?: SelectSubset<T, StoreVendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreVendors and returns the data saved in the database.
     * @param {StoreVendorCreateManyAndReturnArgs} args - Arguments to create many StoreVendors.
     * @example
     * // Create many StoreVendors
     * const storeVendor = await prisma.storeVendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreVendors and only return the `id`
     * const storeVendorWithIdOnly = await prisma.storeVendor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreVendorCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreVendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreVendor.
     * @param {StoreVendorDeleteArgs} args - Arguments to delete one StoreVendor.
     * @example
     * // Delete one StoreVendor
     * const StoreVendor = await prisma.storeVendor.delete({
     *   where: {
     *     // ... filter to delete one StoreVendor
     *   }
     * })
     * 
     */
    delete<T extends StoreVendorDeleteArgs>(args: SelectSubset<T, StoreVendorDeleteArgs<ExtArgs>>): Prisma__StoreVendorClient<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreVendor.
     * @param {StoreVendorUpdateArgs} args - Arguments to update one StoreVendor.
     * @example
     * // Update one StoreVendor
     * const storeVendor = await prisma.storeVendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreVendorUpdateArgs>(args: SelectSubset<T, StoreVendorUpdateArgs<ExtArgs>>): Prisma__StoreVendorClient<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreVendors.
     * @param {StoreVendorDeleteManyArgs} args - Arguments to filter StoreVendors to delete.
     * @example
     * // Delete a few StoreVendors
     * const { count } = await prisma.storeVendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreVendorDeleteManyArgs>(args?: SelectSubset<T, StoreVendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreVendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreVendors
     * const storeVendor = await prisma.storeVendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreVendorUpdateManyArgs>(args: SelectSubset<T, StoreVendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreVendor.
     * @param {StoreVendorUpsertArgs} args - Arguments to update or create a StoreVendor.
     * @example
     * // Update or create a StoreVendor
     * const storeVendor = await prisma.storeVendor.upsert({
     *   create: {
     *     // ... data to create a StoreVendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreVendor we want to update
     *   }
     * })
     */
    upsert<T extends StoreVendorUpsertArgs>(args: SelectSubset<T, StoreVendorUpsertArgs<ExtArgs>>): Prisma__StoreVendorClient<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreVendorCountArgs} args - Arguments to filter StoreVendors to count.
     * @example
     * // Count the number of StoreVendors
     * const count = await prisma.storeVendor.count({
     *   where: {
     *     // ... the filter for the StoreVendors we want to count
     *   }
     * })
    **/
    count<T extends StoreVendorCountArgs>(
      args?: Subset<T, StoreVendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreVendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreVendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreVendorAggregateArgs>(args: Subset<T, StoreVendorAggregateArgs>): Prisma.PrismaPromise<GetStoreVendorAggregateType<T>>

    /**
     * Group by StoreVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreVendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreVendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreVendorGroupByArgs['orderBy'] }
        : { orderBy?: StoreVendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreVendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreVendor model
   */
  readonly fields: StoreVendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreVendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreVendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customRole<T extends StoreVendor$customRoleArgs<ExtArgs> = {}>(args?: Subset<T, StoreVendor$customRoleArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreVendor model
   */ 
  interface StoreVendorFieldRefs {
    readonly id: FieldRef<"StoreVendor", 'String'>
    readonly createdAt: FieldRef<"StoreVendor", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreVendor", 'DateTime'>
    readonly storeId: FieldRef<"StoreVendor", 'String'>
    readonly userId: FieldRef<"StoreVendor", 'String'>
    readonly assignedBy: FieldRef<"StoreVendor", 'String'>
    readonly isActive: FieldRef<"StoreVendor", 'Boolean'>
    readonly permissions: FieldRef<"StoreVendor", 'String'>
    readonly customRoleId: FieldRef<"StoreVendor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StoreVendor findUnique
   */
  export type StoreVendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    /**
     * Filter, which StoreVendor to fetch.
     */
    where: StoreVendorWhereUniqueInput
  }

  /**
   * StoreVendor findUniqueOrThrow
   */
  export type StoreVendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    /**
     * Filter, which StoreVendor to fetch.
     */
    where: StoreVendorWhereUniqueInput
  }

  /**
   * StoreVendor findFirst
   */
  export type StoreVendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    /**
     * Filter, which StoreVendor to fetch.
     */
    where?: StoreVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreVendors to fetch.
     */
    orderBy?: StoreVendorOrderByWithRelationInput | StoreVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreVendors.
     */
    cursor?: StoreVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreVendors.
     */
    distinct?: StoreVendorScalarFieldEnum | StoreVendorScalarFieldEnum[]
  }

  /**
   * StoreVendor findFirstOrThrow
   */
  export type StoreVendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    /**
     * Filter, which StoreVendor to fetch.
     */
    where?: StoreVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreVendors to fetch.
     */
    orderBy?: StoreVendorOrderByWithRelationInput | StoreVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreVendors.
     */
    cursor?: StoreVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreVendors.
     */
    distinct?: StoreVendorScalarFieldEnum | StoreVendorScalarFieldEnum[]
  }

  /**
   * StoreVendor findMany
   */
  export type StoreVendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    /**
     * Filter, which StoreVendors to fetch.
     */
    where?: StoreVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreVendors to fetch.
     */
    orderBy?: StoreVendorOrderByWithRelationInput | StoreVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreVendors.
     */
    cursor?: StoreVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreVendors.
     */
    skip?: number
    distinct?: StoreVendorScalarFieldEnum | StoreVendorScalarFieldEnum[]
  }

  /**
   * StoreVendor create
   */
  export type StoreVendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreVendor.
     */
    data: XOR<StoreVendorCreateInput, StoreVendorUncheckedCreateInput>
  }

  /**
   * StoreVendor createMany
   */
  export type StoreVendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreVendors.
     */
    data: StoreVendorCreateManyInput | StoreVendorCreateManyInput[]
  }

  /**
   * StoreVendor createManyAndReturn
   */
  export type StoreVendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreVendors.
     */
    data: StoreVendorCreateManyInput | StoreVendorCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreVendor update
   */
  export type StoreVendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreVendor.
     */
    data: XOR<StoreVendorUpdateInput, StoreVendorUncheckedUpdateInput>
    /**
     * Choose, which StoreVendor to update.
     */
    where: StoreVendorWhereUniqueInput
  }

  /**
   * StoreVendor updateMany
   */
  export type StoreVendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreVendors.
     */
    data: XOR<StoreVendorUpdateManyMutationInput, StoreVendorUncheckedUpdateManyInput>
    /**
     * Filter which StoreVendors to update
     */
    where?: StoreVendorWhereInput
  }

  /**
   * StoreVendor upsert
   */
  export type StoreVendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreVendor to update in case it exists.
     */
    where: StoreVendorWhereUniqueInput
    /**
     * In case the StoreVendor found by the `where` argument doesn't exist, create a new StoreVendor with this data.
     */
    create: XOR<StoreVendorCreateInput, StoreVendorUncheckedCreateInput>
    /**
     * In case the StoreVendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreVendorUpdateInput, StoreVendorUncheckedUpdateInput>
  }

  /**
   * StoreVendor delete
   */
  export type StoreVendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    /**
     * Filter which StoreVendor to delete.
     */
    where: StoreVendorWhereUniqueInput
  }

  /**
   * StoreVendor deleteMany
   */
  export type StoreVendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreVendors to delete
     */
    where?: StoreVendorWhereInput
  }

  /**
   * StoreVendor.customRole
   */
  export type StoreVendor$customRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    where?: CustomRoleWhereInput
  }

  /**
   * StoreVendor without action
   */
  export type StoreVendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
  }


  /**
   * Model StockLog
   */

  export type AggregateStockLog = {
    _count: StockLogCountAggregateOutputType | null
    _avg: StockLogAvgAggregateOutputType | null
    _sum: StockLogSumAggregateOutputType | null
    _min: StockLogMinAggregateOutputType | null
    _max: StockLogMaxAggregateOutputType | null
  }

  export type StockLogAvgAggregateOutputType = {
    previousQty: number | null
    newQty: number | null
    changeQty: number | null
  }

  export type StockLogSumAggregateOutputType = {
    previousQty: number | null
    newQty: number | null
    changeQty: number | null
  }

  export type StockLogMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    productId: string | null
    storeId: string | null
    variantId: string | null
    changeType: string | null
    previousQty: number | null
    newQty: number | null
    changeQty: number | null
    reason: string | null
    userId: string | null
    orderId: string | null
  }

  export type StockLogMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    productId: string | null
    storeId: string | null
    variantId: string | null
    changeType: string | null
    previousQty: number | null
    newQty: number | null
    changeQty: number | null
    reason: string | null
    userId: string | null
    orderId: string | null
  }

  export type StockLogCountAggregateOutputType = {
    id: number
    createdAt: number
    productId: number
    storeId: number
    variantId: number
    changeType: number
    previousQty: number
    newQty: number
    changeQty: number
    reason: number
    userId: number
    orderId: number
    _all: number
  }


  export type StockLogAvgAggregateInputType = {
    previousQty?: true
    newQty?: true
    changeQty?: true
  }

  export type StockLogSumAggregateInputType = {
    previousQty?: true
    newQty?: true
    changeQty?: true
  }

  export type StockLogMinAggregateInputType = {
    id?: true
    createdAt?: true
    productId?: true
    storeId?: true
    variantId?: true
    changeType?: true
    previousQty?: true
    newQty?: true
    changeQty?: true
    reason?: true
    userId?: true
    orderId?: true
  }

  export type StockLogMaxAggregateInputType = {
    id?: true
    createdAt?: true
    productId?: true
    storeId?: true
    variantId?: true
    changeType?: true
    previousQty?: true
    newQty?: true
    changeQty?: true
    reason?: true
    userId?: true
    orderId?: true
  }

  export type StockLogCountAggregateInputType = {
    id?: true
    createdAt?: true
    productId?: true
    storeId?: true
    variantId?: true
    changeType?: true
    previousQty?: true
    newQty?: true
    changeQty?: true
    reason?: true
    userId?: true
    orderId?: true
    _all?: true
  }

  export type StockLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLog to aggregate.
     */
    where?: StockLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLogs to fetch.
     */
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockLogs
    **/
    _count?: true | StockLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockLogMaxAggregateInputType
  }

  export type GetStockLogAggregateType<T extends StockLogAggregateArgs> = {
        [P in keyof T & keyof AggregateStockLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockLog[P]>
      : GetScalarType<T[P], AggregateStockLog[P]>
  }




  export type StockLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLogWhereInput
    orderBy?: StockLogOrderByWithAggregationInput | StockLogOrderByWithAggregationInput[]
    by: StockLogScalarFieldEnum[] | StockLogScalarFieldEnum
    having?: StockLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockLogCountAggregateInputType | true
    _avg?: StockLogAvgAggregateInputType
    _sum?: StockLogSumAggregateInputType
    _min?: StockLogMinAggregateInputType
    _max?: StockLogMaxAggregateInputType
  }

  export type StockLogGroupByOutputType = {
    id: string
    createdAt: Date
    productId: string
    storeId: string
    variantId: string | null
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason: string | null
    userId: string | null
    orderId: string | null
    _count: StockLogCountAggregateOutputType | null
    _avg: StockLogAvgAggregateOutputType | null
    _sum: StockLogSumAggregateOutputType | null
    _min: StockLogMinAggregateOutputType | null
    _max: StockLogMaxAggregateOutputType | null
  }

  type GetStockLogGroupByPayload<T extends StockLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockLogGroupByOutputType[P]>
            : GetScalarType<T[P], StockLogGroupByOutputType[P]>
        }
      >
    >


  export type StockLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    productId?: boolean
    storeId?: boolean
    variantId?: boolean
    changeType?: boolean
    previousQty?: boolean
    newQty?: boolean
    changeQty?: boolean
    reason?: boolean
    userId?: boolean
    orderId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    variant?: boolean | StockLog$variantArgs<ExtArgs>
  }, ExtArgs["result"]["stockLog"]>

  export type StockLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    productId?: boolean
    storeId?: boolean
    variantId?: boolean
    changeType?: boolean
    previousQty?: boolean
    newQty?: boolean
    changeQty?: boolean
    reason?: boolean
    userId?: boolean
    orderId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    variant?: boolean | StockLog$variantArgs<ExtArgs>
  }, ExtArgs["result"]["stockLog"]>

  export type StockLogSelectScalar = {
    id?: boolean
    createdAt?: boolean
    productId?: boolean
    storeId?: boolean
    variantId?: boolean
    changeType?: boolean
    previousQty?: boolean
    newQty?: boolean
    changeQty?: boolean
    reason?: boolean
    userId?: boolean
    orderId?: boolean
  }

  export type StockLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    variant?: boolean | StockLog$variantArgs<ExtArgs>
  }
  export type StockLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    variant?: boolean | StockLog$variantArgs<ExtArgs>
  }

  export type $StockLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockLog"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      productId: string
      storeId: string
      variantId: string | null
      changeType: string
      previousQty: number
      newQty: number
      changeQty: number
      reason: string | null
      userId: string | null
      orderId: string | null
    }, ExtArgs["result"]["stockLog"]>
    composites: {}
  }

  type StockLogGetPayload<S extends boolean | null | undefined | StockLogDefaultArgs> = $Result.GetResult<Prisma.$StockLogPayload, S>

  type StockLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockLogCountAggregateInputType | true
    }

  export interface StockLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockLog'], meta: { name: 'StockLog' } }
    /**
     * Find zero or one StockLog that matches the filter.
     * @param {StockLogFindUniqueArgs} args - Arguments to find a StockLog
     * @example
     * // Get one StockLog
     * const stockLog = await prisma.stockLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockLogFindUniqueArgs>(args: SelectSubset<T, StockLogFindUniqueArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockLogFindUniqueOrThrowArgs} args - Arguments to find a StockLog
     * @example
     * // Get one StockLog
     * const stockLog = await prisma.stockLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockLogFindUniqueOrThrowArgs>(args: SelectSubset<T, StockLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogFindFirstArgs} args - Arguments to find a StockLog
     * @example
     * // Get one StockLog
     * const stockLog = await prisma.stockLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockLogFindFirstArgs>(args?: SelectSubset<T, StockLogFindFirstArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogFindFirstOrThrowArgs} args - Arguments to find a StockLog
     * @example
     * // Get one StockLog
     * const stockLog = await prisma.stockLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockLogFindFirstOrThrowArgs>(args?: SelectSubset<T, StockLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockLogs
     * const stockLogs = await prisma.stockLog.findMany()
     * 
     * // Get first 10 StockLogs
     * const stockLogs = await prisma.stockLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockLogWithIdOnly = await prisma.stockLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockLogFindManyArgs>(args?: SelectSubset<T, StockLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockLog.
     * @param {StockLogCreateArgs} args - Arguments to create a StockLog.
     * @example
     * // Create one StockLog
     * const StockLog = await prisma.stockLog.create({
     *   data: {
     *     // ... data to create a StockLog
     *   }
     * })
     * 
     */
    create<T extends StockLogCreateArgs>(args: SelectSubset<T, StockLogCreateArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockLogs.
     * @param {StockLogCreateManyArgs} args - Arguments to create many StockLogs.
     * @example
     * // Create many StockLogs
     * const stockLog = await prisma.stockLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockLogCreateManyArgs>(args?: SelectSubset<T, StockLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockLogs and returns the data saved in the database.
     * @param {StockLogCreateManyAndReturnArgs} args - Arguments to create many StockLogs.
     * @example
     * // Create many StockLogs
     * const stockLog = await prisma.stockLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockLogs and only return the `id`
     * const stockLogWithIdOnly = await prisma.stockLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockLogCreateManyAndReturnArgs>(args?: SelectSubset<T, StockLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StockLog.
     * @param {StockLogDeleteArgs} args - Arguments to delete one StockLog.
     * @example
     * // Delete one StockLog
     * const StockLog = await prisma.stockLog.delete({
     *   where: {
     *     // ... filter to delete one StockLog
     *   }
     * })
     * 
     */
    delete<T extends StockLogDeleteArgs>(args: SelectSubset<T, StockLogDeleteArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockLog.
     * @param {StockLogUpdateArgs} args - Arguments to update one StockLog.
     * @example
     * // Update one StockLog
     * const stockLog = await prisma.stockLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockLogUpdateArgs>(args: SelectSubset<T, StockLogUpdateArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockLogs.
     * @param {StockLogDeleteManyArgs} args - Arguments to filter StockLogs to delete.
     * @example
     * // Delete a few StockLogs
     * const { count } = await prisma.stockLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockLogDeleteManyArgs>(args?: SelectSubset<T, StockLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockLogs
     * const stockLog = await prisma.stockLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockLogUpdateManyArgs>(args: SelectSubset<T, StockLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockLog.
     * @param {StockLogUpsertArgs} args - Arguments to update or create a StockLog.
     * @example
     * // Update or create a StockLog
     * const stockLog = await prisma.stockLog.upsert({
     *   create: {
     *     // ... data to create a StockLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockLog we want to update
     *   }
     * })
     */
    upsert<T extends StockLogUpsertArgs>(args: SelectSubset<T, StockLogUpsertArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogCountArgs} args - Arguments to filter StockLogs to count.
     * @example
     * // Count the number of StockLogs
     * const count = await prisma.stockLog.count({
     *   where: {
     *     // ... the filter for the StockLogs we want to count
     *   }
     * })
    **/
    count<T extends StockLogCountArgs>(
      args?: Subset<T, StockLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockLogAggregateArgs>(args: Subset<T, StockLogAggregateArgs>): Prisma.PrismaPromise<GetStockLogAggregateType<T>>

    /**
     * Group by StockLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockLogGroupByArgs['orderBy'] }
        : { orderBy?: StockLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockLog model
   */
  readonly fields: StockLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variant<T extends StockLog$variantArgs<ExtArgs> = {}>(args?: Subset<T, StockLog$variantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockLog model
   */ 
  interface StockLogFieldRefs {
    readonly id: FieldRef<"StockLog", 'String'>
    readonly createdAt: FieldRef<"StockLog", 'DateTime'>
    readonly productId: FieldRef<"StockLog", 'String'>
    readonly storeId: FieldRef<"StockLog", 'String'>
    readonly variantId: FieldRef<"StockLog", 'String'>
    readonly changeType: FieldRef<"StockLog", 'String'>
    readonly previousQty: FieldRef<"StockLog", 'Int'>
    readonly newQty: FieldRef<"StockLog", 'Int'>
    readonly changeQty: FieldRef<"StockLog", 'Int'>
    readonly reason: FieldRef<"StockLog", 'String'>
    readonly userId: FieldRef<"StockLog", 'String'>
    readonly orderId: FieldRef<"StockLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StockLog findUnique
   */
  export type StockLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLog to fetch.
     */
    where: StockLogWhereUniqueInput
  }

  /**
   * StockLog findUniqueOrThrow
   */
  export type StockLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLog to fetch.
     */
    where: StockLogWhereUniqueInput
  }

  /**
   * StockLog findFirst
   */
  export type StockLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLog to fetch.
     */
    where?: StockLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLogs to fetch.
     */
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLogs.
     */
    cursor?: StockLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLogs.
     */
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * StockLog findFirstOrThrow
   */
  export type StockLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLog to fetch.
     */
    where?: StockLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLogs to fetch.
     */
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLogs.
     */
    cursor?: StockLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLogs.
     */
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * StockLog findMany
   */
  export type StockLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLogs to fetch.
     */
    where?: StockLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLogs to fetch.
     */
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockLogs.
     */
    cursor?: StockLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLogs.
     */
    skip?: number
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * StockLog create
   */
  export type StockLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * The data needed to create a StockLog.
     */
    data: XOR<StockLogCreateInput, StockLogUncheckedCreateInput>
  }

  /**
   * StockLog createMany
   */
  export type StockLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockLogs.
     */
    data: StockLogCreateManyInput | StockLogCreateManyInput[]
  }

  /**
   * StockLog createManyAndReturn
   */
  export type StockLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StockLogs.
     */
    data: StockLogCreateManyInput | StockLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockLog update
   */
  export type StockLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * The data needed to update a StockLog.
     */
    data: XOR<StockLogUpdateInput, StockLogUncheckedUpdateInput>
    /**
     * Choose, which StockLog to update.
     */
    where: StockLogWhereUniqueInput
  }

  /**
   * StockLog updateMany
   */
  export type StockLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockLogs.
     */
    data: XOR<StockLogUpdateManyMutationInput, StockLogUncheckedUpdateManyInput>
    /**
     * Filter which StockLogs to update
     */
    where?: StockLogWhereInput
  }

  /**
   * StockLog upsert
   */
  export type StockLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * The filter to search for the StockLog to update in case it exists.
     */
    where: StockLogWhereUniqueInput
    /**
     * In case the StockLog found by the `where` argument doesn't exist, create a new StockLog with this data.
     */
    create: XOR<StockLogCreateInput, StockLogUncheckedCreateInput>
    /**
     * In case the StockLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockLogUpdateInput, StockLogUncheckedUpdateInput>
  }

  /**
   * StockLog delete
   */
  export type StockLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter which StockLog to delete.
     */
    where: StockLogWhereUniqueInput
  }

  /**
   * StockLog deleteMany
   */
  export type StockLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLogs to delete
     */
    where?: StockLogWhereInput
  }

  /**
   * StockLog.variant
   */
  export type StockLog$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * StockLog without action
   */
  export type StockLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeInvitation
   */

  export type AggregateEmployeeInvitation = {
    _count: EmployeeInvitationCountAggregateOutputType | null
    _min: EmployeeInvitationMinAggregateOutputType | null
    _max: EmployeeInvitationMaxAggregateOutputType | null
  }

  export type EmployeeInvitationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: string | null
    userId: string | null
    invitedBy: string | null
    role: string | null
    customRoleId: string | null
    permissions: string | null
    token: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    rejectedAt: Date | null
    message: string | null
    status: string | null
    inviteLinkId: string | null
  }

  export type EmployeeInvitationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: string | null
    userId: string | null
    invitedBy: string | null
    role: string | null
    customRoleId: string | null
    permissions: string | null
    token: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    rejectedAt: Date | null
    message: string | null
    status: string | null
    inviteLinkId: string | null
  }

  export type EmployeeInvitationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    storeId: number
    userId: number
    invitedBy: number
    role: number
    customRoleId: number
    permissions: number
    token: number
    expiresAt: number
    acceptedAt: number
    rejectedAt: number
    message: number
    status: number
    inviteLinkId: number
    _all: number
  }


  export type EmployeeInvitationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    userId?: true
    invitedBy?: true
    role?: true
    customRoleId?: true
    permissions?: true
    token?: true
    expiresAt?: true
    acceptedAt?: true
    rejectedAt?: true
    message?: true
    status?: true
    inviteLinkId?: true
  }

  export type EmployeeInvitationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    userId?: true
    invitedBy?: true
    role?: true
    customRoleId?: true
    permissions?: true
    token?: true
    expiresAt?: true
    acceptedAt?: true
    rejectedAt?: true
    message?: true
    status?: true
    inviteLinkId?: true
  }

  export type EmployeeInvitationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    userId?: true
    invitedBy?: true
    role?: true
    customRoleId?: true
    permissions?: true
    token?: true
    expiresAt?: true
    acceptedAt?: true
    rejectedAt?: true
    message?: true
    status?: true
    inviteLinkId?: true
    _all?: true
  }

  export type EmployeeInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeInvitation to aggregate.
     */
    where?: EmployeeInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeInvitations to fetch.
     */
    orderBy?: EmployeeInvitationOrderByWithRelationInput | EmployeeInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeInvitations
    **/
    _count?: true | EmployeeInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeInvitationMaxAggregateInputType
  }

  export type GetEmployeeInvitationAggregateType<T extends EmployeeInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeInvitation[P]>
      : GetScalarType<T[P], AggregateEmployeeInvitation[P]>
  }




  export type EmployeeInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeInvitationWhereInput
    orderBy?: EmployeeInvitationOrderByWithAggregationInput | EmployeeInvitationOrderByWithAggregationInput[]
    by: EmployeeInvitationScalarFieldEnum[] | EmployeeInvitationScalarFieldEnum
    having?: EmployeeInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeInvitationCountAggregateInputType | true
    _min?: EmployeeInvitationMinAggregateInputType
    _max?: EmployeeInvitationMaxAggregateInputType
  }

  export type EmployeeInvitationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    storeId: string
    userId: string
    invitedBy: string
    role: string | null
    customRoleId: string | null
    permissions: string | null
    token: string
    expiresAt: Date
    acceptedAt: Date | null
    rejectedAt: Date | null
    message: string | null
    status: string
    inviteLinkId: string | null
    _count: EmployeeInvitationCountAggregateOutputType | null
    _min: EmployeeInvitationMinAggregateOutputType | null
    _max: EmployeeInvitationMaxAggregateOutputType | null
  }

  type GetEmployeeInvitationGroupByPayload<T extends EmployeeInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeInvitationGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    userId?: boolean
    invitedBy?: boolean
    role?: boolean
    customRoleId?: boolean
    permissions?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    rejectedAt?: boolean
    message?: boolean
    status?: boolean
    inviteLinkId?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    inviteLink?: boolean | EmployeeInvitation$inviteLinkArgs<ExtArgs>
  }, ExtArgs["result"]["employeeInvitation"]>

  export type EmployeeInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    userId?: boolean
    invitedBy?: boolean
    role?: boolean
    customRoleId?: boolean
    permissions?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    rejectedAt?: boolean
    message?: boolean
    status?: boolean
    inviteLinkId?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    inviteLink?: boolean | EmployeeInvitation$inviteLinkArgs<ExtArgs>
  }, ExtArgs["result"]["employeeInvitation"]>

  export type EmployeeInvitationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    userId?: boolean
    invitedBy?: boolean
    role?: boolean
    customRoleId?: boolean
    permissions?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    rejectedAt?: boolean
    message?: boolean
    status?: boolean
    inviteLinkId?: boolean
  }

  export type EmployeeInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    inviteLink?: boolean | EmployeeInvitation$inviteLinkArgs<ExtArgs>
  }
  export type EmployeeInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    inviteLink?: boolean | EmployeeInvitation$inviteLinkArgs<ExtArgs>
  }

  export type $EmployeeInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeInvitation"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
      inviteLink: Prisma.$InviteLinkPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      storeId: string
      userId: string
      invitedBy: string
      role: string | null
      customRoleId: string | null
      permissions: string | null
      token: string
      expiresAt: Date
      acceptedAt: Date | null
      rejectedAt: Date | null
      message: string | null
      status: string
      inviteLinkId: string | null
    }, ExtArgs["result"]["employeeInvitation"]>
    composites: {}
  }

  type EmployeeInvitationGetPayload<S extends boolean | null | undefined | EmployeeInvitationDefaultArgs> = $Result.GetResult<Prisma.$EmployeeInvitationPayload, S>

  type EmployeeInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeInvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeInvitationCountAggregateInputType | true
    }

  export interface EmployeeInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeInvitation'], meta: { name: 'EmployeeInvitation' } }
    /**
     * Find zero or one EmployeeInvitation that matches the filter.
     * @param {EmployeeInvitationFindUniqueArgs} args - Arguments to find a EmployeeInvitation
     * @example
     * // Get one EmployeeInvitation
     * const employeeInvitation = await prisma.employeeInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeInvitationFindUniqueArgs>(args: SelectSubset<T, EmployeeInvitationFindUniqueArgs<ExtArgs>>): Prisma__EmployeeInvitationClient<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeInvitationFindUniqueOrThrowArgs} args - Arguments to find a EmployeeInvitation
     * @example
     * // Get one EmployeeInvitation
     * const employeeInvitation = await prisma.employeeInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeInvitationClient<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeInvitationFindFirstArgs} args - Arguments to find a EmployeeInvitation
     * @example
     * // Get one EmployeeInvitation
     * const employeeInvitation = await prisma.employeeInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeInvitationFindFirstArgs>(args?: SelectSubset<T, EmployeeInvitationFindFirstArgs<ExtArgs>>): Prisma__EmployeeInvitationClient<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeInvitationFindFirstOrThrowArgs} args - Arguments to find a EmployeeInvitation
     * @example
     * // Get one EmployeeInvitation
     * const employeeInvitation = await prisma.employeeInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeInvitationClient<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeInvitations
     * const employeeInvitations = await prisma.employeeInvitation.findMany()
     * 
     * // Get first 10 EmployeeInvitations
     * const employeeInvitations = await prisma.employeeInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeInvitationWithIdOnly = await prisma.employeeInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeInvitationFindManyArgs>(args?: SelectSubset<T, EmployeeInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeInvitation.
     * @param {EmployeeInvitationCreateArgs} args - Arguments to create a EmployeeInvitation.
     * @example
     * // Create one EmployeeInvitation
     * const EmployeeInvitation = await prisma.employeeInvitation.create({
     *   data: {
     *     // ... data to create a EmployeeInvitation
     *   }
     * })
     * 
     */
    create<T extends EmployeeInvitationCreateArgs>(args: SelectSubset<T, EmployeeInvitationCreateArgs<ExtArgs>>): Prisma__EmployeeInvitationClient<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeInvitations.
     * @param {EmployeeInvitationCreateManyArgs} args - Arguments to create many EmployeeInvitations.
     * @example
     * // Create many EmployeeInvitations
     * const employeeInvitation = await prisma.employeeInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeInvitationCreateManyArgs>(args?: SelectSubset<T, EmployeeInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeInvitations and returns the data saved in the database.
     * @param {EmployeeInvitationCreateManyAndReturnArgs} args - Arguments to create many EmployeeInvitations.
     * @example
     * // Create many EmployeeInvitations
     * const employeeInvitation = await prisma.employeeInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeInvitations and only return the `id`
     * const employeeInvitationWithIdOnly = await prisma.employeeInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeInvitation.
     * @param {EmployeeInvitationDeleteArgs} args - Arguments to delete one EmployeeInvitation.
     * @example
     * // Delete one EmployeeInvitation
     * const EmployeeInvitation = await prisma.employeeInvitation.delete({
     *   where: {
     *     // ... filter to delete one EmployeeInvitation
     *   }
     * })
     * 
     */
    delete<T extends EmployeeInvitationDeleteArgs>(args: SelectSubset<T, EmployeeInvitationDeleteArgs<ExtArgs>>): Prisma__EmployeeInvitationClient<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeInvitation.
     * @param {EmployeeInvitationUpdateArgs} args - Arguments to update one EmployeeInvitation.
     * @example
     * // Update one EmployeeInvitation
     * const employeeInvitation = await prisma.employeeInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeInvitationUpdateArgs>(args: SelectSubset<T, EmployeeInvitationUpdateArgs<ExtArgs>>): Prisma__EmployeeInvitationClient<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeInvitations.
     * @param {EmployeeInvitationDeleteManyArgs} args - Arguments to filter EmployeeInvitations to delete.
     * @example
     * // Delete a few EmployeeInvitations
     * const { count } = await prisma.employeeInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeInvitationDeleteManyArgs>(args?: SelectSubset<T, EmployeeInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeInvitations
     * const employeeInvitation = await prisma.employeeInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeInvitationUpdateManyArgs>(args: SelectSubset<T, EmployeeInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeInvitation.
     * @param {EmployeeInvitationUpsertArgs} args - Arguments to update or create a EmployeeInvitation.
     * @example
     * // Update or create a EmployeeInvitation
     * const employeeInvitation = await prisma.employeeInvitation.upsert({
     *   create: {
     *     // ... data to create a EmployeeInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeInvitation we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeInvitationUpsertArgs>(args: SelectSubset<T, EmployeeInvitationUpsertArgs<ExtArgs>>): Prisma__EmployeeInvitationClient<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeInvitationCountArgs} args - Arguments to filter EmployeeInvitations to count.
     * @example
     * // Count the number of EmployeeInvitations
     * const count = await prisma.employeeInvitation.count({
     *   where: {
     *     // ... the filter for the EmployeeInvitations we want to count
     *   }
     * })
    **/
    count<T extends EmployeeInvitationCountArgs>(
      args?: Subset<T, EmployeeInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeInvitationAggregateArgs>(args: Subset<T, EmployeeInvitationAggregateArgs>): Prisma.PrismaPromise<GetEmployeeInvitationAggregateType<T>>

    /**
     * Group by EmployeeInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeInvitationGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeInvitation model
   */
  readonly fields: EmployeeInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inviteLink<T extends EmployeeInvitation$inviteLinkArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeInvitation$inviteLinkArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeInvitation model
   */ 
  interface EmployeeInvitationFieldRefs {
    readonly id: FieldRef<"EmployeeInvitation", 'String'>
    readonly createdAt: FieldRef<"EmployeeInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeInvitation", 'DateTime'>
    readonly storeId: FieldRef<"EmployeeInvitation", 'String'>
    readonly userId: FieldRef<"EmployeeInvitation", 'String'>
    readonly invitedBy: FieldRef<"EmployeeInvitation", 'String'>
    readonly role: FieldRef<"EmployeeInvitation", 'String'>
    readonly customRoleId: FieldRef<"EmployeeInvitation", 'String'>
    readonly permissions: FieldRef<"EmployeeInvitation", 'String'>
    readonly token: FieldRef<"EmployeeInvitation", 'String'>
    readonly expiresAt: FieldRef<"EmployeeInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"EmployeeInvitation", 'DateTime'>
    readonly rejectedAt: FieldRef<"EmployeeInvitation", 'DateTime'>
    readonly message: FieldRef<"EmployeeInvitation", 'String'>
    readonly status: FieldRef<"EmployeeInvitation", 'String'>
    readonly inviteLinkId: FieldRef<"EmployeeInvitation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeInvitation findUnique
   */
  export type EmployeeInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeInvitation to fetch.
     */
    where: EmployeeInvitationWhereUniqueInput
  }

  /**
   * EmployeeInvitation findUniqueOrThrow
   */
  export type EmployeeInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeInvitation to fetch.
     */
    where: EmployeeInvitationWhereUniqueInput
  }

  /**
   * EmployeeInvitation findFirst
   */
  export type EmployeeInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeInvitation to fetch.
     */
    where?: EmployeeInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeInvitations to fetch.
     */
    orderBy?: EmployeeInvitationOrderByWithRelationInput | EmployeeInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeInvitations.
     */
    cursor?: EmployeeInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeInvitations.
     */
    distinct?: EmployeeInvitationScalarFieldEnum | EmployeeInvitationScalarFieldEnum[]
  }

  /**
   * EmployeeInvitation findFirstOrThrow
   */
  export type EmployeeInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeInvitation to fetch.
     */
    where?: EmployeeInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeInvitations to fetch.
     */
    orderBy?: EmployeeInvitationOrderByWithRelationInput | EmployeeInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeInvitations.
     */
    cursor?: EmployeeInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeInvitations.
     */
    distinct?: EmployeeInvitationScalarFieldEnum | EmployeeInvitationScalarFieldEnum[]
  }

  /**
   * EmployeeInvitation findMany
   */
  export type EmployeeInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeInvitations to fetch.
     */
    where?: EmployeeInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeInvitations to fetch.
     */
    orderBy?: EmployeeInvitationOrderByWithRelationInput | EmployeeInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeInvitations.
     */
    cursor?: EmployeeInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeInvitations.
     */
    skip?: number
    distinct?: EmployeeInvitationScalarFieldEnum | EmployeeInvitationScalarFieldEnum[]
  }

  /**
   * EmployeeInvitation create
   */
  export type EmployeeInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeInvitation.
     */
    data: XOR<EmployeeInvitationCreateInput, EmployeeInvitationUncheckedCreateInput>
  }

  /**
   * EmployeeInvitation createMany
   */
  export type EmployeeInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeInvitations.
     */
    data: EmployeeInvitationCreateManyInput | EmployeeInvitationCreateManyInput[]
  }

  /**
   * EmployeeInvitation createManyAndReturn
   */
  export type EmployeeInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeInvitations.
     */
    data: EmployeeInvitationCreateManyInput | EmployeeInvitationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeInvitation update
   */
  export type EmployeeInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeInvitation.
     */
    data: XOR<EmployeeInvitationUpdateInput, EmployeeInvitationUncheckedUpdateInput>
    /**
     * Choose, which EmployeeInvitation to update.
     */
    where: EmployeeInvitationWhereUniqueInput
  }

  /**
   * EmployeeInvitation updateMany
   */
  export type EmployeeInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeInvitations.
     */
    data: XOR<EmployeeInvitationUpdateManyMutationInput, EmployeeInvitationUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeInvitations to update
     */
    where?: EmployeeInvitationWhereInput
  }

  /**
   * EmployeeInvitation upsert
   */
  export type EmployeeInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeInvitation to update in case it exists.
     */
    where: EmployeeInvitationWhereUniqueInput
    /**
     * In case the EmployeeInvitation found by the `where` argument doesn't exist, create a new EmployeeInvitation with this data.
     */
    create: XOR<EmployeeInvitationCreateInput, EmployeeInvitationUncheckedCreateInput>
    /**
     * In case the EmployeeInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeInvitationUpdateInput, EmployeeInvitationUncheckedUpdateInput>
  }

  /**
   * EmployeeInvitation delete
   */
  export type EmployeeInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    /**
     * Filter which EmployeeInvitation to delete.
     */
    where: EmployeeInvitationWhereUniqueInput
  }

  /**
   * EmployeeInvitation deleteMany
   */
  export type EmployeeInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeInvitations to delete
     */
    where?: EmployeeInvitationWhereInput
  }

  /**
   * EmployeeInvitation.inviteLink
   */
  export type EmployeeInvitation$inviteLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    where?: InviteLinkWhereInput
  }

  /**
   * EmployeeInvitation without action
   */
  export type EmployeeInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeActivity
   */

  export type AggregateEmployeeActivity = {
    _count: EmployeeActivityCountAggregateOutputType | null
    _min: EmployeeActivityMinAggregateOutputType | null
    _max: EmployeeActivityMaxAggregateOutputType | null
  }

  export type EmployeeActivityMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    storeId: string | null
    userId: string | null
    action: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type EmployeeActivityMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    storeId: string | null
    userId: string | null
    action: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type EmployeeActivityCountAggregateOutputType = {
    id: number
    createdAt: number
    storeId: number
    userId: number
    action: number
    details: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type EmployeeActivityMinAggregateInputType = {
    id?: true
    createdAt?: true
    storeId?: true
    userId?: true
    action?: true
    details?: true
    ipAddress?: true
    userAgent?: true
  }

  export type EmployeeActivityMaxAggregateInputType = {
    id?: true
    createdAt?: true
    storeId?: true
    userId?: true
    action?: true
    details?: true
    ipAddress?: true
    userAgent?: true
  }

  export type EmployeeActivityCountAggregateInputType = {
    id?: true
    createdAt?: true
    storeId?: true
    userId?: true
    action?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type EmployeeActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeActivity to aggregate.
     */
    where?: EmployeeActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeActivities to fetch.
     */
    orderBy?: EmployeeActivityOrderByWithRelationInput | EmployeeActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeActivities
    **/
    _count?: true | EmployeeActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeActivityMaxAggregateInputType
  }

  export type GetEmployeeActivityAggregateType<T extends EmployeeActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeActivity[P]>
      : GetScalarType<T[P], AggregateEmployeeActivity[P]>
  }




  export type EmployeeActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeActivityWhereInput
    orderBy?: EmployeeActivityOrderByWithAggregationInput | EmployeeActivityOrderByWithAggregationInput[]
    by: EmployeeActivityScalarFieldEnum[] | EmployeeActivityScalarFieldEnum
    having?: EmployeeActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeActivityCountAggregateInputType | true
    _min?: EmployeeActivityMinAggregateInputType
    _max?: EmployeeActivityMaxAggregateInputType
  }

  export type EmployeeActivityGroupByOutputType = {
    id: string
    createdAt: Date
    storeId: string
    userId: string
    action: string
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    _count: EmployeeActivityCountAggregateOutputType | null
    _min: EmployeeActivityMinAggregateOutputType | null
    _max: EmployeeActivityMaxAggregateOutputType | null
  }

  type GetEmployeeActivityGroupByPayload<T extends EmployeeActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeActivityGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeActivityGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    storeId?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeActivity"]>

  export type EmployeeActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    storeId?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeActivity"]>

  export type EmployeeActivitySelectScalar = {
    id?: boolean
    createdAt?: boolean
    storeId?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type EmployeeActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeeActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeActivity"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      storeId: string
      userId: string
      action: string
      details: string | null
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["employeeActivity"]>
    composites: {}
  }

  type EmployeeActivityGetPayload<S extends boolean | null | undefined | EmployeeActivityDefaultArgs> = $Result.GetResult<Prisma.$EmployeeActivityPayload, S>

  type EmployeeActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeActivityCountAggregateInputType | true
    }

  export interface EmployeeActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeActivity'], meta: { name: 'EmployeeActivity' } }
    /**
     * Find zero or one EmployeeActivity that matches the filter.
     * @param {EmployeeActivityFindUniqueArgs} args - Arguments to find a EmployeeActivity
     * @example
     * // Get one EmployeeActivity
     * const employeeActivity = await prisma.employeeActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeActivityFindUniqueArgs>(args: SelectSubset<T, EmployeeActivityFindUniqueArgs<ExtArgs>>): Prisma__EmployeeActivityClient<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeActivityFindUniqueOrThrowArgs} args - Arguments to find a EmployeeActivity
     * @example
     * // Get one EmployeeActivity
     * const employeeActivity = await prisma.employeeActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeActivityClient<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeActivityFindFirstArgs} args - Arguments to find a EmployeeActivity
     * @example
     * // Get one EmployeeActivity
     * const employeeActivity = await prisma.employeeActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeActivityFindFirstArgs>(args?: SelectSubset<T, EmployeeActivityFindFirstArgs<ExtArgs>>): Prisma__EmployeeActivityClient<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeActivityFindFirstOrThrowArgs} args - Arguments to find a EmployeeActivity
     * @example
     * // Get one EmployeeActivity
     * const employeeActivity = await prisma.employeeActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeActivityClient<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeActivities
     * const employeeActivities = await prisma.employeeActivity.findMany()
     * 
     * // Get first 10 EmployeeActivities
     * const employeeActivities = await prisma.employeeActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeActivityWithIdOnly = await prisma.employeeActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeActivityFindManyArgs>(args?: SelectSubset<T, EmployeeActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeActivity.
     * @param {EmployeeActivityCreateArgs} args - Arguments to create a EmployeeActivity.
     * @example
     * // Create one EmployeeActivity
     * const EmployeeActivity = await prisma.employeeActivity.create({
     *   data: {
     *     // ... data to create a EmployeeActivity
     *   }
     * })
     * 
     */
    create<T extends EmployeeActivityCreateArgs>(args: SelectSubset<T, EmployeeActivityCreateArgs<ExtArgs>>): Prisma__EmployeeActivityClient<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeActivities.
     * @param {EmployeeActivityCreateManyArgs} args - Arguments to create many EmployeeActivities.
     * @example
     * // Create many EmployeeActivities
     * const employeeActivity = await prisma.employeeActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeActivityCreateManyArgs>(args?: SelectSubset<T, EmployeeActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeActivities and returns the data saved in the database.
     * @param {EmployeeActivityCreateManyAndReturnArgs} args - Arguments to create many EmployeeActivities.
     * @example
     * // Create many EmployeeActivities
     * const employeeActivity = await prisma.employeeActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeActivities and only return the `id`
     * const employeeActivityWithIdOnly = await prisma.employeeActivity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeActivity.
     * @param {EmployeeActivityDeleteArgs} args - Arguments to delete one EmployeeActivity.
     * @example
     * // Delete one EmployeeActivity
     * const EmployeeActivity = await prisma.employeeActivity.delete({
     *   where: {
     *     // ... filter to delete one EmployeeActivity
     *   }
     * })
     * 
     */
    delete<T extends EmployeeActivityDeleteArgs>(args: SelectSubset<T, EmployeeActivityDeleteArgs<ExtArgs>>): Prisma__EmployeeActivityClient<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeActivity.
     * @param {EmployeeActivityUpdateArgs} args - Arguments to update one EmployeeActivity.
     * @example
     * // Update one EmployeeActivity
     * const employeeActivity = await prisma.employeeActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeActivityUpdateArgs>(args: SelectSubset<T, EmployeeActivityUpdateArgs<ExtArgs>>): Prisma__EmployeeActivityClient<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeActivities.
     * @param {EmployeeActivityDeleteManyArgs} args - Arguments to filter EmployeeActivities to delete.
     * @example
     * // Delete a few EmployeeActivities
     * const { count } = await prisma.employeeActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeActivityDeleteManyArgs>(args?: SelectSubset<T, EmployeeActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeActivities
     * const employeeActivity = await prisma.employeeActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeActivityUpdateManyArgs>(args: SelectSubset<T, EmployeeActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeActivity.
     * @param {EmployeeActivityUpsertArgs} args - Arguments to update or create a EmployeeActivity.
     * @example
     * // Update or create a EmployeeActivity
     * const employeeActivity = await prisma.employeeActivity.upsert({
     *   create: {
     *     // ... data to create a EmployeeActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeActivity we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeActivityUpsertArgs>(args: SelectSubset<T, EmployeeActivityUpsertArgs<ExtArgs>>): Prisma__EmployeeActivityClient<$Result.GetResult<Prisma.$EmployeeActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeActivityCountArgs} args - Arguments to filter EmployeeActivities to count.
     * @example
     * // Count the number of EmployeeActivities
     * const count = await prisma.employeeActivity.count({
     *   where: {
     *     // ... the filter for the EmployeeActivities we want to count
     *   }
     * })
    **/
    count<T extends EmployeeActivityCountArgs>(
      args?: Subset<T, EmployeeActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeActivityAggregateArgs>(args: Subset<T, EmployeeActivityAggregateArgs>): Prisma.PrismaPromise<GetEmployeeActivityAggregateType<T>>

    /**
     * Group by EmployeeActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeActivityGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeActivity model
   */
  readonly fields: EmployeeActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeActivity model
   */ 
  interface EmployeeActivityFieldRefs {
    readonly id: FieldRef<"EmployeeActivity", 'String'>
    readonly createdAt: FieldRef<"EmployeeActivity", 'DateTime'>
    readonly storeId: FieldRef<"EmployeeActivity", 'String'>
    readonly userId: FieldRef<"EmployeeActivity", 'String'>
    readonly action: FieldRef<"EmployeeActivity", 'String'>
    readonly details: FieldRef<"EmployeeActivity", 'String'>
    readonly ipAddress: FieldRef<"EmployeeActivity", 'String'>
    readonly userAgent: FieldRef<"EmployeeActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeActivity findUnique
   */
  export type EmployeeActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeActivity to fetch.
     */
    where: EmployeeActivityWhereUniqueInput
  }

  /**
   * EmployeeActivity findUniqueOrThrow
   */
  export type EmployeeActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeActivity to fetch.
     */
    where: EmployeeActivityWhereUniqueInput
  }

  /**
   * EmployeeActivity findFirst
   */
  export type EmployeeActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeActivity to fetch.
     */
    where?: EmployeeActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeActivities to fetch.
     */
    orderBy?: EmployeeActivityOrderByWithRelationInput | EmployeeActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeActivities.
     */
    cursor?: EmployeeActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeActivities.
     */
    distinct?: EmployeeActivityScalarFieldEnum | EmployeeActivityScalarFieldEnum[]
  }

  /**
   * EmployeeActivity findFirstOrThrow
   */
  export type EmployeeActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeActivity to fetch.
     */
    where?: EmployeeActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeActivities to fetch.
     */
    orderBy?: EmployeeActivityOrderByWithRelationInput | EmployeeActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeActivities.
     */
    cursor?: EmployeeActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeActivities.
     */
    distinct?: EmployeeActivityScalarFieldEnum | EmployeeActivityScalarFieldEnum[]
  }

  /**
   * EmployeeActivity findMany
   */
  export type EmployeeActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeActivities to fetch.
     */
    where?: EmployeeActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeActivities to fetch.
     */
    orderBy?: EmployeeActivityOrderByWithRelationInput | EmployeeActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeActivities.
     */
    cursor?: EmployeeActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeActivities.
     */
    skip?: number
    distinct?: EmployeeActivityScalarFieldEnum | EmployeeActivityScalarFieldEnum[]
  }

  /**
   * EmployeeActivity create
   */
  export type EmployeeActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeActivity.
     */
    data: XOR<EmployeeActivityCreateInput, EmployeeActivityUncheckedCreateInput>
  }

  /**
   * EmployeeActivity createMany
   */
  export type EmployeeActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeActivities.
     */
    data: EmployeeActivityCreateManyInput | EmployeeActivityCreateManyInput[]
  }

  /**
   * EmployeeActivity createManyAndReturn
   */
  export type EmployeeActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeActivities.
     */
    data: EmployeeActivityCreateManyInput | EmployeeActivityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeActivity update
   */
  export type EmployeeActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeActivity.
     */
    data: XOR<EmployeeActivityUpdateInput, EmployeeActivityUncheckedUpdateInput>
    /**
     * Choose, which EmployeeActivity to update.
     */
    where: EmployeeActivityWhereUniqueInput
  }

  /**
   * EmployeeActivity updateMany
   */
  export type EmployeeActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeActivities.
     */
    data: XOR<EmployeeActivityUpdateManyMutationInput, EmployeeActivityUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeActivities to update
     */
    where?: EmployeeActivityWhereInput
  }

  /**
   * EmployeeActivity upsert
   */
  export type EmployeeActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeActivity to update in case it exists.
     */
    where: EmployeeActivityWhereUniqueInput
    /**
     * In case the EmployeeActivity found by the `where` argument doesn't exist, create a new EmployeeActivity with this data.
     */
    create: XOR<EmployeeActivityCreateInput, EmployeeActivityUncheckedCreateInput>
    /**
     * In case the EmployeeActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeActivityUpdateInput, EmployeeActivityUncheckedUpdateInput>
  }

  /**
   * EmployeeActivity delete
   */
  export type EmployeeActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
    /**
     * Filter which EmployeeActivity to delete.
     */
    where: EmployeeActivityWhereUniqueInput
  }

  /**
   * EmployeeActivity deleteMany
   */
  export type EmployeeActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeActivities to delete
     */
    where?: EmployeeActivityWhereInput
  }

  /**
   * EmployeeActivity without action
   */
  export type EmployeeActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeActivity
     */
    select?: EmployeeActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeActivityInclude<ExtArgs> | null
  }


  /**
   * Model InviteLink
   */

  export type AggregateInviteLink = {
    _count: InviteLinkCountAggregateOutputType | null
    _avg: InviteLinkAvgAggregateOutputType | null
    _sum: InviteLinkSumAggregateOutputType | null
    _min: InviteLinkMinAggregateOutputType | null
    _max: InviteLinkMaxAggregateOutputType | null
  }

  export type InviteLinkAvgAggregateOutputType = {
    maxUses: number | null
    usedCount: number | null
  }

  export type InviteLinkSumAggregateOutputType = {
    maxUses: number | null
    usedCount: number | null
  }

  export type InviteLinkMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: string | null
    createdBy: string | null
    token: string | null
    role: string | null
    customRoleId: string | null
    permissions: string | null
    maxUses: number | null
    usedCount: number | null
    expiresAt: Date | null
    isActive: boolean | null
    description: string | null
  }

  export type InviteLinkMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: string | null
    createdBy: string | null
    token: string | null
    role: string | null
    customRoleId: string | null
    permissions: string | null
    maxUses: number | null
    usedCount: number | null
    expiresAt: Date | null
    isActive: boolean | null
    description: string | null
  }

  export type InviteLinkCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    storeId: number
    createdBy: number
    token: number
    role: number
    customRoleId: number
    permissions: number
    maxUses: number
    usedCount: number
    expiresAt: number
    isActive: number
    description: number
    _all: number
  }


  export type InviteLinkAvgAggregateInputType = {
    maxUses?: true
    usedCount?: true
  }

  export type InviteLinkSumAggregateInputType = {
    maxUses?: true
    usedCount?: true
  }

  export type InviteLinkMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    createdBy?: true
    token?: true
    role?: true
    customRoleId?: true
    permissions?: true
    maxUses?: true
    usedCount?: true
    expiresAt?: true
    isActive?: true
    description?: true
  }

  export type InviteLinkMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    createdBy?: true
    token?: true
    role?: true
    customRoleId?: true
    permissions?: true
    maxUses?: true
    usedCount?: true
    expiresAt?: true
    isActive?: true
    description?: true
  }

  export type InviteLinkCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    createdBy?: true
    token?: true
    role?: true
    customRoleId?: true
    permissions?: true
    maxUses?: true
    usedCount?: true
    expiresAt?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type InviteLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteLink to aggregate.
     */
    where?: InviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteLinks to fetch.
     */
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InviteLinks
    **/
    _count?: true | InviteLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InviteLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InviteLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteLinkMaxAggregateInputType
  }

  export type GetInviteLinkAggregateType<T extends InviteLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateInviteLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInviteLink[P]>
      : GetScalarType<T[P], AggregateInviteLink[P]>
  }




  export type InviteLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteLinkWhereInput
    orderBy?: InviteLinkOrderByWithAggregationInput | InviteLinkOrderByWithAggregationInput[]
    by: InviteLinkScalarFieldEnum[] | InviteLinkScalarFieldEnum
    having?: InviteLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteLinkCountAggregateInputType | true
    _avg?: InviteLinkAvgAggregateInputType
    _sum?: InviteLinkSumAggregateInputType
    _min?: InviteLinkMinAggregateInputType
    _max?: InviteLinkMaxAggregateInputType
  }

  export type InviteLinkGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    storeId: string
    createdBy: string
    token: string
    role: string | null
    customRoleId: string | null
    permissions: string | null
    maxUses: number
    usedCount: number
    expiresAt: Date | null
    isActive: boolean
    description: string | null
    _count: InviteLinkCountAggregateOutputType | null
    _avg: InviteLinkAvgAggregateOutputType | null
    _sum: InviteLinkSumAggregateOutputType | null
    _min: InviteLinkMinAggregateOutputType | null
    _max: InviteLinkMaxAggregateOutputType | null
  }

  type GetInviteLinkGroupByPayload<T extends InviteLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteLinkGroupByOutputType[P]>
            : GetScalarType<T[P], InviteLinkGroupByOutputType[P]>
        }
      >
    >


  export type InviteLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    createdBy?: boolean
    token?: boolean
    role?: boolean
    customRoleId?: boolean
    permissions?: boolean
    maxUses?: boolean
    usedCount?: boolean
    expiresAt?: boolean
    isActive?: boolean
    description?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    customRole?: boolean | InviteLink$customRoleArgs<ExtArgs>
    invitations?: boolean | InviteLink$invitationsArgs<ExtArgs>
    _count?: boolean | InviteLinkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inviteLink"]>

  export type InviteLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    createdBy?: boolean
    token?: boolean
    role?: boolean
    customRoleId?: boolean
    permissions?: boolean
    maxUses?: boolean
    usedCount?: boolean
    expiresAt?: boolean
    isActive?: boolean
    description?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    customRole?: boolean | InviteLink$customRoleArgs<ExtArgs>
  }, ExtArgs["result"]["inviteLink"]>

  export type InviteLinkSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    createdBy?: boolean
    token?: boolean
    role?: boolean
    customRoleId?: boolean
    permissions?: boolean
    maxUses?: boolean
    usedCount?: boolean
    expiresAt?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type InviteLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    customRole?: boolean | InviteLink$customRoleArgs<ExtArgs>
    invitations?: boolean | InviteLink$invitationsArgs<ExtArgs>
    _count?: boolean | InviteLinkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InviteLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    customRole?: boolean | InviteLink$customRoleArgs<ExtArgs>
  }

  export type $InviteLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InviteLink"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      customRole: Prisma.$CustomRolePayload<ExtArgs> | null
      invitations: Prisma.$EmployeeInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      storeId: string
      createdBy: string
      token: string
      role: string | null
      customRoleId: string | null
      permissions: string | null
      maxUses: number
      usedCount: number
      expiresAt: Date | null
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["inviteLink"]>
    composites: {}
  }

  type InviteLinkGetPayload<S extends boolean | null | undefined | InviteLinkDefaultArgs> = $Result.GetResult<Prisma.$InviteLinkPayload, S>

  type InviteLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InviteLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InviteLinkCountAggregateInputType | true
    }

  export interface InviteLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InviteLink'], meta: { name: 'InviteLink' } }
    /**
     * Find zero or one InviteLink that matches the filter.
     * @param {InviteLinkFindUniqueArgs} args - Arguments to find a InviteLink
     * @example
     * // Get one InviteLink
     * const inviteLink = await prisma.inviteLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteLinkFindUniqueArgs>(args: SelectSubset<T, InviteLinkFindUniqueArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InviteLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InviteLinkFindUniqueOrThrowArgs} args - Arguments to find a InviteLink
     * @example
     * // Get one InviteLink
     * const inviteLink = await prisma.inviteLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InviteLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkFindFirstArgs} args - Arguments to find a InviteLink
     * @example
     * // Get one InviteLink
     * const inviteLink = await prisma.inviteLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteLinkFindFirstArgs>(args?: SelectSubset<T, InviteLinkFindFirstArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InviteLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkFindFirstOrThrowArgs} args - Arguments to find a InviteLink
     * @example
     * // Get one InviteLink
     * const inviteLink = await prisma.inviteLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InviteLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InviteLinks
     * const inviteLinks = await prisma.inviteLink.findMany()
     * 
     * // Get first 10 InviteLinks
     * const inviteLinks = await prisma.inviteLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteLinkWithIdOnly = await prisma.inviteLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteLinkFindManyArgs>(args?: SelectSubset<T, InviteLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InviteLink.
     * @param {InviteLinkCreateArgs} args - Arguments to create a InviteLink.
     * @example
     * // Create one InviteLink
     * const InviteLink = await prisma.inviteLink.create({
     *   data: {
     *     // ... data to create a InviteLink
     *   }
     * })
     * 
     */
    create<T extends InviteLinkCreateArgs>(args: SelectSubset<T, InviteLinkCreateArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InviteLinks.
     * @param {InviteLinkCreateManyArgs} args - Arguments to create many InviteLinks.
     * @example
     * // Create many InviteLinks
     * const inviteLink = await prisma.inviteLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteLinkCreateManyArgs>(args?: SelectSubset<T, InviteLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InviteLinks and returns the data saved in the database.
     * @param {InviteLinkCreateManyAndReturnArgs} args - Arguments to create many InviteLinks.
     * @example
     * // Create many InviteLinks
     * const inviteLink = await prisma.inviteLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InviteLinks and only return the `id`
     * const inviteLinkWithIdOnly = await prisma.inviteLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InviteLink.
     * @param {InviteLinkDeleteArgs} args - Arguments to delete one InviteLink.
     * @example
     * // Delete one InviteLink
     * const InviteLink = await prisma.inviteLink.delete({
     *   where: {
     *     // ... filter to delete one InviteLink
     *   }
     * })
     * 
     */
    delete<T extends InviteLinkDeleteArgs>(args: SelectSubset<T, InviteLinkDeleteArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InviteLink.
     * @param {InviteLinkUpdateArgs} args - Arguments to update one InviteLink.
     * @example
     * // Update one InviteLink
     * const inviteLink = await prisma.inviteLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteLinkUpdateArgs>(args: SelectSubset<T, InviteLinkUpdateArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InviteLinks.
     * @param {InviteLinkDeleteManyArgs} args - Arguments to filter InviteLinks to delete.
     * @example
     * // Delete a few InviteLinks
     * const { count } = await prisma.inviteLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteLinkDeleteManyArgs>(args?: SelectSubset<T, InviteLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InviteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InviteLinks
     * const inviteLink = await prisma.inviteLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteLinkUpdateManyArgs>(args: SelectSubset<T, InviteLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InviteLink.
     * @param {InviteLinkUpsertArgs} args - Arguments to update or create a InviteLink.
     * @example
     * // Update or create a InviteLink
     * const inviteLink = await prisma.inviteLink.upsert({
     *   create: {
     *     // ... data to create a InviteLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InviteLink we want to update
     *   }
     * })
     */
    upsert<T extends InviteLinkUpsertArgs>(args: SelectSubset<T, InviteLinkUpsertArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InviteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkCountArgs} args - Arguments to filter InviteLinks to count.
     * @example
     * // Count the number of InviteLinks
     * const count = await prisma.inviteLink.count({
     *   where: {
     *     // ... the filter for the InviteLinks we want to count
     *   }
     * })
    **/
    count<T extends InviteLinkCountArgs>(
      args?: Subset<T, InviteLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InviteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteLinkAggregateArgs>(args: Subset<T, InviteLinkAggregateArgs>): Prisma.PrismaPromise<GetInviteLinkAggregateType<T>>

    /**
     * Group by InviteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteLinkGroupByArgs['orderBy'] }
        : { orderBy?: InviteLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InviteLink model
   */
  readonly fields: InviteLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InviteLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customRole<T extends InviteLink$customRoleArgs<ExtArgs> = {}>(args?: Subset<T, InviteLink$customRoleArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    invitations<T extends InviteLink$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, InviteLink$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InviteLink model
   */ 
  interface InviteLinkFieldRefs {
    readonly id: FieldRef<"InviteLink", 'String'>
    readonly createdAt: FieldRef<"InviteLink", 'DateTime'>
    readonly updatedAt: FieldRef<"InviteLink", 'DateTime'>
    readonly storeId: FieldRef<"InviteLink", 'String'>
    readonly createdBy: FieldRef<"InviteLink", 'String'>
    readonly token: FieldRef<"InviteLink", 'String'>
    readonly role: FieldRef<"InviteLink", 'String'>
    readonly customRoleId: FieldRef<"InviteLink", 'String'>
    readonly permissions: FieldRef<"InviteLink", 'String'>
    readonly maxUses: FieldRef<"InviteLink", 'Int'>
    readonly usedCount: FieldRef<"InviteLink", 'Int'>
    readonly expiresAt: FieldRef<"InviteLink", 'DateTime'>
    readonly isActive: FieldRef<"InviteLink", 'Boolean'>
    readonly description: FieldRef<"InviteLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InviteLink findUnique
   */
  export type InviteLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLink to fetch.
     */
    where: InviteLinkWhereUniqueInput
  }

  /**
   * InviteLink findUniqueOrThrow
   */
  export type InviteLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLink to fetch.
     */
    where: InviteLinkWhereUniqueInput
  }

  /**
   * InviteLink findFirst
   */
  export type InviteLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLink to fetch.
     */
    where?: InviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteLinks to fetch.
     */
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteLinks.
     */
    cursor?: InviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteLinks.
     */
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * InviteLink findFirstOrThrow
   */
  export type InviteLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLink to fetch.
     */
    where?: InviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteLinks to fetch.
     */
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteLinks.
     */
    cursor?: InviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteLinks.
     */
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * InviteLink findMany
   */
  export type InviteLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLinks to fetch.
     */
    where?: InviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteLinks to fetch.
     */
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InviteLinks.
     */
    cursor?: InviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteLinks.
     */
    skip?: number
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * InviteLink create
   */
  export type InviteLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a InviteLink.
     */
    data: XOR<InviteLinkCreateInput, InviteLinkUncheckedCreateInput>
  }

  /**
   * InviteLink createMany
   */
  export type InviteLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InviteLinks.
     */
    data: InviteLinkCreateManyInput | InviteLinkCreateManyInput[]
  }

  /**
   * InviteLink createManyAndReturn
   */
  export type InviteLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InviteLinks.
     */
    data: InviteLinkCreateManyInput | InviteLinkCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InviteLink update
   */
  export type InviteLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a InviteLink.
     */
    data: XOR<InviteLinkUpdateInput, InviteLinkUncheckedUpdateInput>
    /**
     * Choose, which InviteLink to update.
     */
    where: InviteLinkWhereUniqueInput
  }

  /**
   * InviteLink updateMany
   */
  export type InviteLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InviteLinks.
     */
    data: XOR<InviteLinkUpdateManyMutationInput, InviteLinkUncheckedUpdateManyInput>
    /**
     * Filter which InviteLinks to update
     */
    where?: InviteLinkWhereInput
  }

  /**
   * InviteLink upsert
   */
  export type InviteLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the InviteLink to update in case it exists.
     */
    where: InviteLinkWhereUniqueInput
    /**
     * In case the InviteLink found by the `where` argument doesn't exist, create a new InviteLink with this data.
     */
    create: XOR<InviteLinkCreateInput, InviteLinkUncheckedCreateInput>
    /**
     * In case the InviteLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteLinkUpdateInput, InviteLinkUncheckedUpdateInput>
  }

  /**
   * InviteLink delete
   */
  export type InviteLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter which InviteLink to delete.
     */
    where: InviteLinkWhereUniqueInput
  }

  /**
   * InviteLink deleteMany
   */
  export type InviteLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteLinks to delete
     */
    where?: InviteLinkWhereInput
  }

  /**
   * InviteLink.customRole
   */
  export type InviteLink$customRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    where?: CustomRoleWhereInput
  }

  /**
   * InviteLink.invitations
   */
  export type InviteLink$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeInvitation
     */
    select?: EmployeeInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInvitationInclude<ExtArgs> | null
    where?: EmployeeInvitationWhereInput
    orderBy?: EmployeeInvitationOrderByWithRelationInput | EmployeeInvitationOrderByWithRelationInput[]
    cursor?: EmployeeInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeInvitationScalarFieldEnum | EmployeeInvitationScalarFieldEnum[]
  }

  /**
   * InviteLink without action
   */
  export type InviteLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
  }


  /**
   * Model CustomRole
   */

  export type AggregateCustomRole = {
    _count: CustomRoleCountAggregateOutputType | null
    _min: CustomRoleMinAggregateOutputType | null
    _max: CustomRoleMaxAggregateOutputType | null
  }

  export type CustomRoleMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: string | null
    name: string | null
    description: string | null
    permissions: string | null
    color: string | null
    icon: string | null
    isActive: boolean | null
    createdBy: string | null
  }

  export type CustomRoleMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: string | null
    name: string | null
    description: string | null
    permissions: string | null
    color: string | null
    icon: string | null
    isActive: boolean | null
    createdBy: string | null
  }

  export type CustomRoleCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    storeId: number
    name: number
    description: number
    permissions: number
    color: number
    icon: number
    isActive: number
    createdBy: number
    _all: number
  }


  export type CustomRoleMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    name?: true
    description?: true
    permissions?: true
    color?: true
    icon?: true
    isActive?: true
    createdBy?: true
  }

  export type CustomRoleMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    name?: true
    description?: true
    permissions?: true
    color?: true
    icon?: true
    isActive?: true
    createdBy?: true
  }

  export type CustomRoleCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    name?: true
    description?: true
    permissions?: true
    color?: true
    icon?: true
    isActive?: true
    createdBy?: true
    _all?: true
  }

  export type CustomRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomRole to aggregate.
     */
    where?: CustomRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRoles to fetch.
     */
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomRoles
    **/
    _count?: true | CustomRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomRoleMaxAggregateInputType
  }

  export type GetCustomRoleAggregateType<T extends CustomRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomRole[P]>
      : GetScalarType<T[P], AggregateCustomRole[P]>
  }




  export type CustomRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomRoleWhereInput
    orderBy?: CustomRoleOrderByWithAggregationInput | CustomRoleOrderByWithAggregationInput[]
    by: CustomRoleScalarFieldEnum[] | CustomRoleScalarFieldEnum
    having?: CustomRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomRoleCountAggregateInputType | true
    _min?: CustomRoleMinAggregateInputType
    _max?: CustomRoleMaxAggregateInputType
  }

  export type CustomRoleGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    storeId: string
    name: string
    description: string | null
    permissions: string
    color: string
    icon: string | null
    isActive: boolean
    createdBy: string
    _count: CustomRoleCountAggregateOutputType | null
    _min: CustomRoleMinAggregateOutputType | null
    _max: CustomRoleMaxAggregateOutputType | null
  }

  type GetCustomRoleGroupByPayload<T extends CustomRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomRoleGroupByOutputType[P]>
            : GetScalarType<T[P], CustomRoleGroupByOutputType[P]>
        }
      >
    >


  export type CustomRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    createdBy?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    vendors?: boolean | CustomRole$vendorsArgs<ExtArgs>
    inviteLinks?: boolean | CustomRole$inviteLinksArgs<ExtArgs>
    _count?: boolean | CustomRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customRole"]>

  export type CustomRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    createdBy?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customRole"]>

  export type CustomRoleSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    createdBy?: boolean
  }

  export type CustomRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    vendors?: boolean | CustomRole$vendorsArgs<ExtArgs>
    inviteLinks?: boolean | CustomRole$inviteLinksArgs<ExtArgs>
    _count?: boolean | CustomRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CustomRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomRole"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      vendors: Prisma.$StoreVendorPayload<ExtArgs>[]
      inviteLinks: Prisma.$InviteLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      storeId: string
      name: string
      description: string | null
      permissions: string
      color: string
      icon: string | null
      isActive: boolean
      createdBy: string
    }, ExtArgs["result"]["customRole"]>
    composites: {}
  }

  type CustomRoleGetPayload<S extends boolean | null | undefined | CustomRoleDefaultArgs> = $Result.GetResult<Prisma.$CustomRolePayload, S>

  type CustomRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomRoleCountAggregateInputType | true
    }

  export interface CustomRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomRole'], meta: { name: 'CustomRole' } }
    /**
     * Find zero or one CustomRole that matches the filter.
     * @param {CustomRoleFindUniqueArgs} args - Arguments to find a CustomRole
     * @example
     * // Get one CustomRole
     * const customRole = await prisma.customRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomRoleFindUniqueArgs>(args: SelectSubset<T, CustomRoleFindUniqueArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomRoleFindUniqueOrThrowArgs} args - Arguments to find a CustomRole
     * @example
     * // Get one CustomRole
     * const customRole = await prisma.customRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleFindFirstArgs} args - Arguments to find a CustomRole
     * @example
     * // Get one CustomRole
     * const customRole = await prisma.customRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomRoleFindFirstArgs>(args?: SelectSubset<T, CustomRoleFindFirstArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleFindFirstOrThrowArgs} args - Arguments to find a CustomRole
     * @example
     * // Get one CustomRole
     * const customRole = await prisma.customRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomRoles
     * const customRoles = await prisma.customRole.findMany()
     * 
     * // Get first 10 CustomRoles
     * const customRoles = await prisma.customRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customRoleWithIdOnly = await prisma.customRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomRoleFindManyArgs>(args?: SelectSubset<T, CustomRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomRole.
     * @param {CustomRoleCreateArgs} args - Arguments to create a CustomRole.
     * @example
     * // Create one CustomRole
     * const CustomRole = await prisma.customRole.create({
     *   data: {
     *     // ... data to create a CustomRole
     *   }
     * })
     * 
     */
    create<T extends CustomRoleCreateArgs>(args: SelectSubset<T, CustomRoleCreateArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomRoles.
     * @param {CustomRoleCreateManyArgs} args - Arguments to create many CustomRoles.
     * @example
     * // Create many CustomRoles
     * const customRole = await prisma.customRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomRoleCreateManyArgs>(args?: SelectSubset<T, CustomRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomRoles and returns the data saved in the database.
     * @param {CustomRoleCreateManyAndReturnArgs} args - Arguments to create many CustomRoles.
     * @example
     * // Create many CustomRoles
     * const customRole = await prisma.customRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomRoles and only return the `id`
     * const customRoleWithIdOnly = await prisma.customRole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomRole.
     * @param {CustomRoleDeleteArgs} args - Arguments to delete one CustomRole.
     * @example
     * // Delete one CustomRole
     * const CustomRole = await prisma.customRole.delete({
     *   where: {
     *     // ... filter to delete one CustomRole
     *   }
     * })
     * 
     */
    delete<T extends CustomRoleDeleteArgs>(args: SelectSubset<T, CustomRoleDeleteArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomRole.
     * @param {CustomRoleUpdateArgs} args - Arguments to update one CustomRole.
     * @example
     * // Update one CustomRole
     * const customRole = await prisma.customRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomRoleUpdateArgs>(args: SelectSubset<T, CustomRoleUpdateArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomRoles.
     * @param {CustomRoleDeleteManyArgs} args - Arguments to filter CustomRoles to delete.
     * @example
     * // Delete a few CustomRoles
     * const { count } = await prisma.customRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomRoleDeleteManyArgs>(args?: SelectSubset<T, CustomRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomRoles
     * const customRole = await prisma.customRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomRoleUpdateManyArgs>(args: SelectSubset<T, CustomRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomRole.
     * @param {CustomRoleUpsertArgs} args - Arguments to update or create a CustomRole.
     * @example
     * // Update or create a CustomRole
     * const customRole = await prisma.customRole.upsert({
     *   create: {
     *     // ... data to create a CustomRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomRole we want to update
     *   }
     * })
     */
    upsert<T extends CustomRoleUpsertArgs>(args: SelectSubset<T, CustomRoleUpsertArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleCountArgs} args - Arguments to filter CustomRoles to count.
     * @example
     * // Count the number of CustomRoles
     * const count = await prisma.customRole.count({
     *   where: {
     *     // ... the filter for the CustomRoles we want to count
     *   }
     * })
    **/
    count<T extends CustomRoleCountArgs>(
      args?: Subset<T, CustomRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomRoleAggregateArgs>(args: Subset<T, CustomRoleAggregateArgs>): Prisma.PrismaPromise<GetCustomRoleAggregateType<T>>

    /**
     * Group by CustomRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomRoleGroupByArgs['orderBy'] }
        : { orderBy?: CustomRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomRole model
   */
  readonly fields: CustomRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vendors<T extends CustomRole$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, CustomRole$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreVendorPayload<ExtArgs>, T, "findMany"> | Null>
    inviteLinks<T extends CustomRole$inviteLinksArgs<ExtArgs> = {}>(args?: Subset<T, CustomRole$inviteLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomRole model
   */ 
  interface CustomRoleFieldRefs {
    readonly id: FieldRef<"CustomRole", 'String'>
    readonly createdAt: FieldRef<"CustomRole", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomRole", 'DateTime'>
    readonly storeId: FieldRef<"CustomRole", 'String'>
    readonly name: FieldRef<"CustomRole", 'String'>
    readonly description: FieldRef<"CustomRole", 'String'>
    readonly permissions: FieldRef<"CustomRole", 'String'>
    readonly color: FieldRef<"CustomRole", 'String'>
    readonly icon: FieldRef<"CustomRole", 'String'>
    readonly isActive: FieldRef<"CustomRole", 'Boolean'>
    readonly createdBy: FieldRef<"CustomRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CustomRole findUnique
   */
  export type CustomRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRole to fetch.
     */
    where: CustomRoleWhereUniqueInput
  }

  /**
   * CustomRole findUniqueOrThrow
   */
  export type CustomRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRole to fetch.
     */
    where: CustomRoleWhereUniqueInput
  }

  /**
   * CustomRole findFirst
   */
  export type CustomRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRole to fetch.
     */
    where?: CustomRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRoles to fetch.
     */
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomRoles.
     */
    cursor?: CustomRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomRoles.
     */
    distinct?: CustomRoleScalarFieldEnum | CustomRoleScalarFieldEnum[]
  }

  /**
   * CustomRole findFirstOrThrow
   */
  export type CustomRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRole to fetch.
     */
    where?: CustomRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRoles to fetch.
     */
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomRoles.
     */
    cursor?: CustomRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomRoles.
     */
    distinct?: CustomRoleScalarFieldEnum | CustomRoleScalarFieldEnum[]
  }

  /**
   * CustomRole findMany
   */
  export type CustomRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRoles to fetch.
     */
    where?: CustomRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRoles to fetch.
     */
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomRoles.
     */
    cursor?: CustomRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRoles.
     */
    skip?: number
    distinct?: CustomRoleScalarFieldEnum | CustomRoleScalarFieldEnum[]
  }

  /**
   * CustomRole create
   */
  export type CustomRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomRole.
     */
    data: XOR<CustomRoleCreateInput, CustomRoleUncheckedCreateInput>
  }

  /**
   * CustomRole createMany
   */
  export type CustomRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomRoles.
     */
    data: CustomRoleCreateManyInput | CustomRoleCreateManyInput[]
  }

  /**
   * CustomRole createManyAndReturn
   */
  export type CustomRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomRoles.
     */
    data: CustomRoleCreateManyInput | CustomRoleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomRole update
   */
  export type CustomRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomRole.
     */
    data: XOR<CustomRoleUpdateInput, CustomRoleUncheckedUpdateInput>
    /**
     * Choose, which CustomRole to update.
     */
    where: CustomRoleWhereUniqueInput
  }

  /**
   * CustomRole updateMany
   */
  export type CustomRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomRoles.
     */
    data: XOR<CustomRoleUpdateManyMutationInput, CustomRoleUncheckedUpdateManyInput>
    /**
     * Filter which CustomRoles to update
     */
    where?: CustomRoleWhereInput
  }

  /**
   * CustomRole upsert
   */
  export type CustomRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomRole to update in case it exists.
     */
    where: CustomRoleWhereUniqueInput
    /**
     * In case the CustomRole found by the `where` argument doesn't exist, create a new CustomRole with this data.
     */
    create: XOR<CustomRoleCreateInput, CustomRoleUncheckedCreateInput>
    /**
     * In case the CustomRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomRoleUpdateInput, CustomRoleUncheckedUpdateInput>
  }

  /**
   * CustomRole delete
   */
  export type CustomRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter which CustomRole to delete.
     */
    where: CustomRoleWhereUniqueInput
  }

  /**
   * CustomRole deleteMany
   */
  export type CustomRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomRoles to delete
     */
    where?: CustomRoleWhereInput
  }

  /**
   * CustomRole.vendors
   */
  export type CustomRole$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreVendor
     */
    select?: StoreVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreVendorInclude<ExtArgs> | null
    where?: StoreVendorWhereInput
    orderBy?: StoreVendorOrderByWithRelationInput | StoreVendorOrderByWithRelationInput[]
    cursor?: StoreVendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreVendorScalarFieldEnum | StoreVendorScalarFieldEnum[]
  }

  /**
   * CustomRole.inviteLinks
   */
  export type CustomRole$inviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    where?: InviteLinkWhereInput
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    cursor?: InviteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * CustomRole without action
   */
  export type CustomRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    telegramId: 'telegramId',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    phone: 'phone',
    role: 'role',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    profilePhoto: 'profilePhoto',
    balance: 'balance'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    slug: 'slug',
    status: 'status',
    currency: 'currency',
    domain: 'domain',
    contactInfo: 'contactInfo',
    contactPhone: 'contactPhone',
    settings: 'settings',
    logoUrl: 'logoUrl',
    bannerUrl: 'bannerUrl',
    lowStockThreshold: 'lowStockThreshold',
    criticalStockThreshold: 'criticalStockThreshold',
    enableStockAlerts: 'enableStockAlerts',
    botToken: 'botToken',
    botUsername: 'botUsername',
    botStatus: 'botStatus',
    botWebhookUrl: 'botWebhookUrl',
    botSettings: 'botSettings',
    botCreatedAt: 'botCreatedAt',
    botLastActive: 'botLastActive',
    ownerId: 'ownerId'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const StoreAdminScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    storeId: 'storeId',
    userId: 'userId',
    assignedBy: 'assignedBy'
  };

  export type StoreAdminScalarFieldEnum = (typeof StoreAdminScalarFieldEnum)[keyof typeof StoreAdminScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    slug: 'slug',
    parentId: 'parentId'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    sku: 'sku',
    price: 'price',
    stock: 'stock',
    trackStock: 'trackStock',
    isActive: 'isActive',
    images: 'images',
    storeId: 'storeId',
    categoryId: 'categoryId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductVariantScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    value: 'value',
    price: 'price',
    stock: 'stock',
    sku: 'sku',
    productId: 'productId'
  };

  export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    orderNumber: 'orderNumber',
    status: 'status',
    totalAmount: 'totalAmount',
    currency: 'currency',
    customerInfo: 'customerInfo',
    notes: 'notes',
    paidAt: 'paidAt',
    rejectedAt: 'rejectedAt',
    rejectionReason: 'rejectionReason',
    shippedAt: 'shippedAt',
    deliveredAt: 'deliveredAt',
    cancelledAt: 'cancelledAt',
    trackingNumber: 'trackingNumber',
    carrier: 'carrier',
    deliveryNotes: 'deliveryNotes',
    cancellationReason: 'cancellationReason',
    paymentProof: 'paymentProof',
    clientRequestId: 'clientRequestId',
    customerId: 'customerId',
    storeId: 'storeId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    quantity: 'quantity',
    price: 'price',
    orderId: 'orderId',
    productId: 'productId',
    variantId: 'variantId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const AdminLogScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    action: 'action',
    details: 'details',
    adminId: 'adminId',
    orderId: 'orderId'
  };

  export type AdminLogScalarFieldEnum = (typeof AdminLogScalarFieldEnum)[keyof typeof AdminLogScalarFieldEnum]


  export const IntegrationMappingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    source: 'source',
    entityType: 'entityType',
    localId: 'localId',
    externalId: 'externalId',
    storeId: 'storeId'
  };

  export type IntegrationMappingScalarFieldEnum = (typeof IntegrationMappingScalarFieldEnum)[keyof typeof IntegrationMappingScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    title: 'title',
    message: 'message',
    priority: 'priority',
    channels: 'channels',
    data: 'data',
    readAt: 'readAt',
    storeId: 'storeId',
    orderId: 'orderId',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    isRevoked: 'isRevoked',
    revokedAt: 'revokedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const RevokedTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    revokedAt: 'revokedAt',
    expiresAt: 'expiresAt',
    reason: 'reason'
  };

  export type RevokedTokenScalarFieldEnum = (typeof RevokedTokenScalarFieldEnum)[keyof typeof RevokedTokenScalarFieldEnum]


  export const StoreVendorScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    storeId: 'storeId',
    userId: 'userId',
    assignedBy: 'assignedBy',
    isActive: 'isActive',
    permissions: 'permissions',
    customRoleId: 'customRoleId'
  };

  export type StoreVendorScalarFieldEnum = (typeof StoreVendorScalarFieldEnum)[keyof typeof StoreVendorScalarFieldEnum]


  export const StockLogScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    productId: 'productId',
    storeId: 'storeId',
    variantId: 'variantId',
    changeType: 'changeType',
    previousQty: 'previousQty',
    newQty: 'newQty',
    changeQty: 'changeQty',
    reason: 'reason',
    userId: 'userId',
    orderId: 'orderId'
  };

  export type StockLogScalarFieldEnum = (typeof StockLogScalarFieldEnum)[keyof typeof StockLogScalarFieldEnum]


  export const EmployeeInvitationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    storeId: 'storeId',
    userId: 'userId',
    invitedBy: 'invitedBy',
    role: 'role',
    customRoleId: 'customRoleId',
    permissions: 'permissions',
    token: 'token',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt',
    rejectedAt: 'rejectedAt',
    message: 'message',
    status: 'status',
    inviteLinkId: 'inviteLinkId'
  };

  export type EmployeeInvitationScalarFieldEnum = (typeof EmployeeInvitationScalarFieldEnum)[keyof typeof EmployeeInvitationScalarFieldEnum]


  export const EmployeeActivityScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    storeId: 'storeId',
    userId: 'userId',
    action: 'action',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type EmployeeActivityScalarFieldEnum = (typeof EmployeeActivityScalarFieldEnum)[keyof typeof EmployeeActivityScalarFieldEnum]


  export const InviteLinkScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    storeId: 'storeId',
    createdBy: 'createdBy',
    token: 'token',
    role: 'role',
    customRoleId: 'customRoleId',
    permissions: 'permissions',
    maxUses: 'maxUses',
    usedCount: 'usedCount',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    description: 'description'
  };

  export type InviteLinkScalarFieldEnum = (typeof InviteLinkScalarFieldEnum)[keyof typeof InviteLinkScalarFieldEnum]


  export const CustomRoleScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    storeId: 'storeId',
    name: 'name',
    description: 'description',
    permissions: 'permissions',
    color: 'color',
    icon: 'icon',
    isActive: 'isActive',
    createdBy: 'createdBy'
  };

  export type CustomRoleScalarFieldEnum = (typeof CustomRoleScalarFieldEnum)[keyof typeof CustomRoleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    telegramId?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profilePhoto?: StringNullableFilter<"User"> | string | null
    balance?: FloatFilter<"User"> | number
    adminLogs?: AdminLogListRelationFilter
    orders?: OrderListRelationFilter
    managedStores?: StoreAdminListRelationFilter
    assignedAdmins?: StoreAdminListRelationFilter
    ownedStores?: StoreListRelationFilter
    vendorStores?: StoreVendorListRelationFilter
    sessions?: UserSessionListRelationFilter
    notifications?: NotificationListRelationFilter
    receivedInvitations?: EmployeeInvitationListRelationFilter
    sentInvitations?: EmployeeInvitationListRelationFilter
    employeeActivities?: EmployeeActivityListRelationFilter
    createdInviteLinks?: InviteLinkListRelationFilter
    createdCustomRoles?: CustomRoleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    balance?: SortOrder
    adminLogs?: AdminLogOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    managedStores?: StoreAdminOrderByRelationAggregateInput
    assignedAdmins?: StoreAdminOrderByRelationAggregateInput
    ownedStores?: StoreOrderByRelationAggregateInput
    vendorStores?: StoreVendorOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    receivedInvitations?: EmployeeInvitationOrderByRelationAggregateInput
    sentInvitations?: EmployeeInvitationOrderByRelationAggregateInput
    employeeActivities?: EmployeeActivityOrderByRelationAggregateInput
    createdInviteLinks?: InviteLinkOrderByRelationAggregateInput
    createdCustomRoles?: CustomRoleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    telegramId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profilePhoto?: StringNullableFilter<"User"> | string | null
    balance?: FloatFilter<"User"> | number
    adminLogs?: AdminLogListRelationFilter
    orders?: OrderListRelationFilter
    managedStores?: StoreAdminListRelationFilter
    assignedAdmins?: StoreAdminListRelationFilter
    ownedStores?: StoreListRelationFilter
    vendorStores?: StoreVendorListRelationFilter
    sessions?: UserSessionListRelationFilter
    notifications?: NotificationListRelationFilter
    receivedInvitations?: EmployeeInvitationListRelationFilter
    sentInvitations?: EmployeeInvitationListRelationFilter
    employeeActivities?: EmployeeActivityListRelationFilter
    createdInviteLinks?: InviteLinkListRelationFilter
    createdCustomRoles?: CustomRoleListRelationFilter
  }, "id" | "telegramId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    balance?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    telegramId?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    profilePhoto?: StringNullableWithAggregatesFilter<"User"> | string | null
    balance?: FloatWithAggregatesFilter<"User"> | number
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    name?: StringFilter<"Store"> | string
    description?: StringNullableFilter<"Store"> | string | null
    slug?: StringFilter<"Store"> | string
    status?: StringFilter<"Store"> | string
    currency?: StringFilter<"Store"> | string
    domain?: StringNullableFilter<"Store"> | string | null
    contactInfo?: StringNullableFilter<"Store"> | string | null
    contactPhone?: StringNullableFilter<"Store"> | string | null
    settings?: StringNullableFilter<"Store"> | string | null
    logoUrl?: StringNullableFilter<"Store"> | string | null
    bannerUrl?: StringNullableFilter<"Store"> | string | null
    lowStockThreshold?: IntFilter<"Store"> | number
    criticalStockThreshold?: IntFilter<"Store"> | number
    enableStockAlerts?: BoolFilter<"Store"> | boolean
    botToken?: StringNullableFilter<"Store"> | string | null
    botUsername?: StringNullableFilter<"Store"> | string | null
    botStatus?: StringFilter<"Store"> | string
    botWebhookUrl?: StringNullableFilter<"Store"> | string | null
    botSettings?: StringNullableFilter<"Store"> | string | null
    botCreatedAt?: DateTimeNullableFilter<"Store"> | Date | string | null
    botLastActive?: DateTimeNullableFilter<"Store"> | Date | string | null
    ownerId?: StringFilter<"Store"> | string
    integrationMappings?: IntegrationMappingListRelationFilter
    orders?: OrderListRelationFilter
    products?: ProductListRelationFilter
    admins?: StoreAdminListRelationFilter
    vendors?: StoreVendorListRelationFilter
    stockLogs?: StockLogListRelationFilter
    notifications?: NotificationListRelationFilter
    employeeInvitations?: EmployeeInvitationListRelationFilter
    employeeActivities?: EmployeeActivityListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
    customRoles?: CustomRoleListRelationFilter
    owner?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    domain?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    bannerUrl?: SortOrderInput | SortOrder
    lowStockThreshold?: SortOrder
    criticalStockThreshold?: SortOrder
    enableStockAlerts?: SortOrder
    botToken?: SortOrderInput | SortOrder
    botUsername?: SortOrderInput | SortOrder
    botStatus?: SortOrder
    botWebhookUrl?: SortOrderInput | SortOrder
    botSettings?: SortOrderInput | SortOrder
    botCreatedAt?: SortOrderInput | SortOrder
    botLastActive?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    integrationMappings?: IntegrationMappingOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    admins?: StoreAdminOrderByRelationAggregateInput
    vendors?: StoreVendorOrderByRelationAggregateInput
    stockLogs?: StockLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    employeeInvitations?: EmployeeInvitationOrderByRelationAggregateInput
    employeeActivities?: EmployeeActivityOrderByRelationAggregateInput
    inviteLinks?: InviteLinkOrderByRelationAggregateInput
    customRoles?: CustomRoleOrderByRelationAggregateInput
    owner?: UserOrderByWithRelationInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    domain?: string
    botToken?: string
    botUsername?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    name?: StringFilter<"Store"> | string
    description?: StringNullableFilter<"Store"> | string | null
    status?: StringFilter<"Store"> | string
    currency?: StringFilter<"Store"> | string
    contactInfo?: StringNullableFilter<"Store"> | string | null
    contactPhone?: StringNullableFilter<"Store"> | string | null
    settings?: StringNullableFilter<"Store"> | string | null
    logoUrl?: StringNullableFilter<"Store"> | string | null
    bannerUrl?: StringNullableFilter<"Store"> | string | null
    lowStockThreshold?: IntFilter<"Store"> | number
    criticalStockThreshold?: IntFilter<"Store"> | number
    enableStockAlerts?: BoolFilter<"Store"> | boolean
    botStatus?: StringFilter<"Store"> | string
    botWebhookUrl?: StringNullableFilter<"Store"> | string | null
    botSettings?: StringNullableFilter<"Store"> | string | null
    botCreatedAt?: DateTimeNullableFilter<"Store"> | Date | string | null
    botLastActive?: DateTimeNullableFilter<"Store"> | Date | string | null
    ownerId?: StringFilter<"Store"> | string
    integrationMappings?: IntegrationMappingListRelationFilter
    orders?: OrderListRelationFilter
    products?: ProductListRelationFilter
    admins?: StoreAdminListRelationFilter
    vendors?: StoreVendorListRelationFilter
    stockLogs?: StockLogListRelationFilter
    notifications?: NotificationListRelationFilter
    employeeInvitations?: EmployeeInvitationListRelationFilter
    employeeActivities?: EmployeeActivityListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
    customRoles?: CustomRoleListRelationFilter
    owner?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "slug" | "domain" | "botToken" | "botUsername">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    domain?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    bannerUrl?: SortOrderInput | SortOrder
    lowStockThreshold?: SortOrder
    criticalStockThreshold?: SortOrder
    enableStockAlerts?: SortOrder
    botToken?: SortOrderInput | SortOrder
    botUsername?: SortOrderInput | SortOrder
    botStatus?: SortOrder
    botWebhookUrl?: SortOrderInput | SortOrder
    botSettings?: SortOrderInput | SortOrder
    botCreatedAt?: SortOrderInput | SortOrder
    botLastActive?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _avg?: StoreAvgOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
    _sum?: StoreSumOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Store"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    name?: StringWithAggregatesFilter<"Store"> | string
    description?: StringNullableWithAggregatesFilter<"Store"> | string | null
    slug?: StringWithAggregatesFilter<"Store"> | string
    status?: StringWithAggregatesFilter<"Store"> | string
    currency?: StringWithAggregatesFilter<"Store"> | string
    domain?: StringNullableWithAggregatesFilter<"Store"> | string | null
    contactInfo?: StringNullableWithAggregatesFilter<"Store"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Store"> | string | null
    settings?: StringNullableWithAggregatesFilter<"Store"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Store"> | string | null
    bannerUrl?: StringNullableWithAggregatesFilter<"Store"> | string | null
    lowStockThreshold?: IntWithAggregatesFilter<"Store"> | number
    criticalStockThreshold?: IntWithAggregatesFilter<"Store"> | number
    enableStockAlerts?: BoolWithAggregatesFilter<"Store"> | boolean
    botToken?: StringNullableWithAggregatesFilter<"Store"> | string | null
    botUsername?: StringNullableWithAggregatesFilter<"Store"> | string | null
    botStatus?: StringWithAggregatesFilter<"Store"> | string
    botWebhookUrl?: StringNullableWithAggregatesFilter<"Store"> | string | null
    botSettings?: StringNullableWithAggregatesFilter<"Store"> | string | null
    botCreatedAt?: DateTimeNullableWithAggregatesFilter<"Store"> | Date | string | null
    botLastActive?: DateTimeNullableWithAggregatesFilter<"Store"> | Date | string | null
    ownerId?: StringWithAggregatesFilter<"Store"> | string
  }

  export type StoreAdminWhereInput = {
    AND?: StoreAdminWhereInput | StoreAdminWhereInput[]
    OR?: StoreAdminWhereInput[]
    NOT?: StoreAdminWhereInput | StoreAdminWhereInput[]
    id?: StringFilter<"StoreAdmin"> | string
    createdAt?: DateTimeFilter<"StoreAdmin"> | Date | string
    storeId?: StringFilter<"StoreAdmin"> | string
    userId?: StringFilter<"StoreAdmin"> | string
    assignedBy?: StringNullableFilter<"StoreAdmin"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    assignedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type StoreAdminOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    store?: StoreOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    assignedByUser?: UserOrderByWithRelationInput
  }

  export type StoreAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_userId?: StoreAdminStoreIdUserIdCompoundUniqueInput
    AND?: StoreAdminWhereInput | StoreAdminWhereInput[]
    OR?: StoreAdminWhereInput[]
    NOT?: StoreAdminWhereInput | StoreAdminWhereInput[]
    createdAt?: DateTimeFilter<"StoreAdmin"> | Date | string
    storeId?: StringFilter<"StoreAdmin"> | string
    userId?: StringFilter<"StoreAdmin"> | string
    assignedBy?: StringNullableFilter<"StoreAdmin"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    assignedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "storeId_userId">

  export type StoreAdminOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    _count?: StoreAdminCountOrderByAggregateInput
    _max?: StoreAdminMaxOrderByAggregateInput
    _min?: StoreAdminMinOrderByAggregateInput
  }

  export type StoreAdminScalarWhereWithAggregatesInput = {
    AND?: StoreAdminScalarWhereWithAggregatesInput | StoreAdminScalarWhereWithAggregatesInput[]
    OR?: StoreAdminScalarWhereWithAggregatesInput[]
    NOT?: StoreAdminScalarWhereWithAggregatesInput | StoreAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreAdmin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StoreAdmin"> | Date | string
    storeId?: StringWithAggregatesFilter<"StoreAdmin"> | string
    userId?: StringWithAggregatesFilter<"StoreAdmin"> | string
    assignedBy?: StringNullableWithAggregatesFilter<"StoreAdmin"> | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    name?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    trackStock?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    images?: StringNullableFilter<"Product"> | string | null
    storeId?: StringFilter<"Product"> | string
    categoryId?: StringNullableFilter<"Product"> | string | null
    orderItems?: OrderItemListRelationFilter
    variants?: ProductVariantListRelationFilter
    stockLogs?: StockLogListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    trackStock?: SortOrder
    isActive?: SortOrder
    images?: SortOrderInput | SortOrder
    storeId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    variants?: ProductVariantOrderByRelationAggregateInput
    stockLogs?: StockLogOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_sku?: ProductStoreIdSkuCompoundUniqueInput
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    trackStock?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    images?: StringNullableFilter<"Product"> | string | null
    storeId?: StringFilter<"Product"> | string
    categoryId?: StringNullableFilter<"Product"> | string | null
    orderItems?: OrderItemListRelationFilter
    variants?: ProductVariantListRelationFilter
    stockLogs?: StockLogListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id" | "storeId_sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    trackStock?: SortOrder
    isActive?: SortOrder
    images?: SortOrderInput | SortOrder
    storeId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatWithAggregatesFilter<"Product"> | number
    stock?: IntWithAggregatesFilter<"Product"> | number
    trackStock?: BoolWithAggregatesFilter<"Product"> | boolean
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    images?: StringNullableWithAggregatesFilter<"Product"> | string | null
    storeId?: StringWithAggregatesFilter<"Product"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type ProductVariantWhereInput = {
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    name?: StringFilter<"ProductVariant"> | string
    value?: StringFilter<"ProductVariant"> | string
    price?: FloatNullableFilter<"ProductVariant"> | number | null
    stock?: IntNullableFilter<"ProductVariant"> | number | null
    sku?: StringNullableFilter<"ProductVariant"> | string | null
    productId?: StringFilter<"ProductVariant"> | string
    orderItems?: OrderItemListRelationFilter
    stockLogs?: StockLogListRelationFilter
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    value?: SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    productId?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    stockLogs?: StockLogOrderByRelationAggregateInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_name_value?: ProductVariantProductIdNameValueCompoundUniqueInput
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    name?: StringFilter<"ProductVariant"> | string
    value?: StringFilter<"ProductVariant"> | string
    price?: FloatNullableFilter<"ProductVariant"> | number | null
    stock?: IntNullableFilter<"ProductVariant"> | number | null
    sku?: StringNullableFilter<"ProductVariant"> | string | null
    productId?: StringFilter<"ProductVariant"> | string
    orderItems?: OrderItemListRelationFilter
    stockLogs?: StockLogListRelationFilter
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "productId_name_value">

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    value?: SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    productId?: SortOrder
    _count?: ProductVariantCountOrderByAggregateInput
    _avg?: ProductVariantAvgOrderByAggregateInput
    _max?: ProductVariantMaxOrderByAggregateInput
    _min?: ProductVariantMinOrderByAggregateInput
    _sum?: ProductVariantSumOrderByAggregateInput
  }

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    OR?: ProductVariantScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
    name?: StringWithAggregatesFilter<"ProductVariant"> | string
    value?: StringWithAggregatesFilter<"ProductVariant"> | string
    price?: FloatNullableWithAggregatesFilter<"ProductVariant"> | number | null
    stock?: IntNullableWithAggregatesFilter<"ProductVariant"> | number | null
    sku?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    productId?: StringWithAggregatesFilter<"ProductVariant"> | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderNumber?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    totalAmount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    customerInfo?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    trackingNumber?: StringNullableFilter<"Order"> | string | null
    carrier?: StringNullableFilter<"Order"> | string | null
    deliveryNotes?: StringNullableFilter<"Order"> | string | null
    cancellationReason?: StringNullableFilter<"Order"> | string | null
    paymentProof?: StringNullableFilter<"Order"> | string | null
    clientRequestId?: StringNullableFilter<"Order"> | string | null
    customerId?: StringFilter<"Order"> | string
    storeId?: StringFilter<"Order"> | string
    adminLogs?: AdminLogListRelationFilter
    items?: OrderItemListRelationFilter
    notifications?: NotificationListRelationFilter
    customer?: XOR<UserRelationFilter, UserWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    customerInfo?: SortOrder
    notes?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    deliveryNotes?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    paymentProof?: SortOrderInput | SortOrder
    clientRequestId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    adminLogs?: AdminLogOrderByRelationAggregateInput
    items?: OrderItemOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    customer?: UserOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    clientRequestId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    totalAmount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    customerInfo?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    trackingNumber?: StringNullableFilter<"Order"> | string | null
    carrier?: StringNullableFilter<"Order"> | string | null
    deliveryNotes?: StringNullableFilter<"Order"> | string | null
    cancellationReason?: StringNullableFilter<"Order"> | string | null
    paymentProof?: StringNullableFilter<"Order"> | string | null
    customerId?: StringFilter<"Order"> | string
    storeId?: StringFilter<"Order"> | string
    adminLogs?: AdminLogListRelationFilter
    items?: OrderItemListRelationFilter
    notifications?: NotificationListRelationFilter
    customer?: XOR<UserRelationFilter, UserWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id" | "orderNumber" | "clientRequestId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    customerInfo?: SortOrder
    notes?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    deliveryNotes?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    paymentProof?: SortOrderInput | SortOrder
    clientRequestId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    status?: StringWithAggregatesFilter<"Order"> | string
    totalAmount?: FloatWithAggregatesFilter<"Order"> | number
    currency?: StringWithAggregatesFilter<"Order"> | string
    customerInfo?: StringWithAggregatesFilter<"Order"> | string
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    trackingNumber?: StringNullableWithAggregatesFilter<"Order"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"Order"> | string | null
    deliveryNotes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentProof?: StringNullableWithAggregatesFilter<"Order"> | string | null
    clientRequestId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerId?: StringWithAggregatesFilter<"Order"> | string
    storeId?: StringWithAggregatesFilter<"Order"> | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    variantId?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    variantId?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: FloatWithAggregatesFilter<"OrderItem"> | number
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    variantId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
  }

  export type AdminLogWhereInput = {
    AND?: AdminLogWhereInput | AdminLogWhereInput[]
    OR?: AdminLogWhereInput[]
    NOT?: AdminLogWhereInput | AdminLogWhereInput[]
    id?: StringFilter<"AdminLog"> | string
    createdAt?: DateTimeFilter<"AdminLog"> | Date | string
    action?: StringFilter<"AdminLog"> | string
    details?: StringNullableFilter<"AdminLog"> | string | null
    adminId?: StringFilter<"AdminLog"> | string
    orderId?: StringNullableFilter<"AdminLog"> | string | null
    admin?: XOR<UserRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }

  export type AdminLogOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    adminId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    admin?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type AdminLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminLogWhereInput | AdminLogWhereInput[]
    OR?: AdminLogWhereInput[]
    NOT?: AdminLogWhereInput | AdminLogWhereInput[]
    createdAt?: DateTimeFilter<"AdminLog"> | Date | string
    action?: StringFilter<"AdminLog"> | string
    details?: StringNullableFilter<"AdminLog"> | string | null
    adminId?: StringFilter<"AdminLog"> | string
    orderId?: StringNullableFilter<"AdminLog"> | string | null
    admin?: XOR<UserRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }, "id">

  export type AdminLogOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    adminId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    _count?: AdminLogCountOrderByAggregateInput
    _max?: AdminLogMaxOrderByAggregateInput
    _min?: AdminLogMinOrderByAggregateInput
  }

  export type AdminLogScalarWhereWithAggregatesInput = {
    AND?: AdminLogScalarWhereWithAggregatesInput | AdminLogScalarWhereWithAggregatesInput[]
    OR?: AdminLogScalarWhereWithAggregatesInput[]
    NOT?: AdminLogScalarWhereWithAggregatesInput | AdminLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminLog"> | Date | string
    action?: StringWithAggregatesFilter<"AdminLog"> | string
    details?: StringNullableWithAggregatesFilter<"AdminLog"> | string | null
    adminId?: StringWithAggregatesFilter<"AdminLog"> | string
    orderId?: StringNullableWithAggregatesFilter<"AdminLog"> | string | null
  }

  export type IntegrationMappingWhereInput = {
    AND?: IntegrationMappingWhereInput | IntegrationMappingWhereInput[]
    OR?: IntegrationMappingWhereInput[]
    NOT?: IntegrationMappingWhereInput | IntegrationMappingWhereInput[]
    id?: StringFilter<"IntegrationMapping"> | string
    createdAt?: DateTimeFilter<"IntegrationMapping"> | Date | string
    updatedAt?: DateTimeFilter<"IntegrationMapping"> | Date | string
    source?: StringFilter<"IntegrationMapping"> | string
    entityType?: StringFilter<"IntegrationMapping"> | string
    localId?: StringFilter<"IntegrationMapping"> | string
    externalId?: StringFilter<"IntegrationMapping"> | string
    storeId?: StringNullableFilter<"IntegrationMapping"> | string | null
    store?: XOR<StoreNullableRelationFilter, StoreWhereInput> | null
  }

  export type IntegrationMappingOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    entityType?: SortOrder
    localId?: SortOrder
    externalId?: SortOrder
    storeId?: SortOrderInput | SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type IntegrationMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    source_entityType_externalId?: IntegrationMappingSourceEntityTypeExternalIdCompoundUniqueInput
    source_entityType_localId?: IntegrationMappingSourceEntityTypeLocalIdCompoundUniqueInput
    AND?: IntegrationMappingWhereInput | IntegrationMappingWhereInput[]
    OR?: IntegrationMappingWhereInput[]
    NOT?: IntegrationMappingWhereInput | IntegrationMappingWhereInput[]
    createdAt?: DateTimeFilter<"IntegrationMapping"> | Date | string
    updatedAt?: DateTimeFilter<"IntegrationMapping"> | Date | string
    source?: StringFilter<"IntegrationMapping"> | string
    entityType?: StringFilter<"IntegrationMapping"> | string
    localId?: StringFilter<"IntegrationMapping"> | string
    externalId?: StringFilter<"IntegrationMapping"> | string
    storeId?: StringNullableFilter<"IntegrationMapping"> | string | null
    store?: XOR<StoreNullableRelationFilter, StoreWhereInput> | null
  }, "id" | "source_entityType_externalId" | "source_entityType_localId">

  export type IntegrationMappingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    entityType?: SortOrder
    localId?: SortOrder
    externalId?: SortOrder
    storeId?: SortOrderInput | SortOrder
    _count?: IntegrationMappingCountOrderByAggregateInput
    _max?: IntegrationMappingMaxOrderByAggregateInput
    _min?: IntegrationMappingMinOrderByAggregateInput
  }

  export type IntegrationMappingScalarWhereWithAggregatesInput = {
    AND?: IntegrationMappingScalarWhereWithAggregatesInput | IntegrationMappingScalarWhereWithAggregatesInput[]
    OR?: IntegrationMappingScalarWhereWithAggregatesInput[]
    NOT?: IntegrationMappingScalarWhereWithAggregatesInput | IntegrationMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntegrationMapping"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IntegrationMapping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IntegrationMapping"> | Date | string
    source?: StringWithAggregatesFilter<"IntegrationMapping"> | string
    entityType?: StringWithAggregatesFilter<"IntegrationMapping"> | string
    localId?: StringWithAggregatesFilter<"IntegrationMapping"> | string
    externalId?: StringWithAggregatesFilter<"IntegrationMapping"> | string
    storeId?: StringNullableWithAggregatesFilter<"IntegrationMapping"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    channels?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    storeId?: StringNullableFilter<"Notification"> | string | null
    orderId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    store?: XOR<StoreNullableRelationFilter, StoreWhereInput> | null
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channels?: SortOrder
    data?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    channels?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    storeId?: StringNullableFilter<"Notification"> | string | null
    orderId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    store?: XOR<StoreNullableRelationFilter, StoreWhereInput> | null
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channels?: SortOrder
    data?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    priority?: StringWithAggregatesFilter<"Notification"> | string
    channels?: StringWithAggregatesFilter<"Notification"> | string
    data?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    storeId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    userId?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    userId?: StringFilter<"UserSession"> | string
    refreshToken?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isRevoked?: BoolFilter<"UserSession"> | boolean
    revokedAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    userId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isRevoked?: BoolFilter<"UserSession"> | boolean
    revokedAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "refreshToken">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    refreshToken?: StringWithAggregatesFilter<"UserSession"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    isRevoked?: BoolWithAggregatesFilter<"UserSession"> | boolean
    revokedAt?: DateTimeNullableWithAggregatesFilter<"UserSession"> | Date | string | null
  }

  export type RevokedTokenWhereInput = {
    AND?: RevokedTokenWhereInput | RevokedTokenWhereInput[]
    OR?: RevokedTokenWhereInput[]
    NOT?: RevokedTokenWhereInput | RevokedTokenWhereInput[]
    id?: StringFilter<"RevokedToken"> | string
    token?: StringFilter<"RevokedToken"> | string
    userId?: StringFilter<"RevokedToken"> | string
    revokedAt?: DateTimeFilter<"RevokedToken"> | Date | string
    expiresAt?: DateTimeFilter<"RevokedToken"> | Date | string
    reason?: StringNullableFilter<"RevokedToken"> | string | null
  }

  export type RevokedTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    reason?: SortOrderInput | SortOrder
  }

  export type RevokedTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RevokedTokenWhereInput | RevokedTokenWhereInput[]
    OR?: RevokedTokenWhereInput[]
    NOT?: RevokedTokenWhereInput | RevokedTokenWhereInput[]
    userId?: StringFilter<"RevokedToken"> | string
    revokedAt?: DateTimeFilter<"RevokedToken"> | Date | string
    expiresAt?: DateTimeFilter<"RevokedToken"> | Date | string
    reason?: StringNullableFilter<"RevokedToken"> | string | null
  }, "id" | "token">

  export type RevokedTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    _count?: RevokedTokenCountOrderByAggregateInput
    _max?: RevokedTokenMaxOrderByAggregateInput
    _min?: RevokedTokenMinOrderByAggregateInput
  }

  export type RevokedTokenScalarWhereWithAggregatesInput = {
    AND?: RevokedTokenScalarWhereWithAggregatesInput | RevokedTokenScalarWhereWithAggregatesInput[]
    OR?: RevokedTokenScalarWhereWithAggregatesInput[]
    NOT?: RevokedTokenScalarWhereWithAggregatesInput | RevokedTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RevokedToken"> | string
    token?: StringWithAggregatesFilter<"RevokedToken"> | string
    userId?: StringWithAggregatesFilter<"RevokedToken"> | string
    revokedAt?: DateTimeWithAggregatesFilter<"RevokedToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"RevokedToken"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"RevokedToken"> | string | null
  }

  export type StoreVendorWhereInput = {
    AND?: StoreVendorWhereInput | StoreVendorWhereInput[]
    OR?: StoreVendorWhereInput[]
    NOT?: StoreVendorWhereInput | StoreVendorWhereInput[]
    id?: StringFilter<"StoreVendor"> | string
    createdAt?: DateTimeFilter<"StoreVendor"> | Date | string
    updatedAt?: DateTimeFilter<"StoreVendor"> | Date | string
    storeId?: StringFilter<"StoreVendor"> | string
    userId?: StringFilter<"StoreVendor"> | string
    assignedBy?: StringNullableFilter<"StoreVendor"> | string | null
    isActive?: BoolFilter<"StoreVendor"> | boolean
    permissions?: StringNullableFilter<"StoreVendor"> | string | null
    customRoleId?: StringNullableFilter<"StoreVendor"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    customRole?: XOR<CustomRoleNullableRelationFilter, CustomRoleWhereInput> | null
  }

  export type StoreVendorOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    permissions?: SortOrderInput | SortOrder
    customRoleId?: SortOrderInput | SortOrder
    store?: StoreOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    customRole?: CustomRoleOrderByWithRelationInput
  }

  export type StoreVendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_userId?: StoreVendorStoreIdUserIdCompoundUniqueInput
    AND?: StoreVendorWhereInput | StoreVendorWhereInput[]
    OR?: StoreVendorWhereInput[]
    NOT?: StoreVendorWhereInput | StoreVendorWhereInput[]
    createdAt?: DateTimeFilter<"StoreVendor"> | Date | string
    updatedAt?: DateTimeFilter<"StoreVendor"> | Date | string
    storeId?: StringFilter<"StoreVendor"> | string
    userId?: StringFilter<"StoreVendor"> | string
    assignedBy?: StringNullableFilter<"StoreVendor"> | string | null
    isActive?: BoolFilter<"StoreVendor"> | boolean
    permissions?: StringNullableFilter<"StoreVendor"> | string | null
    customRoleId?: StringNullableFilter<"StoreVendor"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    customRole?: XOR<CustomRoleNullableRelationFilter, CustomRoleWhereInput> | null
  }, "id" | "storeId_userId">

  export type StoreVendorOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    permissions?: SortOrderInput | SortOrder
    customRoleId?: SortOrderInput | SortOrder
    _count?: StoreVendorCountOrderByAggregateInput
    _max?: StoreVendorMaxOrderByAggregateInput
    _min?: StoreVendorMinOrderByAggregateInput
  }

  export type StoreVendorScalarWhereWithAggregatesInput = {
    AND?: StoreVendorScalarWhereWithAggregatesInput | StoreVendorScalarWhereWithAggregatesInput[]
    OR?: StoreVendorScalarWhereWithAggregatesInput[]
    NOT?: StoreVendorScalarWhereWithAggregatesInput | StoreVendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreVendor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StoreVendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreVendor"> | Date | string
    storeId?: StringWithAggregatesFilter<"StoreVendor"> | string
    userId?: StringWithAggregatesFilter<"StoreVendor"> | string
    assignedBy?: StringNullableWithAggregatesFilter<"StoreVendor"> | string | null
    isActive?: BoolWithAggregatesFilter<"StoreVendor"> | boolean
    permissions?: StringNullableWithAggregatesFilter<"StoreVendor"> | string | null
    customRoleId?: StringNullableWithAggregatesFilter<"StoreVendor"> | string | null
  }

  export type StockLogWhereInput = {
    AND?: StockLogWhereInput | StockLogWhereInput[]
    OR?: StockLogWhereInput[]
    NOT?: StockLogWhereInput | StockLogWhereInput[]
    id?: StringFilter<"StockLog"> | string
    createdAt?: DateTimeFilter<"StockLog"> | Date | string
    productId?: StringFilter<"StockLog"> | string
    storeId?: StringFilter<"StockLog"> | string
    variantId?: StringNullableFilter<"StockLog"> | string | null
    changeType?: StringFilter<"StockLog"> | string
    previousQty?: IntFilter<"StockLog"> | number
    newQty?: IntFilter<"StockLog"> | number
    changeQty?: IntFilter<"StockLog"> | number
    reason?: StringNullableFilter<"StockLog"> | string | null
    userId?: StringNullableFilter<"StockLog"> | string | null
    orderId?: StringNullableFilter<"StockLog"> | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }

  export type StockLogOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    changeType?: SortOrder
    previousQty?: SortOrder
    newQty?: SortOrder
    changeQty?: SortOrder
    reason?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type StockLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockLogWhereInput | StockLogWhereInput[]
    OR?: StockLogWhereInput[]
    NOT?: StockLogWhereInput | StockLogWhereInput[]
    createdAt?: DateTimeFilter<"StockLog"> | Date | string
    productId?: StringFilter<"StockLog"> | string
    storeId?: StringFilter<"StockLog"> | string
    variantId?: StringNullableFilter<"StockLog"> | string | null
    changeType?: StringFilter<"StockLog"> | string
    previousQty?: IntFilter<"StockLog"> | number
    newQty?: IntFilter<"StockLog"> | number
    changeQty?: IntFilter<"StockLog"> | number
    reason?: StringNullableFilter<"StockLog"> | string | null
    userId?: StringNullableFilter<"StockLog"> | string | null
    orderId?: StringNullableFilter<"StockLog"> | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    variant?: XOR<ProductVariantNullableRelationFilter, ProductVariantWhereInput> | null
  }, "id">

  export type StockLogOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    changeType?: SortOrder
    previousQty?: SortOrder
    newQty?: SortOrder
    changeQty?: SortOrder
    reason?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    _count?: StockLogCountOrderByAggregateInput
    _avg?: StockLogAvgOrderByAggregateInput
    _max?: StockLogMaxOrderByAggregateInput
    _min?: StockLogMinOrderByAggregateInput
    _sum?: StockLogSumOrderByAggregateInput
  }

  export type StockLogScalarWhereWithAggregatesInput = {
    AND?: StockLogScalarWhereWithAggregatesInput | StockLogScalarWhereWithAggregatesInput[]
    OR?: StockLogScalarWhereWithAggregatesInput[]
    NOT?: StockLogScalarWhereWithAggregatesInput | StockLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StockLog"> | Date | string
    productId?: StringWithAggregatesFilter<"StockLog"> | string
    storeId?: StringWithAggregatesFilter<"StockLog"> | string
    variantId?: StringNullableWithAggregatesFilter<"StockLog"> | string | null
    changeType?: StringWithAggregatesFilter<"StockLog"> | string
    previousQty?: IntWithAggregatesFilter<"StockLog"> | number
    newQty?: IntWithAggregatesFilter<"StockLog"> | number
    changeQty?: IntWithAggregatesFilter<"StockLog"> | number
    reason?: StringNullableWithAggregatesFilter<"StockLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"StockLog"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"StockLog"> | string | null
  }

  export type EmployeeInvitationWhereInput = {
    AND?: EmployeeInvitationWhereInput | EmployeeInvitationWhereInput[]
    OR?: EmployeeInvitationWhereInput[]
    NOT?: EmployeeInvitationWhereInput | EmployeeInvitationWhereInput[]
    id?: StringFilter<"EmployeeInvitation"> | string
    createdAt?: DateTimeFilter<"EmployeeInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeInvitation"> | Date | string
    storeId?: StringFilter<"EmployeeInvitation"> | string
    userId?: StringFilter<"EmployeeInvitation"> | string
    invitedBy?: StringFilter<"EmployeeInvitation"> | string
    role?: StringNullableFilter<"EmployeeInvitation"> | string | null
    customRoleId?: StringNullableFilter<"EmployeeInvitation"> | string | null
    permissions?: StringNullableFilter<"EmployeeInvitation"> | string | null
    token?: StringFilter<"EmployeeInvitation"> | string
    expiresAt?: DateTimeFilter<"EmployeeInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"EmployeeInvitation"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"EmployeeInvitation"> | Date | string | null
    message?: StringNullableFilter<"EmployeeInvitation"> | string | null
    status?: StringFilter<"EmployeeInvitation"> | string
    inviteLinkId?: StringNullableFilter<"EmployeeInvitation"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    inviter?: XOR<UserRelationFilter, UserWhereInput>
    inviteLink?: XOR<InviteLinkNullableRelationFilter, InviteLinkWhereInput> | null
  }

  export type EmployeeInvitationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    role?: SortOrderInput | SortOrder
    customRoleId?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    inviteLinkId?: SortOrderInput | SortOrder
    store?: StoreOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
    inviteLink?: InviteLinkOrderByWithRelationInput
  }

  export type EmployeeInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: EmployeeInvitationWhereInput | EmployeeInvitationWhereInput[]
    OR?: EmployeeInvitationWhereInput[]
    NOT?: EmployeeInvitationWhereInput | EmployeeInvitationWhereInput[]
    createdAt?: DateTimeFilter<"EmployeeInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeInvitation"> | Date | string
    storeId?: StringFilter<"EmployeeInvitation"> | string
    userId?: StringFilter<"EmployeeInvitation"> | string
    invitedBy?: StringFilter<"EmployeeInvitation"> | string
    role?: StringNullableFilter<"EmployeeInvitation"> | string | null
    customRoleId?: StringNullableFilter<"EmployeeInvitation"> | string | null
    permissions?: StringNullableFilter<"EmployeeInvitation"> | string | null
    expiresAt?: DateTimeFilter<"EmployeeInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"EmployeeInvitation"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"EmployeeInvitation"> | Date | string | null
    message?: StringNullableFilter<"EmployeeInvitation"> | string | null
    status?: StringFilter<"EmployeeInvitation"> | string
    inviteLinkId?: StringNullableFilter<"EmployeeInvitation"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    inviter?: XOR<UserRelationFilter, UserWhereInput>
    inviteLink?: XOR<InviteLinkNullableRelationFilter, InviteLinkWhereInput> | null
  }, "id" | "token">

  export type EmployeeInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    role?: SortOrderInput | SortOrder
    customRoleId?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    inviteLinkId?: SortOrderInput | SortOrder
    _count?: EmployeeInvitationCountOrderByAggregateInput
    _max?: EmployeeInvitationMaxOrderByAggregateInput
    _min?: EmployeeInvitationMinOrderByAggregateInput
  }

  export type EmployeeInvitationScalarWhereWithAggregatesInput = {
    AND?: EmployeeInvitationScalarWhereWithAggregatesInput | EmployeeInvitationScalarWhereWithAggregatesInput[]
    OR?: EmployeeInvitationScalarWhereWithAggregatesInput[]
    NOT?: EmployeeInvitationScalarWhereWithAggregatesInput | EmployeeInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeInvitation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeInvitation"> | Date | string
    storeId?: StringWithAggregatesFilter<"EmployeeInvitation"> | string
    userId?: StringWithAggregatesFilter<"EmployeeInvitation"> | string
    invitedBy?: StringWithAggregatesFilter<"EmployeeInvitation"> | string
    role?: StringNullableWithAggregatesFilter<"EmployeeInvitation"> | string | null
    customRoleId?: StringNullableWithAggregatesFilter<"EmployeeInvitation"> | string | null
    permissions?: StringNullableWithAggregatesFilter<"EmployeeInvitation"> | string | null
    token?: StringWithAggregatesFilter<"EmployeeInvitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmployeeInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeInvitation"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeInvitation"> | Date | string | null
    message?: StringNullableWithAggregatesFilter<"EmployeeInvitation"> | string | null
    status?: StringWithAggregatesFilter<"EmployeeInvitation"> | string
    inviteLinkId?: StringNullableWithAggregatesFilter<"EmployeeInvitation"> | string | null
  }

  export type EmployeeActivityWhereInput = {
    AND?: EmployeeActivityWhereInput | EmployeeActivityWhereInput[]
    OR?: EmployeeActivityWhereInput[]
    NOT?: EmployeeActivityWhereInput | EmployeeActivityWhereInput[]
    id?: StringFilter<"EmployeeActivity"> | string
    createdAt?: DateTimeFilter<"EmployeeActivity"> | Date | string
    storeId?: StringFilter<"EmployeeActivity"> | string
    userId?: StringFilter<"EmployeeActivity"> | string
    action?: StringFilter<"EmployeeActivity"> | string
    details?: StringNullableFilter<"EmployeeActivity"> | string | null
    ipAddress?: StringNullableFilter<"EmployeeActivity"> | string | null
    userAgent?: StringNullableFilter<"EmployeeActivity"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EmployeeActivityOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    store?: StoreOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EmployeeActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeActivityWhereInput | EmployeeActivityWhereInput[]
    OR?: EmployeeActivityWhereInput[]
    NOT?: EmployeeActivityWhereInput | EmployeeActivityWhereInput[]
    createdAt?: DateTimeFilter<"EmployeeActivity"> | Date | string
    storeId?: StringFilter<"EmployeeActivity"> | string
    userId?: StringFilter<"EmployeeActivity"> | string
    action?: StringFilter<"EmployeeActivity"> | string
    details?: StringNullableFilter<"EmployeeActivity"> | string | null
    ipAddress?: StringNullableFilter<"EmployeeActivity"> | string | null
    userAgent?: StringNullableFilter<"EmployeeActivity"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type EmployeeActivityOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: EmployeeActivityCountOrderByAggregateInput
    _max?: EmployeeActivityMaxOrderByAggregateInput
    _min?: EmployeeActivityMinOrderByAggregateInput
  }

  export type EmployeeActivityScalarWhereWithAggregatesInput = {
    AND?: EmployeeActivityScalarWhereWithAggregatesInput | EmployeeActivityScalarWhereWithAggregatesInput[]
    OR?: EmployeeActivityScalarWhereWithAggregatesInput[]
    NOT?: EmployeeActivityScalarWhereWithAggregatesInput | EmployeeActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeActivity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeActivity"> | Date | string
    storeId?: StringWithAggregatesFilter<"EmployeeActivity"> | string
    userId?: StringWithAggregatesFilter<"EmployeeActivity"> | string
    action?: StringWithAggregatesFilter<"EmployeeActivity"> | string
    details?: StringNullableWithAggregatesFilter<"EmployeeActivity"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"EmployeeActivity"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"EmployeeActivity"> | string | null
  }

  export type InviteLinkWhereInput = {
    AND?: InviteLinkWhereInput | InviteLinkWhereInput[]
    OR?: InviteLinkWhereInput[]
    NOT?: InviteLinkWhereInput | InviteLinkWhereInput[]
    id?: StringFilter<"InviteLink"> | string
    createdAt?: DateTimeFilter<"InviteLink"> | Date | string
    updatedAt?: DateTimeFilter<"InviteLink"> | Date | string
    storeId?: StringFilter<"InviteLink"> | string
    createdBy?: StringFilter<"InviteLink"> | string
    token?: StringFilter<"InviteLink"> | string
    role?: StringNullableFilter<"InviteLink"> | string | null
    customRoleId?: StringNullableFilter<"InviteLink"> | string | null
    permissions?: StringNullableFilter<"InviteLink"> | string | null
    maxUses?: IntFilter<"InviteLink"> | number
    usedCount?: IntFilter<"InviteLink"> | number
    expiresAt?: DateTimeNullableFilter<"InviteLink"> | Date | string | null
    isActive?: BoolFilter<"InviteLink"> | boolean
    description?: StringNullableFilter<"InviteLink"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    customRole?: XOR<CustomRoleNullableRelationFilter, CustomRoleWhereInput> | null
    invitations?: EmployeeInvitationListRelationFilter
  }

  export type InviteLinkOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    createdBy?: SortOrder
    token?: SortOrder
    role?: SortOrderInput | SortOrder
    customRoleId?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    store?: StoreOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    customRole?: CustomRoleOrderByWithRelationInput
    invitations?: EmployeeInvitationOrderByRelationAggregateInput
  }

  export type InviteLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: InviteLinkWhereInput | InviteLinkWhereInput[]
    OR?: InviteLinkWhereInput[]
    NOT?: InviteLinkWhereInput | InviteLinkWhereInput[]
    createdAt?: DateTimeFilter<"InviteLink"> | Date | string
    updatedAt?: DateTimeFilter<"InviteLink"> | Date | string
    storeId?: StringFilter<"InviteLink"> | string
    createdBy?: StringFilter<"InviteLink"> | string
    role?: StringNullableFilter<"InviteLink"> | string | null
    customRoleId?: StringNullableFilter<"InviteLink"> | string | null
    permissions?: StringNullableFilter<"InviteLink"> | string | null
    maxUses?: IntFilter<"InviteLink"> | number
    usedCount?: IntFilter<"InviteLink"> | number
    expiresAt?: DateTimeNullableFilter<"InviteLink"> | Date | string | null
    isActive?: BoolFilter<"InviteLink"> | boolean
    description?: StringNullableFilter<"InviteLink"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    customRole?: XOR<CustomRoleNullableRelationFilter, CustomRoleWhereInput> | null
    invitations?: EmployeeInvitationListRelationFilter
  }, "id" | "token">

  export type InviteLinkOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    createdBy?: SortOrder
    token?: SortOrder
    role?: SortOrderInput | SortOrder
    customRoleId?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: InviteLinkCountOrderByAggregateInput
    _avg?: InviteLinkAvgOrderByAggregateInput
    _max?: InviteLinkMaxOrderByAggregateInput
    _min?: InviteLinkMinOrderByAggregateInput
    _sum?: InviteLinkSumOrderByAggregateInput
  }

  export type InviteLinkScalarWhereWithAggregatesInput = {
    AND?: InviteLinkScalarWhereWithAggregatesInput | InviteLinkScalarWhereWithAggregatesInput[]
    OR?: InviteLinkScalarWhereWithAggregatesInput[]
    NOT?: InviteLinkScalarWhereWithAggregatesInput | InviteLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InviteLink"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InviteLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InviteLink"> | Date | string
    storeId?: StringWithAggregatesFilter<"InviteLink"> | string
    createdBy?: StringWithAggregatesFilter<"InviteLink"> | string
    token?: StringWithAggregatesFilter<"InviteLink"> | string
    role?: StringNullableWithAggregatesFilter<"InviteLink"> | string | null
    customRoleId?: StringNullableWithAggregatesFilter<"InviteLink"> | string | null
    permissions?: StringNullableWithAggregatesFilter<"InviteLink"> | string | null
    maxUses?: IntWithAggregatesFilter<"InviteLink"> | number
    usedCount?: IntWithAggregatesFilter<"InviteLink"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"InviteLink"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"InviteLink"> | boolean
    description?: StringNullableWithAggregatesFilter<"InviteLink"> | string | null
  }

  export type CustomRoleWhereInput = {
    AND?: CustomRoleWhereInput | CustomRoleWhereInput[]
    OR?: CustomRoleWhereInput[]
    NOT?: CustomRoleWhereInput | CustomRoleWhereInput[]
    id?: StringFilter<"CustomRole"> | string
    createdAt?: DateTimeFilter<"CustomRole"> | Date | string
    updatedAt?: DateTimeFilter<"CustomRole"> | Date | string
    storeId?: StringFilter<"CustomRole"> | string
    name?: StringFilter<"CustomRole"> | string
    description?: StringNullableFilter<"CustomRole"> | string | null
    permissions?: StringFilter<"CustomRole"> | string
    color?: StringFilter<"CustomRole"> | string
    icon?: StringNullableFilter<"CustomRole"> | string | null
    isActive?: BoolFilter<"CustomRole"> | boolean
    createdBy?: StringFilter<"CustomRole"> | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    vendors?: StoreVendorListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
  }

  export type CustomRoleOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    color?: SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    store?: StoreOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    vendors?: StoreVendorOrderByRelationAggregateInput
    inviteLinks?: InviteLinkOrderByRelationAggregateInput
  }

  export type CustomRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_name?: CustomRoleStoreIdNameCompoundUniqueInput
    AND?: CustomRoleWhereInput | CustomRoleWhereInput[]
    OR?: CustomRoleWhereInput[]
    NOT?: CustomRoleWhereInput | CustomRoleWhereInput[]
    createdAt?: DateTimeFilter<"CustomRole"> | Date | string
    updatedAt?: DateTimeFilter<"CustomRole"> | Date | string
    storeId?: StringFilter<"CustomRole"> | string
    name?: StringFilter<"CustomRole"> | string
    description?: StringNullableFilter<"CustomRole"> | string | null
    permissions?: StringFilter<"CustomRole"> | string
    color?: StringFilter<"CustomRole"> | string
    icon?: StringNullableFilter<"CustomRole"> | string | null
    isActive?: BoolFilter<"CustomRole"> | boolean
    createdBy?: StringFilter<"CustomRole"> | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    vendors?: StoreVendorListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
  }, "id" | "storeId_name">

  export type CustomRoleOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    color?: SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    _count?: CustomRoleCountOrderByAggregateInput
    _max?: CustomRoleMaxOrderByAggregateInput
    _min?: CustomRoleMinOrderByAggregateInput
  }

  export type CustomRoleScalarWhereWithAggregatesInput = {
    AND?: CustomRoleScalarWhereWithAggregatesInput | CustomRoleScalarWhereWithAggregatesInput[]
    OR?: CustomRoleScalarWhereWithAggregatesInput[]
    NOT?: CustomRoleScalarWhereWithAggregatesInput | CustomRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomRole"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomRole"> | Date | string
    storeId?: StringWithAggregatesFilter<"CustomRole"> | string
    name?: StringWithAggregatesFilter<"CustomRole"> | string
    description?: StringNullableWithAggregatesFilter<"CustomRole"> | string | null
    permissions?: StringWithAggregatesFilter<"CustomRole"> | string
    color?: StringWithAggregatesFilter<"CustomRole"> | string
    icon?: StringNullableWithAggregatesFilter<"CustomRole"> | string | null
    isActive?: BoolWithAggregatesFilter<"CustomRole"> | boolean
    createdBy?: StringWithAggregatesFilter<"CustomRole"> | string
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type StoreCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
  }

  export type StoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreAdminCreateInput = {
    id?: string
    createdAt?: Date | string
    store: StoreCreateNestedOneWithoutAdminsInput
    user: UserCreateNestedOneWithoutManagedStoresInput
    assignedByUser?: UserCreateNestedOneWithoutAssignedAdminsInput
  }

  export type StoreAdminUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    userId: string
    assignedBy?: string | null
  }

  export type StoreAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutAdminsNestedInput
    user?: UserUpdateOneRequiredWithoutManagedStoresNestedInput
    assignedByUser?: UserUpdateOneWithoutAssignedAdminsNestedInput
  }

  export type StoreAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreAdminCreateManyInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    userId: string
    assignedBy?: string | null
  }

  export type StoreAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
    parentId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
    parentId?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLogs?: StockLogCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    store: StoreCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    storeId: string
    categoryId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    storeId: string
    categoryId?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductVariantCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutVariantInput
    stockLogs?: StockLogCreateNestedManyWithoutVariantInput
    product: ProductCreateNestedOneWithoutVariantsInput
  }

  export type ProductVariantUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
    productId: string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutVariantInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutVariantNestedInput
    stockLogs?: StockLogUpdateManyWithoutVariantNestedInput
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type ProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
    productId: string
  }

  export type ProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    adminLogs?: AdminLogCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    customer: UserCreateNestedOneWithoutOrdersInput
    store: StoreCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    customerId: string
    storeId: string
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    adminLogs?: AdminLogUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    store?: StoreUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    adminLogs?: AdminLogUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    customerId: string
    storeId: string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemCreateInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    variant?: ProductVariantCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    orderId: string
    productId: string
    variantId?: string | null
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    orderId: string
    productId: string
    variantId?: string | null
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminLogCreateInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    admin: UserCreateNestedOneWithoutAdminLogsInput
    order?: OrderCreateNestedOneWithoutAdminLogsInput
  }

  export type AdminLogUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    adminId: string
    orderId?: string | null
  }

  export type AdminLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: UserUpdateOneRequiredWithoutAdminLogsNestedInput
    order?: OrderUpdateOneWithoutAdminLogsNestedInput
  }

  export type AdminLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminLogCreateManyInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    adminId: string
    orderId?: string | null
  }

  export type AdminLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntegrationMappingCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    source: string
    entityType: string
    localId: string
    externalId: string
    store?: StoreCreateNestedOneWithoutIntegrationMappingsInput
  }

  export type IntegrationMappingUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    source: string
    entityType: string
    localId: string
    externalId: string
    storeId?: string | null
  }

  export type IntegrationMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    localId?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    store?: StoreUpdateOneWithoutIntegrationMappingsNestedInput
  }

  export type IntegrationMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    localId?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntegrationMappingCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    source: string
    entityType: string
    localId: string
    externalId: string
    storeId?: string | null
  }

  export type IntegrationMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    localId?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
  }

  export type IntegrationMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    localId?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
    store?: StoreCreateNestedOneWithoutNotificationsInput
    order?: OrderCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    storeId?: string | null
    orderId?: string | null
    userId: string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    store?: StoreUpdateOneWithoutNotificationsNestedInput
    order?: OrderUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    storeId?: string | null
    orderId?: string | null
    userId: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RevokedTokenCreateInput = {
    id?: string
    token: string
    userId: string
    revokedAt?: Date | string
    expiresAt: Date | string
    reason?: string | null
  }

  export type RevokedTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    revokedAt?: Date | string
    expiresAt: Date | string
    reason?: string | null
  }

  export type RevokedTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revokedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevokedTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revokedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevokedTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    revokedAt?: Date | string
    expiresAt: Date | string
    reason?: string | null
  }

  export type RevokedTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revokedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevokedTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revokedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreVendorCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    store: StoreCreateNestedOneWithoutVendorsInput
    user: UserCreateNestedOneWithoutVendorStoresInput
    customRole?: CustomRoleCreateNestedOneWithoutVendorsInput
  }

  export type StoreVendorUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    customRoleId?: string | null
  }

  export type StoreVendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutVendorsNestedInput
    user?: UserUpdateOneRequiredWithoutVendorStoresNestedInput
    customRole?: CustomRoleUpdateOneWithoutVendorsNestedInput
  }

  export type StoreVendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreVendorCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    customRoleId?: string | null
  }

  export type StoreVendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreVendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockLogCreateInput = {
    id?: string
    createdAt?: Date | string
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
    product: ProductCreateNestedOneWithoutStockLogsInput
    store: StoreCreateNestedOneWithoutStockLogsInput
    variant?: ProductVariantCreateNestedOneWithoutStockLogsInput
  }

  export type StockLogUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    productId: string
    storeId: string
    variantId?: string | null
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
  }

  export type StockLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutStockLogsNestedInput
    store?: StoreUpdateOneRequiredWithoutStockLogsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockLogsNestedInput
  }

  export type StockLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockLogCreateManyInput = {
    id?: string
    createdAt?: Date | string
    productId: string
    storeId: string
    variantId?: string | null
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
  }

  export type StockLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeInvitationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    store: StoreCreateNestedOneWithoutEmployeeInvitationsInput
    user: UserCreateNestedOneWithoutReceivedInvitationsInput
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
    inviteLink?: InviteLinkCreateNestedOneWithoutInvitationsInput
  }

  export type EmployeeInvitationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    invitedBy: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    inviteLinkId?: string | null
  }

  export type EmployeeInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    store?: StoreUpdateOneRequiredWithoutEmployeeInvitationsNestedInput
    user?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    inviteLink?: InviteLinkUpdateOneWithoutInvitationsNestedInput
  }

  export type EmployeeInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inviteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeInvitationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    invitedBy: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    inviteLinkId?: string | null
  }

  export type EmployeeInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inviteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeActivityCreateInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    store: StoreCreateNestedOneWithoutEmployeeActivitiesInput
    user: UserCreateNestedOneWithoutEmployeeActivitiesInput
  }

  export type EmployeeActivityUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    userId: string
    action: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type EmployeeActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutEmployeeActivitiesNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeActivitiesNestedInput
  }

  export type EmployeeActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeActivityCreateManyInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    userId: string
    action: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type EmployeeActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteLinkCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    role?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
    store: StoreCreateNestedOneWithoutInviteLinksInput
    creator: UserCreateNestedOneWithoutCreatedInviteLinksInput
    customRole?: CustomRoleCreateNestedOneWithoutInviteLinksInput
    invitations?: EmployeeInvitationCreateNestedManyWithoutInviteLinkInput
  }

  export type InviteLinkUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    createdBy: string
    token: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
    invitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviteLinkInput
  }

  export type InviteLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutInviteLinksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInviteLinksNestedInput
    customRole?: CustomRoleUpdateOneWithoutInviteLinksNestedInput
    invitations?: EmployeeInvitationUpdateManyWithoutInviteLinkNestedInput
  }

  export type InviteLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviteLinkNestedInput
  }

  export type InviteLinkCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    createdBy: string
    token: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
  }

  export type InviteLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomRoleCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    store: StoreCreateNestedOneWithoutCustomRolesInput
    creator: UserCreateNestedOneWithoutCreatedCustomRolesInput
    vendors?: StoreVendorCreateNestedManyWithoutCustomRoleInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    createdBy: string
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutCustomRoleInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    store?: StoreUpdateOneRequiredWithoutCustomRolesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomRolesNestedInput
    vendors?: StoreVendorUpdateManyWithoutCustomRoleNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCustomRoleNestedInput
  }

  export type CustomRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    vendors?: StoreVendorUncheckedUpdateManyWithoutCustomRoleNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCustomRoleNestedInput
  }

  export type CustomRoleCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    createdBy: string
  }

  export type CustomRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AdminLogListRelationFilter = {
    every?: AdminLogWhereInput
    some?: AdminLogWhereInput
    none?: AdminLogWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type StoreAdminListRelationFilter = {
    every?: StoreAdminWhereInput
    some?: StoreAdminWhereInput
    none?: StoreAdminWhereInput
  }

  export type StoreListRelationFilter = {
    every?: StoreWhereInput
    some?: StoreWhereInput
    none?: StoreWhereInput
  }

  export type StoreVendorListRelationFilter = {
    every?: StoreVendorWhereInput
    some?: StoreVendorWhereInput
    none?: StoreVendorWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type EmployeeInvitationListRelationFilter = {
    every?: EmployeeInvitationWhereInput
    some?: EmployeeInvitationWhereInput
    none?: EmployeeInvitationWhereInput
  }

  export type EmployeeActivityListRelationFilter = {
    every?: EmployeeActivityWhereInput
    some?: EmployeeActivityWhereInput
    none?: EmployeeActivityWhereInput
  }

  export type InviteLinkListRelationFilter = {
    every?: InviteLinkWhereInput
    some?: InviteLinkWhereInput
    none?: InviteLinkWhereInput
  }

  export type CustomRoleListRelationFilter = {
    every?: CustomRoleWhereInput
    some?: CustomRoleWhereInput
    none?: CustomRoleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreAdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreVendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    profilePhoto?: SortOrder
    balance?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    profilePhoto?: SortOrder
    balance?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    profilePhoto?: SortOrder
    balance?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntegrationMappingListRelationFilter = {
    every?: IntegrationMappingWhereInput
    some?: IntegrationMappingWhereInput
    none?: IntegrationMappingWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type StockLogListRelationFilter = {
    every?: StockLogWhereInput
    some?: StockLogWhereInput
    none?: StockLogWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type IntegrationMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    domain?: SortOrder
    contactInfo?: SortOrder
    contactPhone?: SortOrder
    settings?: SortOrder
    logoUrl?: SortOrder
    bannerUrl?: SortOrder
    lowStockThreshold?: SortOrder
    criticalStockThreshold?: SortOrder
    enableStockAlerts?: SortOrder
    botToken?: SortOrder
    botUsername?: SortOrder
    botStatus?: SortOrder
    botWebhookUrl?: SortOrder
    botSettings?: SortOrder
    botCreatedAt?: SortOrder
    botLastActive?: SortOrder
    ownerId?: SortOrder
  }

  export type StoreAvgOrderByAggregateInput = {
    lowStockThreshold?: SortOrder
    criticalStockThreshold?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    domain?: SortOrder
    contactInfo?: SortOrder
    contactPhone?: SortOrder
    settings?: SortOrder
    logoUrl?: SortOrder
    bannerUrl?: SortOrder
    lowStockThreshold?: SortOrder
    criticalStockThreshold?: SortOrder
    enableStockAlerts?: SortOrder
    botToken?: SortOrder
    botUsername?: SortOrder
    botStatus?: SortOrder
    botWebhookUrl?: SortOrder
    botSettings?: SortOrder
    botCreatedAt?: SortOrder
    botLastActive?: SortOrder
    ownerId?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    domain?: SortOrder
    contactInfo?: SortOrder
    contactPhone?: SortOrder
    settings?: SortOrder
    logoUrl?: SortOrder
    bannerUrl?: SortOrder
    lowStockThreshold?: SortOrder
    criticalStockThreshold?: SortOrder
    enableStockAlerts?: SortOrder
    botToken?: SortOrder
    botUsername?: SortOrder
    botStatus?: SortOrder
    botWebhookUrl?: SortOrder
    botSettings?: SortOrder
    botCreatedAt?: SortOrder
    botLastActive?: SortOrder
    ownerId?: SortOrder
  }

  export type StoreSumOrderByAggregateInput = {
    lowStockThreshold?: SortOrder
    criticalStockThreshold?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StoreRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StoreAdminStoreIdUserIdCompoundUniqueInput = {
    storeId: string
    userId: string
  }

  export type StoreAdminCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrder
  }

  export type StoreAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrder
  }

  export type StoreAdminMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrder
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type ProductVariantListRelationFilter = {
    every?: ProductVariantWhereInput
    some?: ProductVariantWhereInput
    none?: ProductVariantWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductStoreIdSkuCompoundUniqueInput = {
    storeId: string
    sku: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    trackStock?: SortOrder
    isActive?: SortOrder
    images?: SortOrder
    storeId?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    trackStock?: SortOrder
    isActive?: SortOrder
    images?: SortOrder
    storeId?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    trackStock?: SortOrder
    isActive?: SortOrder
    images?: SortOrder
    storeId?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductVariantProductIdNameValueCompoundUniqueInput = {
    productId: string
    name: string
    value: string
  }

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    value?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    productId?: SortOrder
  }

  export type ProductVariantAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    value?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    productId?: SortOrder
  }

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    value?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    productId?: SortOrder
  }

  export type ProductVariantSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    customerInfo?: SortOrder
    notes?: SortOrder
    paidAt?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    cancelledAt?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    deliveryNotes?: SortOrder
    cancellationReason?: SortOrder
    paymentProof?: SortOrder
    clientRequestId?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    customerInfo?: SortOrder
    notes?: SortOrder
    paidAt?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    cancelledAt?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    deliveryNotes?: SortOrder
    cancellationReason?: SortOrder
    paymentProof?: SortOrder
    clientRequestId?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    customerInfo?: SortOrder
    notes?: SortOrder
    paidAt?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    cancelledAt?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    deliveryNotes?: SortOrder
    cancellationReason?: SortOrder
    paymentProof?: SortOrder
    clientRequestId?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductVariantNullableRelationFilter = {
    is?: ProductVariantWhereInput | null
    isNot?: ProductVariantWhereInput | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type AdminLogCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    details?: SortOrder
    adminId?: SortOrder
    orderId?: SortOrder
  }

  export type AdminLogMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    details?: SortOrder
    adminId?: SortOrder
    orderId?: SortOrder
  }

  export type AdminLogMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    details?: SortOrder
    adminId?: SortOrder
    orderId?: SortOrder
  }

  export type StoreNullableRelationFilter = {
    is?: StoreWhereInput | null
    isNot?: StoreWhereInput | null
  }

  export type IntegrationMappingSourceEntityTypeExternalIdCompoundUniqueInput = {
    source: string
    entityType: string
    externalId: string
  }

  export type IntegrationMappingSourceEntityTypeLocalIdCompoundUniqueInput = {
    source: string
    entityType: string
    localId: string
  }

  export type IntegrationMappingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    entityType?: SortOrder
    localId?: SortOrder
    externalId?: SortOrder
    storeId?: SortOrder
  }

  export type IntegrationMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    entityType?: SortOrder
    localId?: SortOrder
    externalId?: SortOrder
    storeId?: SortOrder
  }

  export type IntegrationMappingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    entityType?: SortOrder
    localId?: SortOrder
    externalId?: SortOrder
    storeId?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channels?: SortOrder
    data?: SortOrder
    readAt?: SortOrder
    storeId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channels?: SortOrder
    data?: SortOrder
    readAt?: SortOrder
    storeId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channels?: SortOrder
    data?: SortOrder
    readAt?: SortOrder
    storeId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
  }

  export type RevokedTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    reason?: SortOrder
  }

  export type RevokedTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    reason?: SortOrder
  }

  export type RevokedTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    reason?: SortOrder
  }

  export type CustomRoleNullableRelationFilter = {
    is?: CustomRoleWhereInput | null
    isNot?: CustomRoleWhereInput | null
  }

  export type StoreVendorStoreIdUserIdCompoundUniqueInput = {
    storeId: string
    userId: string
  }

  export type StoreVendorCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    customRoleId?: SortOrder
  }

  export type StoreVendorMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    customRoleId?: SortOrder
  }

  export type StoreVendorMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    assignedBy?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    customRoleId?: SortOrder
  }

  export type StockLogCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    variantId?: SortOrder
    changeType?: SortOrder
    previousQty?: SortOrder
    newQty?: SortOrder
    changeQty?: SortOrder
    reason?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type StockLogAvgOrderByAggregateInput = {
    previousQty?: SortOrder
    newQty?: SortOrder
    changeQty?: SortOrder
  }

  export type StockLogMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    variantId?: SortOrder
    changeType?: SortOrder
    previousQty?: SortOrder
    newQty?: SortOrder
    changeQty?: SortOrder
    reason?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type StockLogMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    variantId?: SortOrder
    changeType?: SortOrder
    previousQty?: SortOrder
    newQty?: SortOrder
    changeQty?: SortOrder
    reason?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type StockLogSumOrderByAggregateInput = {
    previousQty?: SortOrder
    newQty?: SortOrder
    changeQty?: SortOrder
  }

  export type InviteLinkNullableRelationFilter = {
    is?: InviteLinkWhereInput | null
    isNot?: InviteLinkWhereInput | null
  }

  export type EmployeeInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    role?: SortOrder
    customRoleId?: SortOrder
    permissions?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    rejectedAt?: SortOrder
    message?: SortOrder
    status?: SortOrder
    inviteLinkId?: SortOrder
  }

  export type EmployeeInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    role?: SortOrder
    customRoleId?: SortOrder
    permissions?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    rejectedAt?: SortOrder
    message?: SortOrder
    status?: SortOrder
    inviteLinkId?: SortOrder
  }

  export type EmployeeInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    role?: SortOrder
    customRoleId?: SortOrder
    permissions?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    rejectedAt?: SortOrder
    message?: SortOrder
    status?: SortOrder
    inviteLinkId?: SortOrder
  }

  export type EmployeeActivityCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type EmployeeActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type EmployeeActivityMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type InviteLinkCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    createdBy?: SortOrder
    token?: SortOrder
    role?: SortOrder
    customRoleId?: SortOrder
    permissions?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type InviteLinkAvgOrderByAggregateInput = {
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type InviteLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    createdBy?: SortOrder
    token?: SortOrder
    role?: SortOrder
    customRoleId?: SortOrder
    permissions?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type InviteLinkMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    createdBy?: SortOrder
    token?: SortOrder
    role?: SortOrder
    customRoleId?: SortOrder
    permissions?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type InviteLinkSumOrderByAggregateInput = {
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type CustomRoleStoreIdNameCompoundUniqueInput = {
    storeId: string
    name: string
  }

  export type CustomRoleCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
  }

  export type CustomRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
  }

  export type CustomRoleMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
  }

  export type AdminLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput> | AdminLogCreateWithoutAdminInput[] | AdminLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutAdminInput | AdminLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminLogCreateManyAdminInputEnvelope
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type StoreAdminCreateNestedManyWithoutUserInput = {
    create?: XOR<StoreAdminCreateWithoutUserInput, StoreAdminUncheckedCreateWithoutUserInput> | StoreAdminCreateWithoutUserInput[] | StoreAdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutUserInput | StoreAdminCreateOrConnectWithoutUserInput[]
    createMany?: StoreAdminCreateManyUserInputEnvelope
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
  }

  export type StoreAdminCreateNestedManyWithoutAssignedByUserInput = {
    create?: XOR<StoreAdminCreateWithoutAssignedByUserInput, StoreAdminUncheckedCreateWithoutAssignedByUserInput> | StoreAdminCreateWithoutAssignedByUserInput[] | StoreAdminUncheckedCreateWithoutAssignedByUserInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutAssignedByUserInput | StoreAdminCreateOrConnectWithoutAssignedByUserInput[]
    createMany?: StoreAdminCreateManyAssignedByUserInputEnvelope
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
  }

  export type StoreCreateNestedManyWithoutOwnerInput = {
    create?: XOR<StoreCreateWithoutOwnerInput, StoreUncheckedCreateWithoutOwnerInput> | StoreCreateWithoutOwnerInput[] | StoreUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutOwnerInput | StoreCreateOrConnectWithoutOwnerInput[]
    createMany?: StoreCreateManyOwnerInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type StoreVendorCreateNestedManyWithoutUserInput = {
    create?: XOR<StoreVendorCreateWithoutUserInput, StoreVendorUncheckedCreateWithoutUserInput> | StoreVendorCreateWithoutUserInput[] | StoreVendorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutUserInput | StoreVendorCreateOrConnectWithoutUserInput[]
    createMany?: StoreVendorCreateManyUserInputEnvelope
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EmployeeInvitationCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeInvitationCreateWithoutUserInput, EmployeeInvitationUncheckedCreateWithoutUserInput> | EmployeeInvitationCreateWithoutUserInput[] | EmployeeInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutUserInput | EmployeeInvitationCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeInvitationCreateManyUserInputEnvelope
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
  }

  export type EmployeeInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<EmployeeInvitationCreateWithoutInviterInput, EmployeeInvitationUncheckedCreateWithoutInviterInput> | EmployeeInvitationCreateWithoutInviterInput[] | EmployeeInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutInviterInput | EmployeeInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: EmployeeInvitationCreateManyInviterInputEnvelope
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
  }

  export type EmployeeActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeActivityCreateWithoutUserInput, EmployeeActivityUncheckedCreateWithoutUserInput> | EmployeeActivityCreateWithoutUserInput[] | EmployeeActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeActivityCreateOrConnectWithoutUserInput | EmployeeActivityCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeActivityCreateManyUserInputEnvelope
    connect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
  }

  export type InviteLinkCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InviteLinkCreateWithoutCreatorInput, InviteLinkUncheckedCreateWithoutCreatorInput> | InviteLinkCreateWithoutCreatorInput[] | InviteLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCreatorInput | InviteLinkCreateOrConnectWithoutCreatorInput[]
    createMany?: InviteLinkCreateManyCreatorInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type CustomRoleCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CustomRoleCreateWithoutCreatorInput, CustomRoleUncheckedCreateWithoutCreatorInput> | CustomRoleCreateWithoutCreatorInput[] | CustomRoleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomRoleCreateOrConnectWithoutCreatorInput | CustomRoleCreateOrConnectWithoutCreatorInput[]
    createMany?: CustomRoleCreateManyCreatorInputEnvelope
    connect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
  }

  export type AdminLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput> | AdminLogCreateWithoutAdminInput[] | AdminLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutAdminInput | AdminLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminLogCreateManyAdminInputEnvelope
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type StoreAdminUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StoreAdminCreateWithoutUserInput, StoreAdminUncheckedCreateWithoutUserInput> | StoreAdminCreateWithoutUserInput[] | StoreAdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutUserInput | StoreAdminCreateOrConnectWithoutUserInput[]
    createMany?: StoreAdminCreateManyUserInputEnvelope
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
  }

  export type StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput = {
    create?: XOR<StoreAdminCreateWithoutAssignedByUserInput, StoreAdminUncheckedCreateWithoutAssignedByUserInput> | StoreAdminCreateWithoutAssignedByUserInput[] | StoreAdminUncheckedCreateWithoutAssignedByUserInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutAssignedByUserInput | StoreAdminCreateOrConnectWithoutAssignedByUserInput[]
    createMany?: StoreAdminCreateManyAssignedByUserInputEnvelope
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
  }

  export type StoreUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<StoreCreateWithoutOwnerInput, StoreUncheckedCreateWithoutOwnerInput> | StoreCreateWithoutOwnerInput[] | StoreUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutOwnerInput | StoreCreateOrConnectWithoutOwnerInput[]
    createMany?: StoreCreateManyOwnerInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type StoreVendorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StoreVendorCreateWithoutUserInput, StoreVendorUncheckedCreateWithoutUserInput> | StoreVendorCreateWithoutUserInput[] | StoreVendorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutUserInput | StoreVendorCreateOrConnectWithoutUserInput[]
    createMany?: StoreVendorCreateManyUserInputEnvelope
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeInvitationCreateWithoutUserInput, EmployeeInvitationUncheckedCreateWithoutUserInput> | EmployeeInvitationCreateWithoutUserInput[] | EmployeeInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutUserInput | EmployeeInvitationCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeInvitationCreateManyUserInputEnvelope
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
  }

  export type EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<EmployeeInvitationCreateWithoutInviterInput, EmployeeInvitationUncheckedCreateWithoutInviterInput> | EmployeeInvitationCreateWithoutInviterInput[] | EmployeeInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutInviterInput | EmployeeInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: EmployeeInvitationCreateManyInviterInputEnvelope
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
  }

  export type EmployeeActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeActivityCreateWithoutUserInput, EmployeeActivityUncheckedCreateWithoutUserInput> | EmployeeActivityCreateWithoutUserInput[] | EmployeeActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeActivityCreateOrConnectWithoutUserInput | EmployeeActivityCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeActivityCreateManyUserInputEnvelope
    connect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
  }

  export type InviteLinkUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InviteLinkCreateWithoutCreatorInput, InviteLinkUncheckedCreateWithoutCreatorInput> | InviteLinkCreateWithoutCreatorInput[] | InviteLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCreatorInput | InviteLinkCreateOrConnectWithoutCreatorInput[]
    createMany?: InviteLinkCreateManyCreatorInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type CustomRoleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CustomRoleCreateWithoutCreatorInput, CustomRoleUncheckedCreateWithoutCreatorInput> | CustomRoleCreateWithoutCreatorInput[] | CustomRoleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomRoleCreateOrConnectWithoutCreatorInput | CustomRoleCreateOrConnectWithoutCreatorInput[]
    createMany?: CustomRoleCreateManyCreatorInputEnvelope
    connect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput> | AdminLogCreateWithoutAdminInput[] | AdminLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutAdminInput | AdminLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminLogUpsertWithWhereUniqueWithoutAdminInput | AdminLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminLogCreateManyAdminInputEnvelope
    set?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    disconnect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    delete?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    update?: AdminLogUpdateWithWhereUniqueWithoutAdminInput | AdminLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminLogUpdateManyWithWhereWithoutAdminInput | AdminLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type StoreAdminUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoreAdminCreateWithoutUserInput, StoreAdminUncheckedCreateWithoutUserInput> | StoreAdminCreateWithoutUserInput[] | StoreAdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutUserInput | StoreAdminCreateOrConnectWithoutUserInput[]
    upsert?: StoreAdminUpsertWithWhereUniqueWithoutUserInput | StoreAdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoreAdminCreateManyUserInputEnvelope
    set?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    disconnect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    delete?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    update?: StoreAdminUpdateWithWhereUniqueWithoutUserInput | StoreAdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoreAdminUpdateManyWithWhereWithoutUserInput | StoreAdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoreAdminScalarWhereInput | StoreAdminScalarWhereInput[]
  }

  export type StoreAdminUpdateManyWithoutAssignedByUserNestedInput = {
    create?: XOR<StoreAdminCreateWithoutAssignedByUserInput, StoreAdminUncheckedCreateWithoutAssignedByUserInput> | StoreAdminCreateWithoutAssignedByUserInput[] | StoreAdminUncheckedCreateWithoutAssignedByUserInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutAssignedByUserInput | StoreAdminCreateOrConnectWithoutAssignedByUserInput[]
    upsert?: StoreAdminUpsertWithWhereUniqueWithoutAssignedByUserInput | StoreAdminUpsertWithWhereUniqueWithoutAssignedByUserInput[]
    createMany?: StoreAdminCreateManyAssignedByUserInputEnvelope
    set?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    disconnect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    delete?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    update?: StoreAdminUpdateWithWhereUniqueWithoutAssignedByUserInput | StoreAdminUpdateWithWhereUniqueWithoutAssignedByUserInput[]
    updateMany?: StoreAdminUpdateManyWithWhereWithoutAssignedByUserInput | StoreAdminUpdateManyWithWhereWithoutAssignedByUserInput[]
    deleteMany?: StoreAdminScalarWhereInput | StoreAdminScalarWhereInput[]
  }

  export type StoreUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<StoreCreateWithoutOwnerInput, StoreUncheckedCreateWithoutOwnerInput> | StoreCreateWithoutOwnerInput[] | StoreUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutOwnerInput | StoreCreateOrConnectWithoutOwnerInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutOwnerInput | StoreUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: StoreCreateManyOwnerInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutOwnerInput | StoreUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutOwnerInput | StoreUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type StoreVendorUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoreVendorCreateWithoutUserInput, StoreVendorUncheckedCreateWithoutUserInput> | StoreVendorCreateWithoutUserInput[] | StoreVendorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutUserInput | StoreVendorCreateOrConnectWithoutUserInput[]
    upsert?: StoreVendorUpsertWithWhereUniqueWithoutUserInput | StoreVendorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoreVendorCreateManyUserInputEnvelope
    set?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    disconnect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    delete?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    update?: StoreVendorUpdateWithWhereUniqueWithoutUserInput | StoreVendorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoreVendorUpdateManyWithWhereWithoutUserInput | StoreVendorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoreVendorScalarWhereInput | StoreVendorScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EmployeeInvitationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeInvitationCreateWithoutUserInput, EmployeeInvitationUncheckedCreateWithoutUserInput> | EmployeeInvitationCreateWithoutUserInput[] | EmployeeInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutUserInput | EmployeeInvitationCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeInvitationUpsertWithWhereUniqueWithoutUserInput | EmployeeInvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeInvitationCreateManyUserInputEnvelope
    set?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    disconnect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    delete?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    update?: EmployeeInvitationUpdateWithWhereUniqueWithoutUserInput | EmployeeInvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeInvitationUpdateManyWithWhereWithoutUserInput | EmployeeInvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
  }

  export type EmployeeInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<EmployeeInvitationCreateWithoutInviterInput, EmployeeInvitationUncheckedCreateWithoutInviterInput> | EmployeeInvitationCreateWithoutInviterInput[] | EmployeeInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutInviterInput | EmployeeInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: EmployeeInvitationUpsertWithWhereUniqueWithoutInviterInput | EmployeeInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: EmployeeInvitationCreateManyInviterInputEnvelope
    set?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    disconnect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    delete?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    update?: EmployeeInvitationUpdateWithWhereUniqueWithoutInviterInput | EmployeeInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: EmployeeInvitationUpdateManyWithWhereWithoutInviterInput | EmployeeInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
  }

  export type EmployeeActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeActivityCreateWithoutUserInput, EmployeeActivityUncheckedCreateWithoutUserInput> | EmployeeActivityCreateWithoutUserInput[] | EmployeeActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeActivityCreateOrConnectWithoutUserInput | EmployeeActivityCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeActivityUpsertWithWhereUniqueWithoutUserInput | EmployeeActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeActivityCreateManyUserInputEnvelope
    set?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    disconnect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    delete?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    connect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    update?: EmployeeActivityUpdateWithWhereUniqueWithoutUserInput | EmployeeActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeActivityUpdateManyWithWhereWithoutUserInput | EmployeeActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeActivityScalarWhereInput | EmployeeActivityScalarWhereInput[]
  }

  export type InviteLinkUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InviteLinkCreateWithoutCreatorInput, InviteLinkUncheckedCreateWithoutCreatorInput> | InviteLinkCreateWithoutCreatorInput[] | InviteLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCreatorInput | InviteLinkCreateOrConnectWithoutCreatorInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutCreatorInput | InviteLinkUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InviteLinkCreateManyCreatorInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutCreatorInput | InviteLinkUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutCreatorInput | InviteLinkUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type CustomRoleUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CustomRoleCreateWithoutCreatorInput, CustomRoleUncheckedCreateWithoutCreatorInput> | CustomRoleCreateWithoutCreatorInput[] | CustomRoleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomRoleCreateOrConnectWithoutCreatorInput | CustomRoleCreateOrConnectWithoutCreatorInput[]
    upsert?: CustomRoleUpsertWithWhereUniqueWithoutCreatorInput | CustomRoleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CustomRoleCreateManyCreatorInputEnvelope
    set?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    disconnect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    delete?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    connect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    update?: CustomRoleUpdateWithWhereUniqueWithoutCreatorInput | CustomRoleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CustomRoleUpdateManyWithWhereWithoutCreatorInput | CustomRoleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CustomRoleScalarWhereInput | CustomRoleScalarWhereInput[]
  }

  export type AdminLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput> | AdminLogCreateWithoutAdminInput[] | AdminLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutAdminInput | AdminLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminLogUpsertWithWhereUniqueWithoutAdminInput | AdminLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminLogCreateManyAdminInputEnvelope
    set?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    disconnect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    delete?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    update?: AdminLogUpdateWithWhereUniqueWithoutAdminInput | AdminLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminLogUpdateManyWithWhereWithoutAdminInput | AdminLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type StoreAdminUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoreAdminCreateWithoutUserInput, StoreAdminUncheckedCreateWithoutUserInput> | StoreAdminCreateWithoutUserInput[] | StoreAdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutUserInput | StoreAdminCreateOrConnectWithoutUserInput[]
    upsert?: StoreAdminUpsertWithWhereUniqueWithoutUserInput | StoreAdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoreAdminCreateManyUserInputEnvelope
    set?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    disconnect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    delete?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    update?: StoreAdminUpdateWithWhereUniqueWithoutUserInput | StoreAdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoreAdminUpdateManyWithWhereWithoutUserInput | StoreAdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoreAdminScalarWhereInput | StoreAdminScalarWhereInput[]
  }

  export type StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput = {
    create?: XOR<StoreAdminCreateWithoutAssignedByUserInput, StoreAdminUncheckedCreateWithoutAssignedByUserInput> | StoreAdminCreateWithoutAssignedByUserInput[] | StoreAdminUncheckedCreateWithoutAssignedByUserInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutAssignedByUserInput | StoreAdminCreateOrConnectWithoutAssignedByUserInput[]
    upsert?: StoreAdminUpsertWithWhereUniqueWithoutAssignedByUserInput | StoreAdminUpsertWithWhereUniqueWithoutAssignedByUserInput[]
    createMany?: StoreAdminCreateManyAssignedByUserInputEnvelope
    set?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    disconnect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    delete?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    update?: StoreAdminUpdateWithWhereUniqueWithoutAssignedByUserInput | StoreAdminUpdateWithWhereUniqueWithoutAssignedByUserInput[]
    updateMany?: StoreAdminUpdateManyWithWhereWithoutAssignedByUserInput | StoreAdminUpdateManyWithWhereWithoutAssignedByUserInput[]
    deleteMany?: StoreAdminScalarWhereInput | StoreAdminScalarWhereInput[]
  }

  export type StoreUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<StoreCreateWithoutOwnerInput, StoreUncheckedCreateWithoutOwnerInput> | StoreCreateWithoutOwnerInput[] | StoreUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutOwnerInput | StoreCreateOrConnectWithoutOwnerInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutOwnerInput | StoreUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: StoreCreateManyOwnerInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutOwnerInput | StoreUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutOwnerInput | StoreUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type StoreVendorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoreVendorCreateWithoutUserInput, StoreVendorUncheckedCreateWithoutUserInput> | StoreVendorCreateWithoutUserInput[] | StoreVendorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutUserInput | StoreVendorCreateOrConnectWithoutUserInput[]
    upsert?: StoreVendorUpsertWithWhereUniqueWithoutUserInput | StoreVendorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoreVendorCreateManyUserInputEnvelope
    set?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    disconnect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    delete?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    update?: StoreVendorUpdateWithWhereUniqueWithoutUserInput | StoreVendorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoreVendorUpdateManyWithWhereWithoutUserInput | StoreVendorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoreVendorScalarWhereInput | StoreVendorScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeInvitationCreateWithoutUserInput, EmployeeInvitationUncheckedCreateWithoutUserInput> | EmployeeInvitationCreateWithoutUserInput[] | EmployeeInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutUserInput | EmployeeInvitationCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeInvitationUpsertWithWhereUniqueWithoutUserInput | EmployeeInvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeInvitationCreateManyUserInputEnvelope
    set?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    disconnect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    delete?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    update?: EmployeeInvitationUpdateWithWhereUniqueWithoutUserInput | EmployeeInvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeInvitationUpdateManyWithWhereWithoutUserInput | EmployeeInvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
  }

  export type EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<EmployeeInvitationCreateWithoutInviterInput, EmployeeInvitationUncheckedCreateWithoutInviterInput> | EmployeeInvitationCreateWithoutInviterInput[] | EmployeeInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutInviterInput | EmployeeInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: EmployeeInvitationUpsertWithWhereUniqueWithoutInviterInput | EmployeeInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: EmployeeInvitationCreateManyInviterInputEnvelope
    set?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    disconnect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    delete?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    update?: EmployeeInvitationUpdateWithWhereUniqueWithoutInviterInput | EmployeeInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: EmployeeInvitationUpdateManyWithWhereWithoutInviterInput | EmployeeInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
  }

  export type EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeActivityCreateWithoutUserInput, EmployeeActivityUncheckedCreateWithoutUserInput> | EmployeeActivityCreateWithoutUserInput[] | EmployeeActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeActivityCreateOrConnectWithoutUserInput | EmployeeActivityCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeActivityUpsertWithWhereUniqueWithoutUserInput | EmployeeActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeActivityCreateManyUserInputEnvelope
    set?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    disconnect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    delete?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    connect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    update?: EmployeeActivityUpdateWithWhereUniqueWithoutUserInput | EmployeeActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeActivityUpdateManyWithWhereWithoutUserInput | EmployeeActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeActivityScalarWhereInput | EmployeeActivityScalarWhereInput[]
  }

  export type InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InviteLinkCreateWithoutCreatorInput, InviteLinkUncheckedCreateWithoutCreatorInput> | InviteLinkCreateWithoutCreatorInput[] | InviteLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCreatorInput | InviteLinkCreateOrConnectWithoutCreatorInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutCreatorInput | InviteLinkUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InviteLinkCreateManyCreatorInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutCreatorInput | InviteLinkUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutCreatorInput | InviteLinkUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CustomRoleCreateWithoutCreatorInput, CustomRoleUncheckedCreateWithoutCreatorInput> | CustomRoleCreateWithoutCreatorInput[] | CustomRoleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomRoleCreateOrConnectWithoutCreatorInput | CustomRoleCreateOrConnectWithoutCreatorInput[]
    upsert?: CustomRoleUpsertWithWhereUniqueWithoutCreatorInput | CustomRoleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CustomRoleCreateManyCreatorInputEnvelope
    set?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    disconnect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    delete?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    connect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    update?: CustomRoleUpdateWithWhereUniqueWithoutCreatorInput | CustomRoleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CustomRoleUpdateManyWithWhereWithoutCreatorInput | CustomRoleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CustomRoleScalarWhereInput | CustomRoleScalarWhereInput[]
  }

  export type IntegrationMappingCreateNestedManyWithoutStoreInput = {
    create?: XOR<IntegrationMappingCreateWithoutStoreInput, IntegrationMappingUncheckedCreateWithoutStoreInput> | IntegrationMappingCreateWithoutStoreInput[] | IntegrationMappingUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: IntegrationMappingCreateOrConnectWithoutStoreInput | IntegrationMappingCreateOrConnectWithoutStoreInput[]
    createMany?: IntegrationMappingCreateManyStoreInputEnvelope
    connect?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutStoreInput = {
    create?: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput> | OrderCreateWithoutStoreInput[] | OrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreInput | OrderCreateOrConnectWithoutStoreInput[]
    createMany?: OrderCreateManyStoreInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput> | ProductCreateWithoutStoreInput[] | ProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStoreInput | ProductCreateOrConnectWithoutStoreInput[]
    createMany?: ProductCreateManyStoreInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type StoreAdminCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreAdminCreateWithoutStoreInput, StoreAdminUncheckedCreateWithoutStoreInput> | StoreAdminCreateWithoutStoreInput[] | StoreAdminUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutStoreInput | StoreAdminCreateOrConnectWithoutStoreInput[]
    createMany?: StoreAdminCreateManyStoreInputEnvelope
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
  }

  export type StoreVendorCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreVendorCreateWithoutStoreInput, StoreVendorUncheckedCreateWithoutStoreInput> | StoreVendorCreateWithoutStoreInput[] | StoreVendorUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutStoreInput | StoreVendorCreateOrConnectWithoutStoreInput[]
    createMany?: StoreVendorCreateManyStoreInputEnvelope
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
  }

  export type StockLogCreateNestedManyWithoutStoreInput = {
    create?: XOR<StockLogCreateWithoutStoreInput, StockLogUncheckedCreateWithoutStoreInput> | StockLogCreateWithoutStoreInput[] | StockLogUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutStoreInput | StockLogCreateOrConnectWithoutStoreInput[]
    createMany?: StockLogCreateManyStoreInputEnvelope
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutStoreInput = {
    create?: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput> | NotificationCreateWithoutStoreInput[] | NotificationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoreInput | NotificationCreateOrConnectWithoutStoreInput[]
    createMany?: NotificationCreateManyStoreInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EmployeeInvitationCreateNestedManyWithoutStoreInput = {
    create?: XOR<EmployeeInvitationCreateWithoutStoreInput, EmployeeInvitationUncheckedCreateWithoutStoreInput> | EmployeeInvitationCreateWithoutStoreInput[] | EmployeeInvitationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutStoreInput | EmployeeInvitationCreateOrConnectWithoutStoreInput[]
    createMany?: EmployeeInvitationCreateManyStoreInputEnvelope
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
  }

  export type EmployeeActivityCreateNestedManyWithoutStoreInput = {
    create?: XOR<EmployeeActivityCreateWithoutStoreInput, EmployeeActivityUncheckedCreateWithoutStoreInput> | EmployeeActivityCreateWithoutStoreInput[] | EmployeeActivityUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: EmployeeActivityCreateOrConnectWithoutStoreInput | EmployeeActivityCreateOrConnectWithoutStoreInput[]
    createMany?: EmployeeActivityCreateManyStoreInputEnvelope
    connect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
  }

  export type InviteLinkCreateNestedManyWithoutStoreInput = {
    create?: XOR<InviteLinkCreateWithoutStoreInput, InviteLinkUncheckedCreateWithoutStoreInput> | InviteLinkCreateWithoutStoreInput[] | InviteLinkUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutStoreInput | InviteLinkCreateOrConnectWithoutStoreInput[]
    createMany?: InviteLinkCreateManyStoreInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type CustomRoleCreateNestedManyWithoutStoreInput = {
    create?: XOR<CustomRoleCreateWithoutStoreInput, CustomRoleUncheckedCreateWithoutStoreInput> | CustomRoleCreateWithoutStoreInput[] | CustomRoleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomRoleCreateOrConnectWithoutStoreInput | CustomRoleCreateOrConnectWithoutStoreInput[]
    createMany?: CustomRoleCreateManyStoreInputEnvelope
    connect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOwnedStoresInput = {
    create?: XOR<UserCreateWithoutOwnedStoresInput, UserUncheckedCreateWithoutOwnedStoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedStoresInput
    connect?: UserWhereUniqueInput
  }

  export type IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<IntegrationMappingCreateWithoutStoreInput, IntegrationMappingUncheckedCreateWithoutStoreInput> | IntegrationMappingCreateWithoutStoreInput[] | IntegrationMappingUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: IntegrationMappingCreateOrConnectWithoutStoreInput | IntegrationMappingCreateOrConnectWithoutStoreInput[]
    createMany?: IntegrationMappingCreateManyStoreInputEnvelope
    connect?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput> | OrderCreateWithoutStoreInput[] | OrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreInput | OrderCreateOrConnectWithoutStoreInput[]
    createMany?: OrderCreateManyStoreInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput> | ProductCreateWithoutStoreInput[] | ProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStoreInput | ProductCreateOrConnectWithoutStoreInput[]
    createMany?: ProductCreateManyStoreInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type StoreAdminUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreAdminCreateWithoutStoreInput, StoreAdminUncheckedCreateWithoutStoreInput> | StoreAdminCreateWithoutStoreInput[] | StoreAdminUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutStoreInput | StoreAdminCreateOrConnectWithoutStoreInput[]
    createMany?: StoreAdminCreateManyStoreInputEnvelope
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
  }

  export type StoreVendorUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreVendorCreateWithoutStoreInput, StoreVendorUncheckedCreateWithoutStoreInput> | StoreVendorCreateWithoutStoreInput[] | StoreVendorUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutStoreInput | StoreVendorCreateOrConnectWithoutStoreInput[]
    createMany?: StoreVendorCreateManyStoreInputEnvelope
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
  }

  export type StockLogUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StockLogCreateWithoutStoreInput, StockLogUncheckedCreateWithoutStoreInput> | StockLogCreateWithoutStoreInput[] | StockLogUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutStoreInput | StockLogCreateOrConnectWithoutStoreInput[]
    createMany?: StockLogCreateManyStoreInputEnvelope
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput> | NotificationCreateWithoutStoreInput[] | NotificationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoreInput | NotificationCreateOrConnectWithoutStoreInput[]
    createMany?: NotificationCreateManyStoreInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<EmployeeInvitationCreateWithoutStoreInput, EmployeeInvitationUncheckedCreateWithoutStoreInput> | EmployeeInvitationCreateWithoutStoreInput[] | EmployeeInvitationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutStoreInput | EmployeeInvitationCreateOrConnectWithoutStoreInput[]
    createMany?: EmployeeInvitationCreateManyStoreInputEnvelope
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
  }

  export type EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<EmployeeActivityCreateWithoutStoreInput, EmployeeActivityUncheckedCreateWithoutStoreInput> | EmployeeActivityCreateWithoutStoreInput[] | EmployeeActivityUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: EmployeeActivityCreateOrConnectWithoutStoreInput | EmployeeActivityCreateOrConnectWithoutStoreInput[]
    createMany?: EmployeeActivityCreateManyStoreInputEnvelope
    connect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
  }

  export type InviteLinkUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<InviteLinkCreateWithoutStoreInput, InviteLinkUncheckedCreateWithoutStoreInput> | InviteLinkCreateWithoutStoreInput[] | InviteLinkUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutStoreInput | InviteLinkCreateOrConnectWithoutStoreInput[]
    createMany?: InviteLinkCreateManyStoreInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type CustomRoleUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<CustomRoleCreateWithoutStoreInput, CustomRoleUncheckedCreateWithoutStoreInput> | CustomRoleCreateWithoutStoreInput[] | CustomRoleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomRoleCreateOrConnectWithoutStoreInput | CustomRoleCreateOrConnectWithoutStoreInput[]
    createMany?: CustomRoleCreateManyStoreInputEnvelope
    connect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntegrationMappingUpdateManyWithoutStoreNestedInput = {
    create?: XOR<IntegrationMappingCreateWithoutStoreInput, IntegrationMappingUncheckedCreateWithoutStoreInput> | IntegrationMappingCreateWithoutStoreInput[] | IntegrationMappingUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: IntegrationMappingCreateOrConnectWithoutStoreInput | IntegrationMappingCreateOrConnectWithoutStoreInput[]
    upsert?: IntegrationMappingUpsertWithWhereUniqueWithoutStoreInput | IntegrationMappingUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: IntegrationMappingCreateManyStoreInputEnvelope
    set?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
    disconnect?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
    delete?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
    connect?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
    update?: IntegrationMappingUpdateWithWhereUniqueWithoutStoreInput | IntegrationMappingUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: IntegrationMappingUpdateManyWithWhereWithoutStoreInput | IntegrationMappingUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: IntegrationMappingScalarWhereInput | IntegrationMappingScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutStoreNestedInput = {
    create?: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput> | OrderCreateWithoutStoreInput[] | OrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreInput | OrderCreateOrConnectWithoutStoreInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStoreInput | OrderUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: OrderCreateManyStoreInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStoreInput | OrderUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStoreInput | OrderUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput> | ProductCreateWithoutStoreInput[] | ProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStoreInput | ProductCreateOrConnectWithoutStoreInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutStoreInput | ProductUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductCreateManyStoreInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutStoreInput | ProductUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutStoreInput | ProductUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type StoreAdminUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreAdminCreateWithoutStoreInput, StoreAdminUncheckedCreateWithoutStoreInput> | StoreAdminCreateWithoutStoreInput[] | StoreAdminUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutStoreInput | StoreAdminCreateOrConnectWithoutStoreInput[]
    upsert?: StoreAdminUpsertWithWhereUniqueWithoutStoreInput | StoreAdminUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreAdminCreateManyStoreInputEnvelope
    set?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    disconnect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    delete?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    update?: StoreAdminUpdateWithWhereUniqueWithoutStoreInput | StoreAdminUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreAdminUpdateManyWithWhereWithoutStoreInput | StoreAdminUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreAdminScalarWhereInput | StoreAdminScalarWhereInput[]
  }

  export type StoreVendorUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreVendorCreateWithoutStoreInput, StoreVendorUncheckedCreateWithoutStoreInput> | StoreVendorCreateWithoutStoreInput[] | StoreVendorUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutStoreInput | StoreVendorCreateOrConnectWithoutStoreInput[]
    upsert?: StoreVendorUpsertWithWhereUniqueWithoutStoreInput | StoreVendorUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreVendorCreateManyStoreInputEnvelope
    set?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    disconnect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    delete?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    update?: StoreVendorUpdateWithWhereUniqueWithoutStoreInput | StoreVendorUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreVendorUpdateManyWithWhereWithoutStoreInput | StoreVendorUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreVendorScalarWhereInput | StoreVendorScalarWhereInput[]
  }

  export type StockLogUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StockLogCreateWithoutStoreInput, StockLogUncheckedCreateWithoutStoreInput> | StockLogCreateWithoutStoreInput[] | StockLogUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutStoreInput | StockLogCreateOrConnectWithoutStoreInput[]
    upsert?: StockLogUpsertWithWhereUniqueWithoutStoreInput | StockLogUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StockLogCreateManyStoreInputEnvelope
    set?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    disconnect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    delete?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    update?: StockLogUpdateWithWhereUniqueWithoutStoreInput | StockLogUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StockLogUpdateManyWithWhereWithoutStoreInput | StockLogUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutStoreNestedInput = {
    create?: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput> | NotificationCreateWithoutStoreInput[] | NotificationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoreInput | NotificationCreateOrConnectWithoutStoreInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStoreInput | NotificationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: NotificationCreateManyStoreInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStoreInput | NotificationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStoreInput | NotificationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EmployeeInvitationUpdateManyWithoutStoreNestedInput = {
    create?: XOR<EmployeeInvitationCreateWithoutStoreInput, EmployeeInvitationUncheckedCreateWithoutStoreInput> | EmployeeInvitationCreateWithoutStoreInput[] | EmployeeInvitationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutStoreInput | EmployeeInvitationCreateOrConnectWithoutStoreInput[]
    upsert?: EmployeeInvitationUpsertWithWhereUniqueWithoutStoreInput | EmployeeInvitationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: EmployeeInvitationCreateManyStoreInputEnvelope
    set?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    disconnect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    delete?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    update?: EmployeeInvitationUpdateWithWhereUniqueWithoutStoreInput | EmployeeInvitationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: EmployeeInvitationUpdateManyWithWhereWithoutStoreInput | EmployeeInvitationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
  }

  export type EmployeeActivityUpdateManyWithoutStoreNestedInput = {
    create?: XOR<EmployeeActivityCreateWithoutStoreInput, EmployeeActivityUncheckedCreateWithoutStoreInput> | EmployeeActivityCreateWithoutStoreInput[] | EmployeeActivityUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: EmployeeActivityCreateOrConnectWithoutStoreInput | EmployeeActivityCreateOrConnectWithoutStoreInput[]
    upsert?: EmployeeActivityUpsertWithWhereUniqueWithoutStoreInput | EmployeeActivityUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: EmployeeActivityCreateManyStoreInputEnvelope
    set?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    disconnect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    delete?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    connect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    update?: EmployeeActivityUpdateWithWhereUniqueWithoutStoreInput | EmployeeActivityUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: EmployeeActivityUpdateManyWithWhereWithoutStoreInput | EmployeeActivityUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: EmployeeActivityScalarWhereInput | EmployeeActivityScalarWhereInput[]
  }

  export type InviteLinkUpdateManyWithoutStoreNestedInput = {
    create?: XOR<InviteLinkCreateWithoutStoreInput, InviteLinkUncheckedCreateWithoutStoreInput> | InviteLinkCreateWithoutStoreInput[] | InviteLinkUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutStoreInput | InviteLinkCreateOrConnectWithoutStoreInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutStoreInput | InviteLinkUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: InviteLinkCreateManyStoreInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutStoreInput | InviteLinkUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutStoreInput | InviteLinkUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type CustomRoleUpdateManyWithoutStoreNestedInput = {
    create?: XOR<CustomRoleCreateWithoutStoreInput, CustomRoleUncheckedCreateWithoutStoreInput> | CustomRoleCreateWithoutStoreInput[] | CustomRoleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomRoleCreateOrConnectWithoutStoreInput | CustomRoleCreateOrConnectWithoutStoreInput[]
    upsert?: CustomRoleUpsertWithWhereUniqueWithoutStoreInput | CustomRoleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: CustomRoleCreateManyStoreInputEnvelope
    set?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    disconnect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    delete?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    connect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    update?: CustomRoleUpdateWithWhereUniqueWithoutStoreInput | CustomRoleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: CustomRoleUpdateManyWithWhereWithoutStoreInput | CustomRoleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: CustomRoleScalarWhereInput | CustomRoleScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedStoresNestedInput = {
    create?: XOR<UserCreateWithoutOwnedStoresInput, UserUncheckedCreateWithoutOwnedStoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedStoresInput
    upsert?: UserUpsertWithoutOwnedStoresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedStoresInput, UserUpdateWithoutOwnedStoresInput>, UserUncheckedUpdateWithoutOwnedStoresInput>
  }

  export type IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<IntegrationMappingCreateWithoutStoreInput, IntegrationMappingUncheckedCreateWithoutStoreInput> | IntegrationMappingCreateWithoutStoreInput[] | IntegrationMappingUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: IntegrationMappingCreateOrConnectWithoutStoreInput | IntegrationMappingCreateOrConnectWithoutStoreInput[]
    upsert?: IntegrationMappingUpsertWithWhereUniqueWithoutStoreInput | IntegrationMappingUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: IntegrationMappingCreateManyStoreInputEnvelope
    set?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
    disconnect?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
    delete?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
    connect?: IntegrationMappingWhereUniqueInput | IntegrationMappingWhereUniqueInput[]
    update?: IntegrationMappingUpdateWithWhereUniqueWithoutStoreInput | IntegrationMappingUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: IntegrationMappingUpdateManyWithWhereWithoutStoreInput | IntegrationMappingUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: IntegrationMappingScalarWhereInput | IntegrationMappingScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput> | OrderCreateWithoutStoreInput[] | OrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreInput | OrderCreateOrConnectWithoutStoreInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStoreInput | OrderUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: OrderCreateManyStoreInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStoreInput | OrderUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStoreInput | OrderUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput> | ProductCreateWithoutStoreInput[] | ProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStoreInput | ProductCreateOrConnectWithoutStoreInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutStoreInput | ProductUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductCreateManyStoreInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutStoreInput | ProductUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutStoreInput | ProductUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type StoreAdminUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreAdminCreateWithoutStoreInput, StoreAdminUncheckedCreateWithoutStoreInput> | StoreAdminCreateWithoutStoreInput[] | StoreAdminUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreAdminCreateOrConnectWithoutStoreInput | StoreAdminCreateOrConnectWithoutStoreInput[]
    upsert?: StoreAdminUpsertWithWhereUniqueWithoutStoreInput | StoreAdminUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreAdminCreateManyStoreInputEnvelope
    set?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    disconnect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    delete?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    connect?: StoreAdminWhereUniqueInput | StoreAdminWhereUniqueInput[]
    update?: StoreAdminUpdateWithWhereUniqueWithoutStoreInput | StoreAdminUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreAdminUpdateManyWithWhereWithoutStoreInput | StoreAdminUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreAdminScalarWhereInput | StoreAdminScalarWhereInput[]
  }

  export type StoreVendorUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreVendorCreateWithoutStoreInput, StoreVendorUncheckedCreateWithoutStoreInput> | StoreVendorCreateWithoutStoreInput[] | StoreVendorUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutStoreInput | StoreVendorCreateOrConnectWithoutStoreInput[]
    upsert?: StoreVendorUpsertWithWhereUniqueWithoutStoreInput | StoreVendorUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreVendorCreateManyStoreInputEnvelope
    set?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    disconnect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    delete?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    update?: StoreVendorUpdateWithWhereUniqueWithoutStoreInput | StoreVendorUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreVendorUpdateManyWithWhereWithoutStoreInput | StoreVendorUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreVendorScalarWhereInput | StoreVendorScalarWhereInput[]
  }

  export type StockLogUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StockLogCreateWithoutStoreInput, StockLogUncheckedCreateWithoutStoreInput> | StockLogCreateWithoutStoreInput[] | StockLogUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutStoreInput | StockLogCreateOrConnectWithoutStoreInput[]
    upsert?: StockLogUpsertWithWhereUniqueWithoutStoreInput | StockLogUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StockLogCreateManyStoreInputEnvelope
    set?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    disconnect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    delete?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    update?: StockLogUpdateWithWhereUniqueWithoutStoreInput | StockLogUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StockLogUpdateManyWithWhereWithoutStoreInput | StockLogUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput> | NotificationCreateWithoutStoreInput[] | NotificationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoreInput | NotificationCreateOrConnectWithoutStoreInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStoreInput | NotificationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: NotificationCreateManyStoreInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStoreInput | NotificationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStoreInput | NotificationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<EmployeeInvitationCreateWithoutStoreInput, EmployeeInvitationUncheckedCreateWithoutStoreInput> | EmployeeInvitationCreateWithoutStoreInput[] | EmployeeInvitationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutStoreInput | EmployeeInvitationCreateOrConnectWithoutStoreInput[]
    upsert?: EmployeeInvitationUpsertWithWhereUniqueWithoutStoreInput | EmployeeInvitationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: EmployeeInvitationCreateManyStoreInputEnvelope
    set?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    disconnect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    delete?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    update?: EmployeeInvitationUpdateWithWhereUniqueWithoutStoreInput | EmployeeInvitationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: EmployeeInvitationUpdateManyWithWhereWithoutStoreInput | EmployeeInvitationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
  }

  export type EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<EmployeeActivityCreateWithoutStoreInput, EmployeeActivityUncheckedCreateWithoutStoreInput> | EmployeeActivityCreateWithoutStoreInput[] | EmployeeActivityUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: EmployeeActivityCreateOrConnectWithoutStoreInput | EmployeeActivityCreateOrConnectWithoutStoreInput[]
    upsert?: EmployeeActivityUpsertWithWhereUniqueWithoutStoreInput | EmployeeActivityUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: EmployeeActivityCreateManyStoreInputEnvelope
    set?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    disconnect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    delete?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    connect?: EmployeeActivityWhereUniqueInput | EmployeeActivityWhereUniqueInput[]
    update?: EmployeeActivityUpdateWithWhereUniqueWithoutStoreInput | EmployeeActivityUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: EmployeeActivityUpdateManyWithWhereWithoutStoreInput | EmployeeActivityUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: EmployeeActivityScalarWhereInput | EmployeeActivityScalarWhereInput[]
  }

  export type InviteLinkUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<InviteLinkCreateWithoutStoreInput, InviteLinkUncheckedCreateWithoutStoreInput> | InviteLinkCreateWithoutStoreInput[] | InviteLinkUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutStoreInput | InviteLinkCreateOrConnectWithoutStoreInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutStoreInput | InviteLinkUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: InviteLinkCreateManyStoreInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutStoreInput | InviteLinkUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutStoreInput | InviteLinkUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type CustomRoleUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<CustomRoleCreateWithoutStoreInput, CustomRoleUncheckedCreateWithoutStoreInput> | CustomRoleCreateWithoutStoreInput[] | CustomRoleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomRoleCreateOrConnectWithoutStoreInput | CustomRoleCreateOrConnectWithoutStoreInput[]
    upsert?: CustomRoleUpsertWithWhereUniqueWithoutStoreInput | CustomRoleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: CustomRoleCreateManyStoreInputEnvelope
    set?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    disconnect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    delete?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    connect?: CustomRoleWhereUniqueInput | CustomRoleWhereUniqueInput[]
    update?: CustomRoleUpdateWithWhereUniqueWithoutStoreInput | CustomRoleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: CustomRoleUpdateManyWithWhereWithoutStoreInput | CustomRoleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: CustomRoleScalarWhereInput | CustomRoleScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutAdminsInput = {
    create?: XOR<StoreCreateWithoutAdminsInput, StoreUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutAdminsInput
    connect?: StoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedStoresInput = {
    create?: XOR<UserCreateWithoutManagedStoresInput, UserUncheckedCreateWithoutManagedStoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedStoresInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedAdminsInput = {
    create?: XOR<UserCreateWithoutAssignedAdminsInput, UserUncheckedCreateWithoutAssignedAdminsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedAdminsInput
    connect?: UserWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutAdminsNestedInput = {
    create?: XOR<StoreCreateWithoutAdminsInput, StoreUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutAdminsInput
    upsert?: StoreUpsertWithoutAdminsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutAdminsInput, StoreUpdateWithoutAdminsInput>, StoreUncheckedUpdateWithoutAdminsInput>
  }

  export type UserUpdateOneRequiredWithoutManagedStoresNestedInput = {
    create?: XOR<UserCreateWithoutManagedStoresInput, UserUncheckedCreateWithoutManagedStoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedStoresInput
    upsert?: UserUpsertWithoutManagedStoresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedStoresInput, UserUpdateWithoutManagedStoresInput>, UserUncheckedUpdateWithoutManagedStoresInput>
  }

  export type UserUpdateOneWithoutAssignedAdminsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedAdminsInput, UserUncheckedCreateWithoutAssignedAdminsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedAdminsInput
    upsert?: UserUpsertWithoutAssignedAdminsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedAdminsInput, UserUpdateWithoutAssignedAdminsInput>, UserUncheckedUpdateWithoutAssignedAdminsInput>
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type StockLogCreateNestedManyWithoutProductInput = {
    create?: XOR<StockLogCreateWithoutProductInput, StockLogUncheckedCreateWithoutProductInput> | StockLogCreateWithoutProductInput[] | StockLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutProductInput | StockLogCreateOrConnectWithoutProductInput[]
    createMany?: StockLogCreateManyProductInputEnvelope
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutProductsInput = {
    create?: XOR<StoreCreateWithoutProductsInput, StoreUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutProductsInput
    connect?: StoreWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type StockLogUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockLogCreateWithoutProductInput, StockLogUncheckedCreateWithoutProductInput> | StockLogCreateWithoutProductInput[] | StockLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutProductInput | StockLogCreateOrConnectWithoutProductInput[]
    createMany?: StockLogCreateManyProductInputEnvelope
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type StockLogUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockLogCreateWithoutProductInput, StockLogUncheckedCreateWithoutProductInput> | StockLogCreateWithoutProductInput[] | StockLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutProductInput | StockLogCreateOrConnectWithoutProductInput[]
    upsert?: StockLogUpsertWithWhereUniqueWithoutProductInput | StockLogUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockLogCreateManyProductInputEnvelope
    set?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    disconnect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    delete?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    update?: StockLogUpdateWithWhereUniqueWithoutProductInput | StockLogUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockLogUpdateManyWithWhereWithoutProductInput | StockLogUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type StoreUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<StoreCreateWithoutProductsInput, StoreUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutProductsInput
    upsert?: StoreUpsertWithoutProductsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutProductsInput, StoreUpdateWithoutProductsInput>, StoreUncheckedUpdateWithoutProductsInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type StockLogUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockLogCreateWithoutProductInput, StockLogUncheckedCreateWithoutProductInput> | StockLogCreateWithoutProductInput[] | StockLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutProductInput | StockLogCreateOrConnectWithoutProductInput[]
    upsert?: StockLogUpsertWithWhereUniqueWithoutProductInput | StockLogUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockLogCreateManyProductInputEnvelope
    set?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    disconnect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    delete?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    update?: StockLogUpdateWithWhereUniqueWithoutProductInput | StockLogUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockLogUpdateManyWithWhereWithoutProductInput | StockLogUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutVariantInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockLogCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockLogCreateWithoutVariantInput, StockLogUncheckedCreateWithoutVariantInput> | StockLogCreateWithoutVariantInput[] | StockLogUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutVariantInput | StockLogCreateOrConnectWithoutVariantInput[]
    createMany?: StockLogCreateManyVariantInputEnvelope
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockLogUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockLogCreateWithoutVariantInput, StockLogUncheckedCreateWithoutVariantInput> | StockLogCreateWithoutVariantInput[] | StockLogUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutVariantInput | StockLogCreateOrConnectWithoutVariantInput[]
    createMany?: StockLogCreateManyVariantInputEnvelope
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemUpdateManyWithoutVariantNestedInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutVariantInput | OrderItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutVariantInput | OrderItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutVariantInput | OrderItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockLogUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockLogCreateWithoutVariantInput, StockLogUncheckedCreateWithoutVariantInput> | StockLogCreateWithoutVariantInput[] | StockLogUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutVariantInput | StockLogCreateOrConnectWithoutVariantInput[]
    upsert?: StockLogUpsertWithWhereUniqueWithoutVariantInput | StockLogUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockLogCreateManyVariantInputEnvelope
    set?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    disconnect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    delete?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    update?: StockLogUpdateWithWhereUniqueWithoutVariantInput | StockLogUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockLogUpdateManyWithWhereWithoutVariantInput | StockLogUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutVariantInput | OrderItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutVariantInput | OrderItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutVariantInput | OrderItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockLogUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockLogCreateWithoutVariantInput, StockLogUncheckedCreateWithoutVariantInput> | StockLogCreateWithoutVariantInput[] | StockLogUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutVariantInput | StockLogCreateOrConnectWithoutVariantInput[]
    upsert?: StockLogUpsertWithWhereUniqueWithoutVariantInput | StockLogUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockLogCreateManyVariantInputEnvelope
    set?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    disconnect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    delete?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    update?: StockLogUpdateWithWhereUniqueWithoutVariantInput | StockLogUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockLogUpdateManyWithWhereWithoutVariantInput | StockLogUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
  }

  export type AdminLogCreateNestedManyWithoutOrderInput = {
    create?: XOR<AdminLogCreateWithoutOrderInput, AdminLogUncheckedCreateWithoutOrderInput> | AdminLogCreateWithoutOrderInput[] | AdminLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutOrderInput | AdminLogCreateOrConnectWithoutOrderInput[]
    createMany?: AdminLogCreateManyOrderInputEnvelope
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutOrderInput = {
    create?: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput> | NotificationCreateWithoutOrderInput[] | NotificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrderInput | NotificationCreateOrConnectWithoutOrderInput[]
    createMany?: NotificationCreateManyOrderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutOrdersInput = {
    create?: XOR<StoreCreateWithoutOrdersInput, StoreUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: StoreCreateOrConnectWithoutOrdersInput
    connect?: StoreWhereUniqueInput
  }

  export type AdminLogUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<AdminLogCreateWithoutOrderInput, AdminLogUncheckedCreateWithoutOrderInput> | AdminLogCreateWithoutOrderInput[] | AdminLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutOrderInput | AdminLogCreateOrConnectWithoutOrderInput[]
    createMany?: AdminLogCreateManyOrderInputEnvelope
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput> | NotificationCreateWithoutOrderInput[] | NotificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrderInput | NotificationCreateOrConnectWithoutOrderInput[]
    createMany?: NotificationCreateManyOrderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AdminLogUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AdminLogCreateWithoutOrderInput, AdminLogUncheckedCreateWithoutOrderInput> | AdminLogCreateWithoutOrderInput[] | AdminLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutOrderInput | AdminLogCreateOrConnectWithoutOrderInput[]
    upsert?: AdminLogUpsertWithWhereUniqueWithoutOrderInput | AdminLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AdminLogCreateManyOrderInputEnvelope
    set?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    disconnect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    delete?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    update?: AdminLogUpdateWithWhereUniqueWithoutOrderInput | AdminLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AdminLogUpdateManyWithWhereWithoutOrderInput | AdminLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutOrderNestedInput = {
    create?: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput> | NotificationCreateWithoutOrderInput[] | NotificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrderInput | NotificationCreateOrConnectWithoutOrderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrderInput | NotificationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: NotificationCreateManyOrderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrderInput | NotificationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrderInput | NotificationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type StoreUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<StoreCreateWithoutOrdersInput, StoreUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: StoreCreateOrConnectWithoutOrdersInput
    upsert?: StoreUpsertWithoutOrdersInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutOrdersInput, StoreUpdateWithoutOrdersInput>, StoreUncheckedUpdateWithoutOrdersInput>
  }

  export type AdminLogUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AdminLogCreateWithoutOrderInput, AdminLogUncheckedCreateWithoutOrderInput> | AdminLogCreateWithoutOrderInput[] | AdminLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutOrderInput | AdminLogCreateOrConnectWithoutOrderInput[]
    upsert?: AdminLogUpsertWithWhereUniqueWithoutOrderInput | AdminLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AdminLogCreateManyOrderInputEnvelope
    set?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    disconnect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    delete?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    update?: AdminLogUpdateWithWhereUniqueWithoutOrderInput | AdminLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AdminLogUpdateManyWithWhereWithoutOrderInput | AdminLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput> | NotificationCreateWithoutOrderInput[] | NotificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrderInput | NotificationCreateOrConnectWithoutOrderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrderInput | NotificationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: NotificationCreateManyOrderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrderInput | NotificationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrderInput | NotificationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductVariantCreateWithoutOrderItemsInput, ProductVariantUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutOrderItemsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductVariantUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutOrderItemsInput, ProductVariantUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductVariantUpsertWithoutOrderItemsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutOrderItemsInput, ProductVariantUpdateWithoutOrderItemsInput>, ProductVariantUncheckedUpdateWithoutOrderItemsInput>
  }

  export type UserCreateNestedOneWithoutAdminLogsInput = {
    create?: XOR<UserCreateWithoutAdminLogsInput, UserUncheckedCreateWithoutAdminLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminLogsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutAdminLogsInput = {
    create?: XOR<OrderCreateWithoutAdminLogsInput, OrderUncheckedCreateWithoutAdminLogsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAdminLogsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminLogsNestedInput = {
    create?: XOR<UserCreateWithoutAdminLogsInput, UserUncheckedCreateWithoutAdminLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminLogsInput
    upsert?: UserUpsertWithoutAdminLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminLogsInput, UserUpdateWithoutAdminLogsInput>, UserUncheckedUpdateWithoutAdminLogsInput>
  }

  export type OrderUpdateOneWithoutAdminLogsNestedInput = {
    create?: XOR<OrderCreateWithoutAdminLogsInput, OrderUncheckedCreateWithoutAdminLogsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAdminLogsInput
    upsert?: OrderUpsertWithoutAdminLogsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutAdminLogsInput, OrderUpdateWithoutAdminLogsInput>, OrderUncheckedUpdateWithoutAdminLogsInput>
  }

  export type StoreCreateNestedOneWithoutIntegrationMappingsInput = {
    create?: XOR<StoreCreateWithoutIntegrationMappingsInput, StoreUncheckedCreateWithoutIntegrationMappingsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutIntegrationMappingsInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneWithoutIntegrationMappingsNestedInput = {
    create?: XOR<StoreCreateWithoutIntegrationMappingsInput, StoreUncheckedCreateWithoutIntegrationMappingsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutIntegrationMappingsInput
    upsert?: StoreUpsertWithoutIntegrationMappingsInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutIntegrationMappingsInput, StoreUpdateWithoutIntegrationMappingsInput>, StoreUncheckedUpdateWithoutIntegrationMappingsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<StoreCreateWithoutNotificationsInput, StoreUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutNotificationsInput
    connect?: StoreWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<OrderCreateWithoutNotificationsInput, OrderUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutNotificationsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type StoreUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<StoreCreateWithoutNotificationsInput, StoreUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutNotificationsInput
    upsert?: StoreUpsertWithoutNotificationsInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutNotificationsInput, StoreUpdateWithoutNotificationsInput>, StoreUncheckedUpdateWithoutNotificationsInput>
  }

  export type OrderUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<OrderCreateWithoutNotificationsInput, OrderUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutNotificationsInput
    upsert?: OrderUpsertWithoutNotificationsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutNotificationsInput, OrderUpdateWithoutNotificationsInput>, OrderUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type StoreCreateNestedOneWithoutVendorsInput = {
    create?: XOR<StoreCreateWithoutVendorsInput, StoreUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutVendorsInput
    connect?: StoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVendorStoresInput = {
    create?: XOR<UserCreateWithoutVendorStoresInput, UserUncheckedCreateWithoutVendorStoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorStoresInput
    connect?: UserWhereUniqueInput
  }

  export type CustomRoleCreateNestedOneWithoutVendorsInput = {
    create?: XOR<CustomRoleCreateWithoutVendorsInput, CustomRoleUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: CustomRoleCreateOrConnectWithoutVendorsInput
    connect?: CustomRoleWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutVendorsNestedInput = {
    create?: XOR<StoreCreateWithoutVendorsInput, StoreUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutVendorsInput
    upsert?: StoreUpsertWithoutVendorsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutVendorsInput, StoreUpdateWithoutVendorsInput>, StoreUncheckedUpdateWithoutVendorsInput>
  }

  export type UserUpdateOneRequiredWithoutVendorStoresNestedInput = {
    create?: XOR<UserCreateWithoutVendorStoresInput, UserUncheckedCreateWithoutVendorStoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorStoresInput
    upsert?: UserUpsertWithoutVendorStoresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVendorStoresInput, UserUpdateWithoutVendorStoresInput>, UserUncheckedUpdateWithoutVendorStoresInput>
  }

  export type CustomRoleUpdateOneWithoutVendorsNestedInput = {
    create?: XOR<CustomRoleCreateWithoutVendorsInput, CustomRoleUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: CustomRoleCreateOrConnectWithoutVendorsInput
    upsert?: CustomRoleUpsertWithoutVendorsInput
    disconnect?: CustomRoleWhereInput | boolean
    delete?: CustomRoleWhereInput | boolean
    connect?: CustomRoleWhereUniqueInput
    update?: XOR<XOR<CustomRoleUpdateToOneWithWhereWithoutVendorsInput, CustomRoleUpdateWithoutVendorsInput>, CustomRoleUncheckedUpdateWithoutVendorsInput>
  }

  export type ProductCreateNestedOneWithoutStockLogsInput = {
    create?: XOR<ProductCreateWithoutStockLogsInput, ProductUncheckedCreateWithoutStockLogsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockLogsInput
    connect?: ProductWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutStockLogsInput = {
    create?: XOR<StoreCreateWithoutStockLogsInput, StoreUncheckedCreateWithoutStockLogsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStockLogsInput
    connect?: StoreWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutStockLogsInput = {
    create?: XOR<ProductVariantCreateWithoutStockLogsInput, ProductVariantUncheckedCreateWithoutStockLogsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockLogsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutStockLogsNestedInput = {
    create?: XOR<ProductCreateWithoutStockLogsInput, ProductUncheckedCreateWithoutStockLogsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockLogsInput
    upsert?: ProductUpsertWithoutStockLogsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockLogsInput, ProductUpdateWithoutStockLogsInput>, ProductUncheckedUpdateWithoutStockLogsInput>
  }

  export type StoreUpdateOneRequiredWithoutStockLogsNestedInput = {
    create?: XOR<StoreCreateWithoutStockLogsInput, StoreUncheckedCreateWithoutStockLogsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStockLogsInput
    upsert?: StoreUpsertWithoutStockLogsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutStockLogsInput, StoreUpdateWithoutStockLogsInput>, StoreUncheckedUpdateWithoutStockLogsInput>
  }

  export type ProductVariantUpdateOneWithoutStockLogsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutStockLogsInput, ProductVariantUncheckedCreateWithoutStockLogsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockLogsInput
    upsert?: ProductVariantUpsertWithoutStockLogsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutStockLogsInput, ProductVariantUpdateWithoutStockLogsInput>, ProductVariantUncheckedUpdateWithoutStockLogsInput>
  }

  export type StoreCreateNestedOneWithoutEmployeeInvitationsInput = {
    create?: XOR<StoreCreateWithoutEmployeeInvitationsInput, StoreUncheckedCreateWithoutEmployeeInvitationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutEmployeeInvitationsInput
    connect?: StoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedInvitationsInput = {
    create?: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentInvitationsInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type InviteLinkCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<InviteLinkCreateWithoutInvitationsInput, InviteLinkUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: InviteLinkCreateOrConnectWithoutInvitationsInput
    connect?: InviteLinkWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutEmployeeInvitationsNestedInput = {
    create?: XOR<StoreCreateWithoutEmployeeInvitationsInput, StoreUncheckedCreateWithoutEmployeeInvitationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutEmployeeInvitationsInput
    upsert?: StoreUpsertWithoutEmployeeInvitationsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutEmployeeInvitationsInput, StoreUpdateWithoutEmployeeInvitationsInput>, StoreUncheckedUpdateWithoutEmployeeInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInvitationsInput
    upsert?: UserUpsertWithoutReceivedInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedInvitationsInput, UserUpdateWithoutReceivedInvitationsInput>, UserUncheckedUpdateWithoutReceivedInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutSentInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    upsert?: UserUpsertWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitationsInput, UserUpdateWithoutSentInvitationsInput>, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type InviteLinkUpdateOneWithoutInvitationsNestedInput = {
    create?: XOR<InviteLinkCreateWithoutInvitationsInput, InviteLinkUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: InviteLinkCreateOrConnectWithoutInvitationsInput
    upsert?: InviteLinkUpsertWithoutInvitationsInput
    disconnect?: InviteLinkWhereInput | boolean
    delete?: InviteLinkWhereInput | boolean
    connect?: InviteLinkWhereUniqueInput
    update?: XOR<XOR<InviteLinkUpdateToOneWithWhereWithoutInvitationsInput, InviteLinkUpdateWithoutInvitationsInput>, InviteLinkUncheckedUpdateWithoutInvitationsInput>
  }

  export type StoreCreateNestedOneWithoutEmployeeActivitiesInput = {
    create?: XOR<StoreCreateWithoutEmployeeActivitiesInput, StoreUncheckedCreateWithoutEmployeeActivitiesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutEmployeeActivitiesInput
    connect?: StoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeActivitiesInput = {
    create?: XOR<UserCreateWithoutEmployeeActivitiesInput, UserUncheckedCreateWithoutEmployeeActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutEmployeeActivitiesNestedInput = {
    create?: XOR<StoreCreateWithoutEmployeeActivitiesInput, StoreUncheckedCreateWithoutEmployeeActivitiesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutEmployeeActivitiesInput
    upsert?: StoreUpsertWithoutEmployeeActivitiesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutEmployeeActivitiesInput, StoreUpdateWithoutEmployeeActivitiesInput>, StoreUncheckedUpdateWithoutEmployeeActivitiesInput>
  }

  export type UserUpdateOneRequiredWithoutEmployeeActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeActivitiesInput, UserUncheckedCreateWithoutEmployeeActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeActivitiesInput
    upsert?: UserUpsertWithoutEmployeeActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeActivitiesInput, UserUpdateWithoutEmployeeActivitiesInput>, UserUncheckedUpdateWithoutEmployeeActivitiesInput>
  }

  export type StoreCreateNestedOneWithoutInviteLinksInput = {
    create?: XOR<StoreCreateWithoutInviteLinksInput, StoreUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: StoreCreateOrConnectWithoutInviteLinksInput
    connect?: StoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedInviteLinksInput = {
    create?: XOR<UserCreateWithoutCreatedInviteLinksInput, UserUncheckedCreateWithoutCreatedInviteLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInviteLinksInput
    connect?: UserWhereUniqueInput
  }

  export type CustomRoleCreateNestedOneWithoutInviteLinksInput = {
    create?: XOR<CustomRoleCreateWithoutInviteLinksInput, CustomRoleUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: CustomRoleCreateOrConnectWithoutInviteLinksInput
    connect?: CustomRoleWhereUniqueInput
  }

  export type EmployeeInvitationCreateNestedManyWithoutInviteLinkInput = {
    create?: XOR<EmployeeInvitationCreateWithoutInviteLinkInput, EmployeeInvitationUncheckedCreateWithoutInviteLinkInput> | EmployeeInvitationCreateWithoutInviteLinkInput[] | EmployeeInvitationUncheckedCreateWithoutInviteLinkInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutInviteLinkInput | EmployeeInvitationCreateOrConnectWithoutInviteLinkInput[]
    createMany?: EmployeeInvitationCreateManyInviteLinkInputEnvelope
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
  }

  export type EmployeeInvitationUncheckedCreateNestedManyWithoutInviteLinkInput = {
    create?: XOR<EmployeeInvitationCreateWithoutInviteLinkInput, EmployeeInvitationUncheckedCreateWithoutInviteLinkInput> | EmployeeInvitationCreateWithoutInviteLinkInput[] | EmployeeInvitationUncheckedCreateWithoutInviteLinkInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutInviteLinkInput | EmployeeInvitationCreateOrConnectWithoutInviteLinkInput[]
    createMany?: EmployeeInvitationCreateManyInviteLinkInputEnvelope
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
  }

  export type StoreUpdateOneRequiredWithoutInviteLinksNestedInput = {
    create?: XOR<StoreCreateWithoutInviteLinksInput, StoreUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: StoreCreateOrConnectWithoutInviteLinksInput
    upsert?: StoreUpsertWithoutInviteLinksInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutInviteLinksInput, StoreUpdateWithoutInviteLinksInput>, StoreUncheckedUpdateWithoutInviteLinksInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedInviteLinksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedInviteLinksInput, UserUncheckedCreateWithoutCreatedInviteLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInviteLinksInput
    upsert?: UserUpsertWithoutCreatedInviteLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedInviteLinksInput, UserUpdateWithoutCreatedInviteLinksInput>, UserUncheckedUpdateWithoutCreatedInviteLinksInput>
  }

  export type CustomRoleUpdateOneWithoutInviteLinksNestedInput = {
    create?: XOR<CustomRoleCreateWithoutInviteLinksInput, CustomRoleUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: CustomRoleCreateOrConnectWithoutInviteLinksInput
    upsert?: CustomRoleUpsertWithoutInviteLinksInput
    disconnect?: CustomRoleWhereInput | boolean
    delete?: CustomRoleWhereInput | boolean
    connect?: CustomRoleWhereUniqueInput
    update?: XOR<XOR<CustomRoleUpdateToOneWithWhereWithoutInviteLinksInput, CustomRoleUpdateWithoutInviteLinksInput>, CustomRoleUncheckedUpdateWithoutInviteLinksInput>
  }

  export type EmployeeInvitationUpdateManyWithoutInviteLinkNestedInput = {
    create?: XOR<EmployeeInvitationCreateWithoutInviteLinkInput, EmployeeInvitationUncheckedCreateWithoutInviteLinkInput> | EmployeeInvitationCreateWithoutInviteLinkInput[] | EmployeeInvitationUncheckedCreateWithoutInviteLinkInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutInviteLinkInput | EmployeeInvitationCreateOrConnectWithoutInviteLinkInput[]
    upsert?: EmployeeInvitationUpsertWithWhereUniqueWithoutInviteLinkInput | EmployeeInvitationUpsertWithWhereUniqueWithoutInviteLinkInput[]
    createMany?: EmployeeInvitationCreateManyInviteLinkInputEnvelope
    set?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    disconnect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    delete?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    update?: EmployeeInvitationUpdateWithWhereUniqueWithoutInviteLinkInput | EmployeeInvitationUpdateWithWhereUniqueWithoutInviteLinkInput[]
    updateMany?: EmployeeInvitationUpdateManyWithWhereWithoutInviteLinkInput | EmployeeInvitationUpdateManyWithWhereWithoutInviteLinkInput[]
    deleteMany?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
  }

  export type EmployeeInvitationUncheckedUpdateManyWithoutInviteLinkNestedInput = {
    create?: XOR<EmployeeInvitationCreateWithoutInviteLinkInput, EmployeeInvitationUncheckedCreateWithoutInviteLinkInput> | EmployeeInvitationCreateWithoutInviteLinkInput[] | EmployeeInvitationUncheckedCreateWithoutInviteLinkInput[]
    connectOrCreate?: EmployeeInvitationCreateOrConnectWithoutInviteLinkInput | EmployeeInvitationCreateOrConnectWithoutInviteLinkInput[]
    upsert?: EmployeeInvitationUpsertWithWhereUniqueWithoutInviteLinkInput | EmployeeInvitationUpsertWithWhereUniqueWithoutInviteLinkInput[]
    createMany?: EmployeeInvitationCreateManyInviteLinkInputEnvelope
    set?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    disconnect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    delete?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    connect?: EmployeeInvitationWhereUniqueInput | EmployeeInvitationWhereUniqueInput[]
    update?: EmployeeInvitationUpdateWithWhereUniqueWithoutInviteLinkInput | EmployeeInvitationUpdateWithWhereUniqueWithoutInviteLinkInput[]
    updateMany?: EmployeeInvitationUpdateManyWithWhereWithoutInviteLinkInput | EmployeeInvitationUpdateManyWithWhereWithoutInviteLinkInput[]
    deleteMany?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutCustomRolesInput = {
    create?: XOR<StoreCreateWithoutCustomRolesInput, StoreUncheckedCreateWithoutCustomRolesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutCustomRolesInput
    connect?: StoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedCustomRolesInput = {
    create?: XOR<UserCreateWithoutCreatedCustomRolesInput, UserUncheckedCreateWithoutCreatedCustomRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCustomRolesInput
    connect?: UserWhereUniqueInput
  }

  export type StoreVendorCreateNestedManyWithoutCustomRoleInput = {
    create?: XOR<StoreVendorCreateWithoutCustomRoleInput, StoreVendorUncheckedCreateWithoutCustomRoleInput> | StoreVendorCreateWithoutCustomRoleInput[] | StoreVendorUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutCustomRoleInput | StoreVendorCreateOrConnectWithoutCustomRoleInput[]
    createMany?: StoreVendorCreateManyCustomRoleInputEnvelope
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
  }

  export type InviteLinkCreateNestedManyWithoutCustomRoleInput = {
    create?: XOR<InviteLinkCreateWithoutCustomRoleInput, InviteLinkUncheckedCreateWithoutCustomRoleInput> | InviteLinkCreateWithoutCustomRoleInput[] | InviteLinkUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCustomRoleInput | InviteLinkCreateOrConnectWithoutCustomRoleInput[]
    createMany?: InviteLinkCreateManyCustomRoleInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type StoreVendorUncheckedCreateNestedManyWithoutCustomRoleInput = {
    create?: XOR<StoreVendorCreateWithoutCustomRoleInput, StoreVendorUncheckedCreateWithoutCustomRoleInput> | StoreVendorCreateWithoutCustomRoleInput[] | StoreVendorUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutCustomRoleInput | StoreVendorCreateOrConnectWithoutCustomRoleInput[]
    createMany?: StoreVendorCreateManyCustomRoleInputEnvelope
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
  }

  export type InviteLinkUncheckedCreateNestedManyWithoutCustomRoleInput = {
    create?: XOR<InviteLinkCreateWithoutCustomRoleInput, InviteLinkUncheckedCreateWithoutCustomRoleInput> | InviteLinkCreateWithoutCustomRoleInput[] | InviteLinkUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCustomRoleInput | InviteLinkCreateOrConnectWithoutCustomRoleInput[]
    createMany?: InviteLinkCreateManyCustomRoleInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type StoreUpdateOneRequiredWithoutCustomRolesNestedInput = {
    create?: XOR<StoreCreateWithoutCustomRolesInput, StoreUncheckedCreateWithoutCustomRolesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutCustomRolesInput
    upsert?: StoreUpsertWithoutCustomRolesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutCustomRolesInput, StoreUpdateWithoutCustomRolesInput>, StoreUncheckedUpdateWithoutCustomRolesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedCustomRolesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCustomRolesInput, UserUncheckedCreateWithoutCreatedCustomRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCustomRolesInput
    upsert?: UserUpsertWithoutCreatedCustomRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCustomRolesInput, UserUpdateWithoutCreatedCustomRolesInput>, UserUncheckedUpdateWithoutCreatedCustomRolesInput>
  }

  export type StoreVendorUpdateManyWithoutCustomRoleNestedInput = {
    create?: XOR<StoreVendorCreateWithoutCustomRoleInput, StoreVendorUncheckedCreateWithoutCustomRoleInput> | StoreVendorCreateWithoutCustomRoleInput[] | StoreVendorUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutCustomRoleInput | StoreVendorCreateOrConnectWithoutCustomRoleInput[]
    upsert?: StoreVendorUpsertWithWhereUniqueWithoutCustomRoleInput | StoreVendorUpsertWithWhereUniqueWithoutCustomRoleInput[]
    createMany?: StoreVendorCreateManyCustomRoleInputEnvelope
    set?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    disconnect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    delete?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    update?: StoreVendorUpdateWithWhereUniqueWithoutCustomRoleInput | StoreVendorUpdateWithWhereUniqueWithoutCustomRoleInput[]
    updateMany?: StoreVendorUpdateManyWithWhereWithoutCustomRoleInput | StoreVendorUpdateManyWithWhereWithoutCustomRoleInput[]
    deleteMany?: StoreVendorScalarWhereInput | StoreVendorScalarWhereInput[]
  }

  export type InviteLinkUpdateManyWithoutCustomRoleNestedInput = {
    create?: XOR<InviteLinkCreateWithoutCustomRoleInput, InviteLinkUncheckedCreateWithoutCustomRoleInput> | InviteLinkCreateWithoutCustomRoleInput[] | InviteLinkUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCustomRoleInput | InviteLinkCreateOrConnectWithoutCustomRoleInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutCustomRoleInput | InviteLinkUpsertWithWhereUniqueWithoutCustomRoleInput[]
    createMany?: InviteLinkCreateManyCustomRoleInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutCustomRoleInput | InviteLinkUpdateWithWhereUniqueWithoutCustomRoleInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutCustomRoleInput | InviteLinkUpdateManyWithWhereWithoutCustomRoleInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type StoreVendorUncheckedUpdateManyWithoutCustomRoleNestedInput = {
    create?: XOR<StoreVendorCreateWithoutCustomRoleInput, StoreVendorUncheckedCreateWithoutCustomRoleInput> | StoreVendorCreateWithoutCustomRoleInput[] | StoreVendorUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: StoreVendorCreateOrConnectWithoutCustomRoleInput | StoreVendorCreateOrConnectWithoutCustomRoleInput[]
    upsert?: StoreVendorUpsertWithWhereUniqueWithoutCustomRoleInput | StoreVendorUpsertWithWhereUniqueWithoutCustomRoleInput[]
    createMany?: StoreVendorCreateManyCustomRoleInputEnvelope
    set?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    disconnect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    delete?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    connect?: StoreVendorWhereUniqueInput | StoreVendorWhereUniqueInput[]
    update?: StoreVendorUpdateWithWhereUniqueWithoutCustomRoleInput | StoreVendorUpdateWithWhereUniqueWithoutCustomRoleInput[]
    updateMany?: StoreVendorUpdateManyWithWhereWithoutCustomRoleInput | StoreVendorUpdateManyWithWhereWithoutCustomRoleInput[]
    deleteMany?: StoreVendorScalarWhereInput | StoreVendorScalarWhereInput[]
  }

  export type InviteLinkUncheckedUpdateManyWithoutCustomRoleNestedInput = {
    create?: XOR<InviteLinkCreateWithoutCustomRoleInput, InviteLinkUncheckedCreateWithoutCustomRoleInput> | InviteLinkCreateWithoutCustomRoleInput[] | InviteLinkUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCustomRoleInput | InviteLinkCreateOrConnectWithoutCustomRoleInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutCustomRoleInput | InviteLinkUpsertWithWhereUniqueWithoutCustomRoleInput[]
    createMany?: InviteLinkCreateManyCustomRoleInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutCustomRoleInput | InviteLinkUpdateWithWhereUniqueWithoutCustomRoleInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutCustomRoleInput | InviteLinkUpdateManyWithWhereWithoutCustomRoleInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AdminLogCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    order?: OrderCreateNestedOneWithoutAdminLogsInput
  }

  export type AdminLogUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    orderId?: string | null
  }

  export type AdminLogCreateOrConnectWithoutAdminInput = {
    where: AdminLogWhereUniqueInput
    create: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminLogCreateManyAdminInputEnvelope = {
    data: AdminLogCreateManyAdminInput | AdminLogCreateManyAdminInput[]
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    adminLogs?: AdminLogCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    store: StoreCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    storeId: string
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
  }

  export type StoreAdminCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    store: StoreCreateNestedOneWithoutAdminsInput
    assignedByUser?: UserCreateNestedOneWithoutAssignedAdminsInput
  }

  export type StoreAdminUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    assignedBy?: string | null
  }

  export type StoreAdminCreateOrConnectWithoutUserInput = {
    where: StoreAdminWhereUniqueInput
    create: XOR<StoreAdminCreateWithoutUserInput, StoreAdminUncheckedCreateWithoutUserInput>
  }

  export type StoreAdminCreateManyUserInputEnvelope = {
    data: StoreAdminCreateManyUserInput | StoreAdminCreateManyUserInput[]
  }

  export type StoreAdminCreateWithoutAssignedByUserInput = {
    id?: string
    createdAt?: Date | string
    store: StoreCreateNestedOneWithoutAdminsInput
    user: UserCreateNestedOneWithoutManagedStoresInput
  }

  export type StoreAdminUncheckedCreateWithoutAssignedByUserInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    userId: string
  }

  export type StoreAdminCreateOrConnectWithoutAssignedByUserInput = {
    where: StoreAdminWhereUniqueInput
    create: XOR<StoreAdminCreateWithoutAssignedByUserInput, StoreAdminUncheckedCreateWithoutAssignedByUserInput>
  }

  export type StoreAdminCreateManyAssignedByUserInputEnvelope = {
    data: StoreAdminCreateManyAssignedByUserInput | StoreAdminCreateManyAssignedByUserInput[]
  }

  export type StoreCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutOwnerInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutOwnerInput, StoreUncheckedCreateWithoutOwnerInput>
  }

  export type StoreCreateManyOwnerInputEnvelope = {
    data: StoreCreateManyOwnerInput | StoreCreateManyOwnerInput[]
  }

  export type StoreVendorCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    store: StoreCreateNestedOneWithoutVendorsInput
    customRole?: CustomRoleCreateNestedOneWithoutVendorsInput
  }

  export type StoreVendorUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    customRoleId?: string | null
  }

  export type StoreVendorCreateOrConnectWithoutUserInput = {
    where: StoreVendorWhereUniqueInput
    create: XOR<StoreVendorCreateWithoutUserInput, StoreVendorUncheckedCreateWithoutUserInput>
  }

  export type StoreVendorCreateManyUserInputEnvelope = {
    data: StoreVendorCreateManyUserInput | StoreVendorCreateManyUserInput[]
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    store?: StoreCreateNestedOneWithoutNotificationsInput
    order?: OrderCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    storeId?: string | null
    orderId?: string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type EmployeeInvitationCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    store: StoreCreateNestedOneWithoutEmployeeInvitationsInput
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
    inviteLink?: InviteLinkCreateNestedOneWithoutInvitationsInput
  }

  export type EmployeeInvitationUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    invitedBy: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    inviteLinkId?: string | null
  }

  export type EmployeeInvitationCreateOrConnectWithoutUserInput = {
    where: EmployeeInvitationWhereUniqueInput
    create: XOR<EmployeeInvitationCreateWithoutUserInput, EmployeeInvitationUncheckedCreateWithoutUserInput>
  }

  export type EmployeeInvitationCreateManyUserInputEnvelope = {
    data: EmployeeInvitationCreateManyUserInput | EmployeeInvitationCreateManyUserInput[]
  }

  export type EmployeeInvitationCreateWithoutInviterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    store: StoreCreateNestedOneWithoutEmployeeInvitationsInput
    user: UserCreateNestedOneWithoutReceivedInvitationsInput
    inviteLink?: InviteLinkCreateNestedOneWithoutInvitationsInput
  }

  export type EmployeeInvitationUncheckedCreateWithoutInviterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    inviteLinkId?: string | null
  }

  export type EmployeeInvitationCreateOrConnectWithoutInviterInput = {
    where: EmployeeInvitationWhereUniqueInput
    create: XOR<EmployeeInvitationCreateWithoutInviterInput, EmployeeInvitationUncheckedCreateWithoutInviterInput>
  }

  export type EmployeeInvitationCreateManyInviterInputEnvelope = {
    data: EmployeeInvitationCreateManyInviterInput | EmployeeInvitationCreateManyInviterInput[]
  }

  export type EmployeeActivityCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    store: StoreCreateNestedOneWithoutEmployeeActivitiesInput
  }

  export type EmployeeActivityUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    action: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type EmployeeActivityCreateOrConnectWithoutUserInput = {
    where: EmployeeActivityWhereUniqueInput
    create: XOR<EmployeeActivityCreateWithoutUserInput, EmployeeActivityUncheckedCreateWithoutUserInput>
  }

  export type EmployeeActivityCreateManyUserInputEnvelope = {
    data: EmployeeActivityCreateManyUserInput | EmployeeActivityCreateManyUserInput[]
  }

  export type InviteLinkCreateWithoutCreatorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    role?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
    store: StoreCreateNestedOneWithoutInviteLinksInput
    customRole?: CustomRoleCreateNestedOneWithoutInviteLinksInput
    invitations?: EmployeeInvitationCreateNestedManyWithoutInviteLinkInput
  }

  export type InviteLinkUncheckedCreateWithoutCreatorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    token: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
    invitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviteLinkInput
  }

  export type InviteLinkCreateOrConnectWithoutCreatorInput = {
    where: InviteLinkWhereUniqueInput
    create: XOR<InviteLinkCreateWithoutCreatorInput, InviteLinkUncheckedCreateWithoutCreatorInput>
  }

  export type InviteLinkCreateManyCreatorInputEnvelope = {
    data: InviteLinkCreateManyCreatorInput | InviteLinkCreateManyCreatorInput[]
  }

  export type CustomRoleCreateWithoutCreatorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    store: StoreCreateNestedOneWithoutCustomRolesInput
    vendors?: StoreVendorCreateNestedManyWithoutCustomRoleInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleUncheckedCreateWithoutCreatorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutCustomRoleInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleCreateOrConnectWithoutCreatorInput = {
    where: CustomRoleWhereUniqueInput
    create: XOR<CustomRoleCreateWithoutCreatorInput, CustomRoleUncheckedCreateWithoutCreatorInput>
  }

  export type CustomRoleCreateManyCreatorInputEnvelope = {
    data: CustomRoleCreateManyCreatorInput | CustomRoleCreateManyCreatorInput[]
  }

  export type AdminLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminLogWhereUniqueInput
    update: XOR<AdminLogUpdateWithoutAdminInput, AdminLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminLogWhereUniqueInput
    data: XOR<AdminLogUpdateWithoutAdminInput, AdminLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminLogScalarWhereInput
    data: XOR<AdminLogUpdateManyMutationInput, AdminLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminLogScalarWhereInput = {
    AND?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
    OR?: AdminLogScalarWhereInput[]
    NOT?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
    id?: StringFilter<"AdminLog"> | string
    createdAt?: DateTimeFilter<"AdminLog"> | Date | string
    action?: StringFilter<"AdminLog"> | string
    details?: StringNullableFilter<"AdminLog"> | string | null
    adminId?: StringFilter<"AdminLog"> | string
    orderId?: StringNullableFilter<"AdminLog"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderNumber?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    totalAmount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    customerInfo?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    trackingNumber?: StringNullableFilter<"Order"> | string | null
    carrier?: StringNullableFilter<"Order"> | string | null
    deliveryNotes?: StringNullableFilter<"Order"> | string | null
    cancellationReason?: StringNullableFilter<"Order"> | string | null
    paymentProof?: StringNullableFilter<"Order"> | string | null
    clientRequestId?: StringNullableFilter<"Order"> | string | null
    customerId?: StringFilter<"Order"> | string
    storeId?: StringFilter<"Order"> | string
  }

  export type StoreAdminUpsertWithWhereUniqueWithoutUserInput = {
    where: StoreAdminWhereUniqueInput
    update: XOR<StoreAdminUpdateWithoutUserInput, StoreAdminUncheckedUpdateWithoutUserInput>
    create: XOR<StoreAdminCreateWithoutUserInput, StoreAdminUncheckedCreateWithoutUserInput>
  }

  export type StoreAdminUpdateWithWhereUniqueWithoutUserInput = {
    where: StoreAdminWhereUniqueInput
    data: XOR<StoreAdminUpdateWithoutUserInput, StoreAdminUncheckedUpdateWithoutUserInput>
  }

  export type StoreAdminUpdateManyWithWhereWithoutUserInput = {
    where: StoreAdminScalarWhereInput
    data: XOR<StoreAdminUpdateManyMutationInput, StoreAdminUncheckedUpdateManyWithoutUserInput>
  }

  export type StoreAdminScalarWhereInput = {
    AND?: StoreAdminScalarWhereInput | StoreAdminScalarWhereInput[]
    OR?: StoreAdminScalarWhereInput[]
    NOT?: StoreAdminScalarWhereInput | StoreAdminScalarWhereInput[]
    id?: StringFilter<"StoreAdmin"> | string
    createdAt?: DateTimeFilter<"StoreAdmin"> | Date | string
    storeId?: StringFilter<"StoreAdmin"> | string
    userId?: StringFilter<"StoreAdmin"> | string
    assignedBy?: StringNullableFilter<"StoreAdmin"> | string | null
  }

  export type StoreAdminUpsertWithWhereUniqueWithoutAssignedByUserInput = {
    where: StoreAdminWhereUniqueInput
    update: XOR<StoreAdminUpdateWithoutAssignedByUserInput, StoreAdminUncheckedUpdateWithoutAssignedByUserInput>
    create: XOR<StoreAdminCreateWithoutAssignedByUserInput, StoreAdminUncheckedCreateWithoutAssignedByUserInput>
  }

  export type StoreAdminUpdateWithWhereUniqueWithoutAssignedByUserInput = {
    where: StoreAdminWhereUniqueInput
    data: XOR<StoreAdminUpdateWithoutAssignedByUserInput, StoreAdminUncheckedUpdateWithoutAssignedByUserInput>
  }

  export type StoreAdminUpdateManyWithWhereWithoutAssignedByUserInput = {
    where: StoreAdminScalarWhereInput
    data: XOR<StoreAdminUpdateManyMutationInput, StoreAdminUncheckedUpdateManyWithoutAssignedByUserInput>
  }

  export type StoreUpsertWithWhereUniqueWithoutOwnerInput = {
    where: StoreWhereUniqueInput
    update: XOR<StoreUpdateWithoutOwnerInput, StoreUncheckedUpdateWithoutOwnerInput>
    create: XOR<StoreCreateWithoutOwnerInput, StoreUncheckedCreateWithoutOwnerInput>
  }

  export type StoreUpdateWithWhereUniqueWithoutOwnerInput = {
    where: StoreWhereUniqueInput
    data: XOR<StoreUpdateWithoutOwnerInput, StoreUncheckedUpdateWithoutOwnerInput>
  }

  export type StoreUpdateManyWithWhereWithoutOwnerInput = {
    where: StoreScalarWhereInput
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyWithoutOwnerInput>
  }

  export type StoreScalarWhereInput = {
    AND?: StoreScalarWhereInput | StoreScalarWhereInput[]
    OR?: StoreScalarWhereInput[]
    NOT?: StoreScalarWhereInput | StoreScalarWhereInput[]
    id?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    name?: StringFilter<"Store"> | string
    description?: StringNullableFilter<"Store"> | string | null
    slug?: StringFilter<"Store"> | string
    status?: StringFilter<"Store"> | string
    currency?: StringFilter<"Store"> | string
    domain?: StringNullableFilter<"Store"> | string | null
    contactInfo?: StringNullableFilter<"Store"> | string | null
    contactPhone?: StringNullableFilter<"Store"> | string | null
    settings?: StringNullableFilter<"Store"> | string | null
    logoUrl?: StringNullableFilter<"Store"> | string | null
    bannerUrl?: StringNullableFilter<"Store"> | string | null
    lowStockThreshold?: IntFilter<"Store"> | number
    criticalStockThreshold?: IntFilter<"Store"> | number
    enableStockAlerts?: BoolFilter<"Store"> | boolean
    botToken?: StringNullableFilter<"Store"> | string | null
    botUsername?: StringNullableFilter<"Store"> | string | null
    botStatus?: StringFilter<"Store"> | string
    botWebhookUrl?: StringNullableFilter<"Store"> | string | null
    botSettings?: StringNullableFilter<"Store"> | string | null
    botCreatedAt?: DateTimeNullableFilter<"Store"> | Date | string | null
    botLastActive?: DateTimeNullableFilter<"Store"> | Date | string | null
    ownerId?: StringFilter<"Store"> | string
  }

  export type StoreVendorUpsertWithWhereUniqueWithoutUserInput = {
    where: StoreVendorWhereUniqueInput
    update: XOR<StoreVendorUpdateWithoutUserInput, StoreVendorUncheckedUpdateWithoutUserInput>
    create: XOR<StoreVendorCreateWithoutUserInput, StoreVendorUncheckedCreateWithoutUserInput>
  }

  export type StoreVendorUpdateWithWhereUniqueWithoutUserInput = {
    where: StoreVendorWhereUniqueInput
    data: XOR<StoreVendorUpdateWithoutUserInput, StoreVendorUncheckedUpdateWithoutUserInput>
  }

  export type StoreVendorUpdateManyWithWhereWithoutUserInput = {
    where: StoreVendorScalarWhereInput
    data: XOR<StoreVendorUpdateManyMutationInput, StoreVendorUncheckedUpdateManyWithoutUserInput>
  }

  export type StoreVendorScalarWhereInput = {
    AND?: StoreVendorScalarWhereInput | StoreVendorScalarWhereInput[]
    OR?: StoreVendorScalarWhereInput[]
    NOT?: StoreVendorScalarWhereInput | StoreVendorScalarWhereInput[]
    id?: StringFilter<"StoreVendor"> | string
    createdAt?: DateTimeFilter<"StoreVendor"> | Date | string
    updatedAt?: DateTimeFilter<"StoreVendor"> | Date | string
    storeId?: StringFilter<"StoreVendor"> | string
    userId?: StringFilter<"StoreVendor"> | string
    assignedBy?: StringNullableFilter<"StoreVendor"> | string | null
    isActive?: BoolFilter<"StoreVendor"> | boolean
    permissions?: StringNullableFilter<"StoreVendor"> | string | null
    customRoleId?: StringNullableFilter<"StoreVendor"> | string | null
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    userId?: StringFilter<"UserSession"> | string
    refreshToken?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isRevoked?: BoolFilter<"UserSession"> | boolean
    revokedAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    channels?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    storeId?: StringNullableFilter<"Notification"> | string | null
    orderId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
  }

  export type EmployeeInvitationUpsertWithWhereUniqueWithoutUserInput = {
    where: EmployeeInvitationWhereUniqueInput
    update: XOR<EmployeeInvitationUpdateWithoutUserInput, EmployeeInvitationUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeInvitationCreateWithoutUserInput, EmployeeInvitationUncheckedCreateWithoutUserInput>
  }

  export type EmployeeInvitationUpdateWithWhereUniqueWithoutUserInput = {
    where: EmployeeInvitationWhereUniqueInput
    data: XOR<EmployeeInvitationUpdateWithoutUserInput, EmployeeInvitationUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeInvitationUpdateManyWithWhereWithoutUserInput = {
    where: EmployeeInvitationScalarWhereInput
    data: XOR<EmployeeInvitationUpdateManyMutationInput, EmployeeInvitationUncheckedUpdateManyWithoutUserInput>
  }

  export type EmployeeInvitationScalarWhereInput = {
    AND?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
    OR?: EmployeeInvitationScalarWhereInput[]
    NOT?: EmployeeInvitationScalarWhereInput | EmployeeInvitationScalarWhereInput[]
    id?: StringFilter<"EmployeeInvitation"> | string
    createdAt?: DateTimeFilter<"EmployeeInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeInvitation"> | Date | string
    storeId?: StringFilter<"EmployeeInvitation"> | string
    userId?: StringFilter<"EmployeeInvitation"> | string
    invitedBy?: StringFilter<"EmployeeInvitation"> | string
    role?: StringNullableFilter<"EmployeeInvitation"> | string | null
    customRoleId?: StringNullableFilter<"EmployeeInvitation"> | string | null
    permissions?: StringNullableFilter<"EmployeeInvitation"> | string | null
    token?: StringFilter<"EmployeeInvitation"> | string
    expiresAt?: DateTimeFilter<"EmployeeInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"EmployeeInvitation"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"EmployeeInvitation"> | Date | string | null
    message?: StringNullableFilter<"EmployeeInvitation"> | string | null
    status?: StringFilter<"EmployeeInvitation"> | string
    inviteLinkId?: StringNullableFilter<"EmployeeInvitation"> | string | null
  }

  export type EmployeeInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: EmployeeInvitationWhereUniqueInput
    update: XOR<EmployeeInvitationUpdateWithoutInviterInput, EmployeeInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<EmployeeInvitationCreateWithoutInviterInput, EmployeeInvitationUncheckedCreateWithoutInviterInput>
  }

  export type EmployeeInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: EmployeeInvitationWhereUniqueInput
    data: XOR<EmployeeInvitationUpdateWithoutInviterInput, EmployeeInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type EmployeeInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: EmployeeInvitationScalarWhereInput
    data: XOR<EmployeeInvitationUpdateManyMutationInput, EmployeeInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type EmployeeActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: EmployeeActivityWhereUniqueInput
    update: XOR<EmployeeActivityUpdateWithoutUserInput, EmployeeActivityUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeActivityCreateWithoutUserInput, EmployeeActivityUncheckedCreateWithoutUserInput>
  }

  export type EmployeeActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: EmployeeActivityWhereUniqueInput
    data: XOR<EmployeeActivityUpdateWithoutUserInput, EmployeeActivityUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeActivityUpdateManyWithWhereWithoutUserInput = {
    where: EmployeeActivityScalarWhereInput
    data: XOR<EmployeeActivityUpdateManyMutationInput, EmployeeActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type EmployeeActivityScalarWhereInput = {
    AND?: EmployeeActivityScalarWhereInput | EmployeeActivityScalarWhereInput[]
    OR?: EmployeeActivityScalarWhereInput[]
    NOT?: EmployeeActivityScalarWhereInput | EmployeeActivityScalarWhereInput[]
    id?: StringFilter<"EmployeeActivity"> | string
    createdAt?: DateTimeFilter<"EmployeeActivity"> | Date | string
    storeId?: StringFilter<"EmployeeActivity"> | string
    userId?: StringFilter<"EmployeeActivity"> | string
    action?: StringFilter<"EmployeeActivity"> | string
    details?: StringNullableFilter<"EmployeeActivity"> | string | null
    ipAddress?: StringNullableFilter<"EmployeeActivity"> | string | null
    userAgent?: StringNullableFilter<"EmployeeActivity"> | string | null
  }

  export type InviteLinkUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InviteLinkWhereUniqueInput
    update: XOR<InviteLinkUpdateWithoutCreatorInput, InviteLinkUncheckedUpdateWithoutCreatorInput>
    create: XOR<InviteLinkCreateWithoutCreatorInput, InviteLinkUncheckedCreateWithoutCreatorInput>
  }

  export type InviteLinkUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InviteLinkWhereUniqueInput
    data: XOR<InviteLinkUpdateWithoutCreatorInput, InviteLinkUncheckedUpdateWithoutCreatorInput>
  }

  export type InviteLinkUpdateManyWithWhereWithoutCreatorInput = {
    where: InviteLinkScalarWhereInput
    data: XOR<InviteLinkUpdateManyMutationInput, InviteLinkUncheckedUpdateManyWithoutCreatorInput>
  }

  export type InviteLinkScalarWhereInput = {
    AND?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
    OR?: InviteLinkScalarWhereInput[]
    NOT?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
    id?: StringFilter<"InviteLink"> | string
    createdAt?: DateTimeFilter<"InviteLink"> | Date | string
    updatedAt?: DateTimeFilter<"InviteLink"> | Date | string
    storeId?: StringFilter<"InviteLink"> | string
    createdBy?: StringFilter<"InviteLink"> | string
    token?: StringFilter<"InviteLink"> | string
    role?: StringNullableFilter<"InviteLink"> | string | null
    customRoleId?: StringNullableFilter<"InviteLink"> | string | null
    permissions?: StringNullableFilter<"InviteLink"> | string | null
    maxUses?: IntFilter<"InviteLink"> | number
    usedCount?: IntFilter<"InviteLink"> | number
    expiresAt?: DateTimeNullableFilter<"InviteLink"> | Date | string | null
    isActive?: BoolFilter<"InviteLink"> | boolean
    description?: StringNullableFilter<"InviteLink"> | string | null
  }

  export type CustomRoleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CustomRoleWhereUniqueInput
    update: XOR<CustomRoleUpdateWithoutCreatorInput, CustomRoleUncheckedUpdateWithoutCreatorInput>
    create: XOR<CustomRoleCreateWithoutCreatorInput, CustomRoleUncheckedCreateWithoutCreatorInput>
  }

  export type CustomRoleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CustomRoleWhereUniqueInput
    data: XOR<CustomRoleUpdateWithoutCreatorInput, CustomRoleUncheckedUpdateWithoutCreatorInput>
  }

  export type CustomRoleUpdateManyWithWhereWithoutCreatorInput = {
    where: CustomRoleScalarWhereInput
    data: XOR<CustomRoleUpdateManyMutationInput, CustomRoleUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CustomRoleScalarWhereInput = {
    AND?: CustomRoleScalarWhereInput | CustomRoleScalarWhereInput[]
    OR?: CustomRoleScalarWhereInput[]
    NOT?: CustomRoleScalarWhereInput | CustomRoleScalarWhereInput[]
    id?: StringFilter<"CustomRole"> | string
    createdAt?: DateTimeFilter<"CustomRole"> | Date | string
    updatedAt?: DateTimeFilter<"CustomRole"> | Date | string
    storeId?: StringFilter<"CustomRole"> | string
    name?: StringFilter<"CustomRole"> | string
    description?: StringNullableFilter<"CustomRole"> | string | null
    permissions?: StringFilter<"CustomRole"> | string
    color?: StringFilter<"CustomRole"> | string
    icon?: StringNullableFilter<"CustomRole"> | string | null
    isActive?: BoolFilter<"CustomRole"> | boolean
    createdBy?: StringFilter<"CustomRole"> | string
  }

  export type IntegrationMappingCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    source: string
    entityType: string
    localId: string
    externalId: string
  }

  export type IntegrationMappingUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    source: string
    entityType: string
    localId: string
    externalId: string
  }

  export type IntegrationMappingCreateOrConnectWithoutStoreInput = {
    where: IntegrationMappingWhereUniqueInput
    create: XOR<IntegrationMappingCreateWithoutStoreInput, IntegrationMappingUncheckedCreateWithoutStoreInput>
  }

  export type IntegrationMappingCreateManyStoreInputEnvelope = {
    data: IntegrationMappingCreateManyStoreInput | IntegrationMappingCreateManyStoreInput[]
  }

  export type OrderCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    adminLogs?: AdminLogCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    customer: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    customerId: string
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStoreInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput>
  }

  export type OrderCreateManyStoreInputEnvelope = {
    data: OrderCreateManyStoreInput | OrderCreateManyStoreInput[]
  }

  export type ProductCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLogs?: StockLogCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    categoryId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStoreInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput>
  }

  export type ProductCreateManyStoreInputEnvelope = {
    data: ProductCreateManyStoreInput | ProductCreateManyStoreInput[]
  }

  export type StoreAdminCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutManagedStoresInput
    assignedByUser?: UserCreateNestedOneWithoutAssignedAdminsInput
  }

  export type StoreAdminUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    assignedBy?: string | null
  }

  export type StoreAdminCreateOrConnectWithoutStoreInput = {
    where: StoreAdminWhereUniqueInput
    create: XOR<StoreAdminCreateWithoutStoreInput, StoreAdminUncheckedCreateWithoutStoreInput>
  }

  export type StoreAdminCreateManyStoreInputEnvelope = {
    data: StoreAdminCreateManyStoreInput | StoreAdminCreateManyStoreInput[]
  }

  export type StoreVendorCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    user: UserCreateNestedOneWithoutVendorStoresInput
    customRole?: CustomRoleCreateNestedOneWithoutVendorsInput
  }

  export type StoreVendorUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    customRoleId?: string | null
  }

  export type StoreVendorCreateOrConnectWithoutStoreInput = {
    where: StoreVendorWhereUniqueInput
    create: XOR<StoreVendorCreateWithoutStoreInput, StoreVendorUncheckedCreateWithoutStoreInput>
  }

  export type StoreVendorCreateManyStoreInputEnvelope = {
    data: StoreVendorCreateManyStoreInput | StoreVendorCreateManyStoreInput[]
  }

  export type StockLogCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
    product: ProductCreateNestedOneWithoutStockLogsInput
    variant?: ProductVariantCreateNestedOneWithoutStockLogsInput
  }

  export type StockLogUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    productId: string
    variantId?: string | null
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
  }

  export type StockLogCreateOrConnectWithoutStoreInput = {
    where: StockLogWhereUniqueInput
    create: XOR<StockLogCreateWithoutStoreInput, StockLogUncheckedCreateWithoutStoreInput>
  }

  export type StockLogCreateManyStoreInputEnvelope = {
    data: StockLogCreateManyStoreInput | StockLogCreateManyStoreInput[]
  }

  export type NotificationCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
    order?: OrderCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    orderId?: string | null
    userId: string
  }

  export type NotificationCreateOrConnectWithoutStoreInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput>
  }

  export type NotificationCreateManyStoreInputEnvelope = {
    data: NotificationCreateManyStoreInput | NotificationCreateManyStoreInput[]
  }

  export type EmployeeInvitationCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    user: UserCreateNestedOneWithoutReceivedInvitationsInput
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
    inviteLink?: InviteLinkCreateNestedOneWithoutInvitationsInput
  }

  export type EmployeeInvitationUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    invitedBy: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    inviteLinkId?: string | null
  }

  export type EmployeeInvitationCreateOrConnectWithoutStoreInput = {
    where: EmployeeInvitationWhereUniqueInput
    create: XOR<EmployeeInvitationCreateWithoutStoreInput, EmployeeInvitationUncheckedCreateWithoutStoreInput>
  }

  export type EmployeeInvitationCreateManyStoreInputEnvelope = {
    data: EmployeeInvitationCreateManyStoreInput | EmployeeInvitationCreateManyStoreInput[]
  }

  export type EmployeeActivityCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutEmployeeActivitiesInput
  }

  export type EmployeeActivityUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    action: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type EmployeeActivityCreateOrConnectWithoutStoreInput = {
    where: EmployeeActivityWhereUniqueInput
    create: XOR<EmployeeActivityCreateWithoutStoreInput, EmployeeActivityUncheckedCreateWithoutStoreInput>
  }

  export type EmployeeActivityCreateManyStoreInputEnvelope = {
    data: EmployeeActivityCreateManyStoreInput | EmployeeActivityCreateManyStoreInput[]
  }

  export type InviteLinkCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    role?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
    creator: UserCreateNestedOneWithoutCreatedInviteLinksInput
    customRole?: CustomRoleCreateNestedOneWithoutInviteLinksInput
    invitations?: EmployeeInvitationCreateNestedManyWithoutInviteLinkInput
  }

  export type InviteLinkUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    token: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
    invitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviteLinkInput
  }

  export type InviteLinkCreateOrConnectWithoutStoreInput = {
    where: InviteLinkWhereUniqueInput
    create: XOR<InviteLinkCreateWithoutStoreInput, InviteLinkUncheckedCreateWithoutStoreInput>
  }

  export type InviteLinkCreateManyStoreInputEnvelope = {
    data: InviteLinkCreateManyStoreInput | InviteLinkCreateManyStoreInput[]
  }

  export type CustomRoleCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    creator: UserCreateNestedOneWithoutCreatedCustomRolesInput
    vendors?: StoreVendorCreateNestedManyWithoutCustomRoleInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleUncheckedCreateWithoutStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    createdBy: string
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutCustomRoleInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleCreateOrConnectWithoutStoreInput = {
    where: CustomRoleWhereUniqueInput
    create: XOR<CustomRoleCreateWithoutStoreInput, CustomRoleUncheckedCreateWithoutStoreInput>
  }

  export type CustomRoleCreateManyStoreInputEnvelope = {
    data: CustomRoleCreateManyStoreInput | CustomRoleCreateManyStoreInput[]
  }

  export type UserCreateWithoutOwnedStoresInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutOwnedStoresInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutOwnedStoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedStoresInput, UserUncheckedCreateWithoutOwnedStoresInput>
  }

  export type IntegrationMappingUpsertWithWhereUniqueWithoutStoreInput = {
    where: IntegrationMappingWhereUniqueInput
    update: XOR<IntegrationMappingUpdateWithoutStoreInput, IntegrationMappingUncheckedUpdateWithoutStoreInput>
    create: XOR<IntegrationMappingCreateWithoutStoreInput, IntegrationMappingUncheckedCreateWithoutStoreInput>
  }

  export type IntegrationMappingUpdateWithWhereUniqueWithoutStoreInput = {
    where: IntegrationMappingWhereUniqueInput
    data: XOR<IntegrationMappingUpdateWithoutStoreInput, IntegrationMappingUncheckedUpdateWithoutStoreInput>
  }

  export type IntegrationMappingUpdateManyWithWhereWithoutStoreInput = {
    where: IntegrationMappingScalarWhereInput
    data: XOR<IntegrationMappingUpdateManyMutationInput, IntegrationMappingUncheckedUpdateManyWithoutStoreInput>
  }

  export type IntegrationMappingScalarWhereInput = {
    AND?: IntegrationMappingScalarWhereInput | IntegrationMappingScalarWhereInput[]
    OR?: IntegrationMappingScalarWhereInput[]
    NOT?: IntegrationMappingScalarWhereInput | IntegrationMappingScalarWhereInput[]
    id?: StringFilter<"IntegrationMapping"> | string
    createdAt?: DateTimeFilter<"IntegrationMapping"> | Date | string
    updatedAt?: DateTimeFilter<"IntegrationMapping"> | Date | string
    source?: StringFilter<"IntegrationMapping"> | string
    entityType?: StringFilter<"IntegrationMapping"> | string
    localId?: StringFilter<"IntegrationMapping"> | string
    externalId?: StringFilter<"IntegrationMapping"> | string
    storeId?: StringNullableFilter<"IntegrationMapping"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutStoreInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutStoreInput, OrderUncheckedUpdateWithoutStoreInput>
    create: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutStoreInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutStoreInput, OrderUncheckedUpdateWithoutStoreInput>
  }

  export type OrderUpdateManyWithWhereWithoutStoreInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutStoreInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutStoreInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutStoreInput, ProductUncheckedUpdateWithoutStoreInput>
    create: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutStoreInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutStoreInput, ProductUncheckedUpdateWithoutStoreInput>
  }

  export type ProductUpdateManyWithWhereWithoutStoreInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutStoreInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    trackStock?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    images?: StringNullableFilter<"Product"> | string | null
    storeId?: StringFilter<"Product"> | string
    categoryId?: StringNullableFilter<"Product"> | string | null
  }

  export type StoreAdminUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreAdminWhereUniqueInput
    update: XOR<StoreAdminUpdateWithoutStoreInput, StoreAdminUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreAdminCreateWithoutStoreInput, StoreAdminUncheckedCreateWithoutStoreInput>
  }

  export type StoreAdminUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreAdminWhereUniqueInput
    data: XOR<StoreAdminUpdateWithoutStoreInput, StoreAdminUncheckedUpdateWithoutStoreInput>
  }

  export type StoreAdminUpdateManyWithWhereWithoutStoreInput = {
    where: StoreAdminScalarWhereInput
    data: XOR<StoreAdminUpdateManyMutationInput, StoreAdminUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreVendorUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreVendorWhereUniqueInput
    update: XOR<StoreVendorUpdateWithoutStoreInput, StoreVendorUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreVendorCreateWithoutStoreInput, StoreVendorUncheckedCreateWithoutStoreInput>
  }

  export type StoreVendorUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreVendorWhereUniqueInput
    data: XOR<StoreVendorUpdateWithoutStoreInput, StoreVendorUncheckedUpdateWithoutStoreInput>
  }

  export type StoreVendorUpdateManyWithWhereWithoutStoreInput = {
    where: StoreVendorScalarWhereInput
    data: XOR<StoreVendorUpdateManyMutationInput, StoreVendorUncheckedUpdateManyWithoutStoreInput>
  }

  export type StockLogUpsertWithWhereUniqueWithoutStoreInput = {
    where: StockLogWhereUniqueInput
    update: XOR<StockLogUpdateWithoutStoreInput, StockLogUncheckedUpdateWithoutStoreInput>
    create: XOR<StockLogCreateWithoutStoreInput, StockLogUncheckedCreateWithoutStoreInput>
  }

  export type StockLogUpdateWithWhereUniqueWithoutStoreInput = {
    where: StockLogWhereUniqueInput
    data: XOR<StockLogUpdateWithoutStoreInput, StockLogUncheckedUpdateWithoutStoreInput>
  }

  export type StockLogUpdateManyWithWhereWithoutStoreInput = {
    where: StockLogScalarWhereInput
    data: XOR<StockLogUpdateManyMutationInput, StockLogUncheckedUpdateManyWithoutStoreInput>
  }

  export type StockLogScalarWhereInput = {
    AND?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
    OR?: StockLogScalarWhereInput[]
    NOT?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
    id?: StringFilter<"StockLog"> | string
    createdAt?: DateTimeFilter<"StockLog"> | Date | string
    productId?: StringFilter<"StockLog"> | string
    storeId?: StringFilter<"StockLog"> | string
    variantId?: StringNullableFilter<"StockLog"> | string | null
    changeType?: StringFilter<"StockLog"> | string
    previousQty?: IntFilter<"StockLog"> | number
    newQty?: IntFilter<"StockLog"> | number
    changeQty?: IntFilter<"StockLog"> | number
    reason?: StringNullableFilter<"StockLog"> | string | null
    userId?: StringNullableFilter<"StockLog"> | string | null
    orderId?: StringNullableFilter<"StockLog"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutStoreInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutStoreInput, NotificationUncheckedUpdateWithoutStoreInput>
    create: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutStoreInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutStoreInput, NotificationUncheckedUpdateWithoutStoreInput>
  }

  export type NotificationUpdateManyWithWhereWithoutStoreInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutStoreInput>
  }

  export type EmployeeInvitationUpsertWithWhereUniqueWithoutStoreInput = {
    where: EmployeeInvitationWhereUniqueInput
    update: XOR<EmployeeInvitationUpdateWithoutStoreInput, EmployeeInvitationUncheckedUpdateWithoutStoreInput>
    create: XOR<EmployeeInvitationCreateWithoutStoreInput, EmployeeInvitationUncheckedCreateWithoutStoreInput>
  }

  export type EmployeeInvitationUpdateWithWhereUniqueWithoutStoreInput = {
    where: EmployeeInvitationWhereUniqueInput
    data: XOR<EmployeeInvitationUpdateWithoutStoreInput, EmployeeInvitationUncheckedUpdateWithoutStoreInput>
  }

  export type EmployeeInvitationUpdateManyWithWhereWithoutStoreInput = {
    where: EmployeeInvitationScalarWhereInput
    data: XOR<EmployeeInvitationUpdateManyMutationInput, EmployeeInvitationUncheckedUpdateManyWithoutStoreInput>
  }

  export type EmployeeActivityUpsertWithWhereUniqueWithoutStoreInput = {
    where: EmployeeActivityWhereUniqueInput
    update: XOR<EmployeeActivityUpdateWithoutStoreInput, EmployeeActivityUncheckedUpdateWithoutStoreInput>
    create: XOR<EmployeeActivityCreateWithoutStoreInput, EmployeeActivityUncheckedCreateWithoutStoreInput>
  }

  export type EmployeeActivityUpdateWithWhereUniqueWithoutStoreInput = {
    where: EmployeeActivityWhereUniqueInput
    data: XOR<EmployeeActivityUpdateWithoutStoreInput, EmployeeActivityUncheckedUpdateWithoutStoreInput>
  }

  export type EmployeeActivityUpdateManyWithWhereWithoutStoreInput = {
    where: EmployeeActivityScalarWhereInput
    data: XOR<EmployeeActivityUpdateManyMutationInput, EmployeeActivityUncheckedUpdateManyWithoutStoreInput>
  }

  export type InviteLinkUpsertWithWhereUniqueWithoutStoreInput = {
    where: InviteLinkWhereUniqueInput
    update: XOR<InviteLinkUpdateWithoutStoreInput, InviteLinkUncheckedUpdateWithoutStoreInput>
    create: XOR<InviteLinkCreateWithoutStoreInput, InviteLinkUncheckedCreateWithoutStoreInput>
  }

  export type InviteLinkUpdateWithWhereUniqueWithoutStoreInput = {
    where: InviteLinkWhereUniqueInput
    data: XOR<InviteLinkUpdateWithoutStoreInput, InviteLinkUncheckedUpdateWithoutStoreInput>
  }

  export type InviteLinkUpdateManyWithWhereWithoutStoreInput = {
    where: InviteLinkScalarWhereInput
    data: XOR<InviteLinkUpdateManyMutationInput, InviteLinkUncheckedUpdateManyWithoutStoreInput>
  }

  export type CustomRoleUpsertWithWhereUniqueWithoutStoreInput = {
    where: CustomRoleWhereUniqueInput
    update: XOR<CustomRoleUpdateWithoutStoreInput, CustomRoleUncheckedUpdateWithoutStoreInput>
    create: XOR<CustomRoleCreateWithoutStoreInput, CustomRoleUncheckedCreateWithoutStoreInput>
  }

  export type CustomRoleUpdateWithWhereUniqueWithoutStoreInput = {
    where: CustomRoleWhereUniqueInput
    data: XOR<CustomRoleUpdateWithoutStoreInput, CustomRoleUncheckedUpdateWithoutStoreInput>
  }

  export type CustomRoleUpdateManyWithWhereWithoutStoreInput = {
    where: CustomRoleScalarWhereInput
    data: XOR<CustomRoleUpdateManyMutationInput, CustomRoleUncheckedUpdateManyWithoutStoreInput>
  }

  export type UserUpsertWithoutOwnedStoresInput = {
    update: XOR<UserUpdateWithoutOwnedStoresInput, UserUncheckedUpdateWithoutOwnedStoresInput>
    create: XOR<UserCreateWithoutOwnedStoresInput, UserUncheckedCreateWithoutOwnedStoresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedStoresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedStoresInput, UserUncheckedUpdateWithoutOwnedStoresInput>
  }

  export type UserUpdateWithoutOwnedStoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedStoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StoreCreateWithoutAdminsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutAdminsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutAdminsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutAdminsInput, StoreUncheckedCreateWithoutAdminsInput>
  }

  export type UserCreateWithoutManagedStoresInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutManagedStoresInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutManagedStoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedStoresInput, UserUncheckedCreateWithoutManagedStoresInput>
  }

  export type UserCreateWithoutAssignedAdminsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAssignedAdminsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAssignedAdminsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedAdminsInput, UserUncheckedCreateWithoutAssignedAdminsInput>
  }

  export type StoreUpsertWithoutAdminsInput = {
    update: XOR<StoreUpdateWithoutAdminsInput, StoreUncheckedUpdateWithoutAdminsInput>
    create: XOR<StoreCreateWithoutAdminsInput, StoreUncheckedCreateWithoutAdminsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutAdminsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutAdminsInput, StoreUncheckedUpdateWithoutAdminsInput>
  }

  export type StoreUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutManagedStoresInput = {
    update: XOR<UserUpdateWithoutManagedStoresInput, UserUncheckedUpdateWithoutManagedStoresInput>
    create: XOR<UserCreateWithoutManagedStoresInput, UserUncheckedCreateWithoutManagedStoresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedStoresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedStoresInput, UserUncheckedUpdateWithoutManagedStoresInput>
  }

  export type UserUpdateWithoutManagedStoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedStoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutAssignedAdminsInput = {
    update: XOR<UserUpdateWithoutAssignedAdminsInput, UserUncheckedUpdateWithoutAssignedAdminsInput>
    create: XOR<UserCreateWithoutAssignedAdminsInput, UserUncheckedCreateWithoutAssignedAdminsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedAdminsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedAdminsInput, UserUncheckedUpdateWithoutAssignedAdminsInput>
  }

  export type UserUpdateWithoutAssignedAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
    parentId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLogs?: StockLogCreateNestedManyWithoutProductInput
    store: StoreCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    storeId: string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    order: OrderCreateNestedOneWithoutItemsInput
    variant?: ProductVariantCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    orderId: string
    variantId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
  }

  export type ProductVariantCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutVariantInput
    stockLogs?: StockLogCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutVariantInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantCreateManyProductInputEnvelope = {
    data: ProductVariantCreateManyProductInput | ProductVariantCreateManyProductInput[]
  }

  export type StockLogCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
    store: StoreCreateNestedOneWithoutStockLogsInput
    variant?: ProductVariantCreateNestedOneWithoutStockLogsInput
  }

  export type StockLogUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    variantId?: string | null
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
  }

  export type StockLogCreateOrConnectWithoutProductInput = {
    where: StockLogWhereUniqueInput
    create: XOR<StockLogCreateWithoutProductInput, StockLogUncheckedCreateWithoutProductInput>
  }

  export type StockLogCreateManyProductInputEnvelope = {
    data: StockLogCreateManyProductInput | StockLogCreateManyProductInput[]
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
    parentId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type StoreCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutProductsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutProductsInput, StoreUncheckedCreateWithoutProductsInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    variantId?: StringNullableFilter<"OrderItem"> | string | null
  }

  export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    update: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    data: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariantScalarWhereInput
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariantScalarWhereInput = {
    AND?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    OR?: ProductVariantScalarWhereInput[]
    NOT?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    name?: StringFilter<"ProductVariant"> | string
    value?: StringFilter<"ProductVariant"> | string
    price?: FloatNullableFilter<"ProductVariant"> | number | null
    stock?: IntNullableFilter<"ProductVariant"> | number | null
    sku?: StringNullableFilter<"ProductVariant"> | string | null
    productId?: StringFilter<"ProductVariant"> | string
  }

  export type StockLogUpsertWithWhereUniqueWithoutProductInput = {
    where: StockLogWhereUniqueInput
    update: XOR<StockLogUpdateWithoutProductInput, StockLogUncheckedUpdateWithoutProductInput>
    create: XOR<StockLogCreateWithoutProductInput, StockLogUncheckedCreateWithoutProductInput>
  }

  export type StockLogUpdateWithWhereUniqueWithoutProductInput = {
    where: StockLogWhereUniqueInput
    data: XOR<StockLogUpdateWithoutProductInput, StockLogUncheckedUpdateWithoutProductInput>
  }

  export type StockLogUpdateManyWithWhereWithoutProductInput = {
    where: StockLogScalarWhereInput
    data: XOR<StockLogUpdateManyMutationInput, StockLogUncheckedUpdateManyWithoutProductInput>
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type StoreUpsertWithoutProductsInput = {
    update: XOR<StoreUpdateWithoutProductsInput, StoreUncheckedUpdateWithoutProductsInput>
    create: XOR<StoreCreateWithoutProductsInput, StoreUncheckedCreateWithoutProductsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutProductsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutProductsInput, StoreUncheckedUpdateWithoutProductsInput>
  }

  export type StoreUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrderItemCreateWithoutVariantInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutVariantInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    orderId: string
    productId: string
  }

  export type OrderItemCreateOrConnectWithoutVariantInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
  }

  export type OrderItemCreateManyVariantInputEnvelope = {
    data: OrderItemCreateManyVariantInput | OrderItemCreateManyVariantInput[]
  }

  export type StockLogCreateWithoutVariantInput = {
    id?: string
    createdAt?: Date | string
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
    product: ProductCreateNestedOneWithoutStockLogsInput
    store: StoreCreateNestedOneWithoutStockLogsInput
  }

  export type StockLogUncheckedCreateWithoutVariantInput = {
    id?: string
    createdAt?: Date | string
    productId: string
    storeId: string
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
  }

  export type StockLogCreateOrConnectWithoutVariantInput = {
    where: StockLogWhereUniqueInput
    create: XOR<StockLogCreateWithoutVariantInput, StockLogUncheckedCreateWithoutVariantInput>
  }

  export type StockLogCreateManyVariantInputEnvelope = {
    data: StockLogCreateManyVariantInput | StockLogCreateManyVariantInput[]
  }

  export type ProductCreateWithoutVariantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stockLogs?: StockLogCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    store: StoreCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    storeId: string
    categoryId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutVariantInput, OrderItemUncheckedUpdateWithoutVariantInput>
    create: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutVariantInput, OrderItemUncheckedUpdateWithoutVariantInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutVariantInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutVariantInput>
  }

  export type StockLogUpsertWithWhereUniqueWithoutVariantInput = {
    where: StockLogWhereUniqueInput
    update: XOR<StockLogUpdateWithoutVariantInput, StockLogUncheckedUpdateWithoutVariantInput>
    create: XOR<StockLogCreateWithoutVariantInput, StockLogUncheckedCreateWithoutVariantInput>
  }

  export type StockLogUpdateWithWhereUniqueWithoutVariantInput = {
    where: StockLogWhereUniqueInput
    data: XOR<StockLogUpdateWithoutVariantInput, StockLogUncheckedUpdateWithoutVariantInput>
  }

  export type StockLogUpdateManyWithWhereWithoutVariantInput = {
    where: StockLogScalarWhereInput
    data: XOR<StockLogUpdateManyMutationInput, StockLogUncheckedUpdateManyWithoutVariantInput>
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AdminLogCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    admin: UserCreateNestedOneWithoutAdminLogsInput
  }

  export type AdminLogUncheckedCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    adminId: string
  }

  export type AdminLogCreateOrConnectWithoutOrderInput = {
    where: AdminLogWhereUniqueInput
    create: XOR<AdminLogCreateWithoutOrderInput, AdminLogUncheckedCreateWithoutOrderInput>
  }

  export type AdminLogCreateManyOrderInputEnvelope = {
    data: AdminLogCreateManyOrderInput | AdminLogCreateManyOrderInput[]
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    product: ProductCreateNestedOneWithoutOrderItemsInput
    variant?: ProductVariantCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    productId: string
    variantId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
  }

  export type NotificationCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
    store?: StoreCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    storeId?: string | null
    userId: string
  }

  export type NotificationCreateOrConnectWithoutOrderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput>
  }

  export type NotificationCreateManyOrderInputEnvelope = {
    data: NotificationCreateManyOrderInput | NotificationCreateManyOrderInput[]
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type StoreCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutOrdersInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutOrdersInput, StoreUncheckedCreateWithoutOrdersInput>
  }

  export type AdminLogUpsertWithWhereUniqueWithoutOrderInput = {
    where: AdminLogWhereUniqueInput
    update: XOR<AdminLogUpdateWithoutOrderInput, AdminLogUncheckedUpdateWithoutOrderInput>
    create: XOR<AdminLogCreateWithoutOrderInput, AdminLogUncheckedCreateWithoutOrderInput>
  }

  export type AdminLogUpdateWithWhereUniqueWithoutOrderInput = {
    where: AdminLogWhereUniqueInput
    data: XOR<AdminLogUpdateWithoutOrderInput, AdminLogUncheckedUpdateWithoutOrderInput>
  }

  export type AdminLogUpdateManyWithWhereWithoutOrderInput = {
    where: AdminLogScalarWhereInput
    data: XOR<AdminLogUpdateManyMutationInput, AdminLogUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutOrderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutOrderInput, NotificationUncheckedUpdateWithoutOrderInput>
    create: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutOrderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutOrderInput, NotificationUncheckedUpdateWithoutOrderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutOrderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutOrderInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StoreUpsertWithoutOrdersInput = {
    update: XOR<StoreUpdateWithoutOrdersInput, StoreUncheckedUpdateWithoutOrdersInput>
    create: XOR<StoreCreateWithoutOrdersInput, StoreUncheckedCreateWithoutOrdersInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutOrdersInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutOrdersInput, StoreUncheckedUpdateWithoutOrdersInput>
  }

  export type StoreUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    adminLogs?: AdminLogCreateNestedManyWithoutOrderInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    customer: UserCreateNestedOneWithoutOrdersInput
    store: StoreCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    customerId: string
    storeId: string
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutOrderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    stockLogs?: StockLogCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    store: StoreCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    storeId: string
    categoryId?: string | null
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductVariantCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
    stockLogs?: StockLogCreateNestedManyWithoutVariantInput
    product: ProductCreateNestedOneWithoutVariantsInput
  }

  export type ProductVariantUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
    productId: string
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutOrderItemsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutOrderItemsInput, ProductVariantUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    adminLogs?: AdminLogUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    store?: StoreUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    adminLogs?: AdminLogUncheckedUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductVariantUpsertWithoutOrderItemsInput = {
    update: XOR<ProductVariantUpdateWithoutOrderItemsInput, ProductVariantUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductVariantCreateWithoutOrderItemsInput, ProductVariantUncheckedCreateWithoutOrderItemsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutOrderItemsInput, ProductVariantUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductVariantUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stockLogs?: StockLogUpdateManyWithoutVariantNestedInput
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    stockLogs?: StockLogUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type UserCreateWithoutAdminLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAdminLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAdminLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminLogsInput, UserUncheckedCreateWithoutAdminLogsInput>
  }

  export type OrderCreateWithoutAdminLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    items?: OrderItemCreateNestedManyWithoutOrderInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    customer: UserCreateNestedOneWithoutOrdersInput
    store: StoreCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutAdminLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    customerId: string
    storeId: string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAdminLogsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAdminLogsInput, OrderUncheckedCreateWithoutAdminLogsInput>
  }

  export type UserUpsertWithoutAdminLogsInput = {
    update: XOR<UserUpdateWithoutAdminLogsInput, UserUncheckedUpdateWithoutAdminLogsInput>
    create: XOR<UserCreateWithoutAdminLogsInput, UserUncheckedCreateWithoutAdminLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminLogsInput, UserUncheckedUpdateWithoutAdminLogsInput>
  }

  export type UserUpdateWithoutAdminLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type OrderUpsertWithoutAdminLogsInput = {
    update: XOR<OrderUpdateWithoutAdminLogsInput, OrderUncheckedUpdateWithoutAdminLogsInput>
    create: XOR<OrderCreateWithoutAdminLogsInput, OrderUncheckedCreateWithoutAdminLogsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutAdminLogsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutAdminLogsInput, OrderUncheckedUpdateWithoutAdminLogsInput>
  }

  export type OrderUpdateWithoutAdminLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    store?: StoreUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutAdminLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type StoreCreateWithoutIntegrationMappingsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutIntegrationMappingsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutIntegrationMappingsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutIntegrationMappingsInput, StoreUncheckedCreateWithoutIntegrationMappingsInput>
  }

  export type StoreUpsertWithoutIntegrationMappingsInput = {
    update: XOR<StoreUpdateWithoutIntegrationMappingsInput, StoreUncheckedUpdateWithoutIntegrationMappingsInput>
    create: XOR<StoreCreateWithoutIntegrationMappingsInput, StoreUncheckedCreateWithoutIntegrationMappingsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutIntegrationMappingsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutIntegrationMappingsInput, StoreUncheckedUpdateWithoutIntegrationMappingsInput>
  }

  export type StoreUpdateWithoutIntegrationMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutIntegrationMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type StoreCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutNotificationsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutNotificationsInput, StoreUncheckedCreateWithoutNotificationsInput>
  }

  export type OrderCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    adminLogs?: AdminLogCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    customer: UserCreateNestedOneWithoutOrdersInput
    store: StoreCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    customerId: string
    storeId: string
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutNotificationsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutNotificationsInput, OrderUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StoreUpsertWithoutNotificationsInput = {
    update: XOR<StoreUpdateWithoutNotificationsInput, StoreUncheckedUpdateWithoutNotificationsInput>
    create: XOR<StoreCreateWithoutNotificationsInput, StoreUncheckedCreateWithoutNotificationsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutNotificationsInput, StoreUncheckedUpdateWithoutNotificationsInput>
  }

  export type StoreUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrderUpsertWithoutNotificationsInput = {
    update: XOR<OrderUpdateWithoutNotificationsInput, OrderUncheckedUpdateWithoutNotificationsInput>
    create: XOR<OrderCreateWithoutNotificationsInput, OrderUncheckedCreateWithoutNotificationsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutNotificationsInput, OrderUncheckedUpdateWithoutNotificationsInput>
  }

  export type OrderUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    adminLogs?: AdminLogUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    store?: StoreUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    adminLogs?: AdminLogUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StoreCreateWithoutVendorsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutVendorsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutVendorsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutVendorsInput, StoreUncheckedCreateWithoutVendorsInput>
  }

  export type UserCreateWithoutVendorStoresInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutVendorStoresInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutVendorStoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorStoresInput, UserUncheckedCreateWithoutVendorStoresInput>
  }

  export type CustomRoleCreateWithoutVendorsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    store: StoreCreateNestedOneWithoutCustomRolesInput
    creator: UserCreateNestedOneWithoutCreatedCustomRolesInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleUncheckedCreateWithoutVendorsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    createdBy: string
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleCreateOrConnectWithoutVendorsInput = {
    where: CustomRoleWhereUniqueInput
    create: XOR<CustomRoleCreateWithoutVendorsInput, CustomRoleUncheckedCreateWithoutVendorsInput>
  }

  export type StoreUpsertWithoutVendorsInput = {
    update: XOR<StoreUpdateWithoutVendorsInput, StoreUncheckedUpdateWithoutVendorsInput>
    create: XOR<StoreCreateWithoutVendorsInput, StoreUncheckedCreateWithoutVendorsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutVendorsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutVendorsInput, StoreUncheckedUpdateWithoutVendorsInput>
  }

  export type StoreUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutVendorStoresInput = {
    update: XOR<UserUpdateWithoutVendorStoresInput, UserUncheckedUpdateWithoutVendorStoresInput>
    create: XOR<UserCreateWithoutVendorStoresInput, UserUncheckedCreateWithoutVendorStoresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVendorStoresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVendorStoresInput, UserUncheckedUpdateWithoutVendorStoresInput>
  }

  export type UserUpdateWithoutVendorStoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorStoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CustomRoleUpsertWithoutVendorsInput = {
    update: XOR<CustomRoleUpdateWithoutVendorsInput, CustomRoleUncheckedUpdateWithoutVendorsInput>
    create: XOR<CustomRoleCreateWithoutVendorsInput, CustomRoleUncheckedCreateWithoutVendorsInput>
    where?: CustomRoleWhereInput
  }

  export type CustomRoleUpdateToOneWithWhereWithoutVendorsInput = {
    where?: CustomRoleWhereInput
    data: XOR<CustomRoleUpdateWithoutVendorsInput, CustomRoleUncheckedUpdateWithoutVendorsInput>
  }

  export type CustomRoleUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    store?: StoreUpdateOneRequiredWithoutCustomRolesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomRolesNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCustomRoleNestedInput
  }

  export type CustomRoleUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCustomRoleNestedInput
  }

  export type ProductCreateWithoutStockLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    store: StoreCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutStockLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    storeId: string
    categoryId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockLogsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockLogsInput, ProductUncheckedCreateWithoutStockLogsInput>
  }

  export type StoreCreateWithoutStockLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutStockLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStockLogsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStockLogsInput, StoreUncheckedCreateWithoutStockLogsInput>
  }

  export type ProductVariantCreateWithoutStockLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutVariantInput
    product: ProductCreateNestedOneWithoutVariantsInput
  }

  export type ProductVariantUncheckedCreateWithoutStockLogsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
    productId: string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutStockLogsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutStockLogsInput, ProductVariantUncheckedCreateWithoutStockLogsInput>
  }

  export type ProductUpsertWithoutStockLogsInput = {
    update: XOR<ProductUpdateWithoutStockLogsInput, ProductUncheckedUpdateWithoutStockLogsInput>
    create: XOR<ProductCreateWithoutStockLogsInput, ProductUncheckedCreateWithoutStockLogsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockLogsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockLogsInput, ProductUncheckedUpdateWithoutStockLogsInput>
  }

  export type ProductUpdateWithoutStockLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreUpsertWithoutStockLogsInput = {
    update: XOR<StoreUpdateWithoutStockLogsInput, StoreUncheckedUpdateWithoutStockLogsInput>
    create: XOR<StoreCreateWithoutStockLogsInput, StoreUncheckedCreateWithoutStockLogsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutStockLogsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutStockLogsInput, StoreUncheckedUpdateWithoutStockLogsInput>
  }

  export type StoreUpdateWithoutStockLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutStockLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductVariantUpsertWithoutStockLogsInput = {
    update: XOR<ProductVariantUpdateWithoutStockLogsInput, ProductVariantUncheckedUpdateWithoutStockLogsInput>
    create: XOR<ProductVariantCreateWithoutStockLogsInput, ProductVariantUncheckedCreateWithoutStockLogsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutStockLogsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutStockLogsInput, ProductVariantUncheckedUpdateWithoutStockLogsInput>
  }

  export type ProductVariantUpdateWithoutStockLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutVariantNestedInput
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutStockLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type StoreCreateWithoutEmployeeInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutEmployeeInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutEmployeeInvitationsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutEmployeeInvitationsInput, StoreUncheckedCreateWithoutEmployeeInvitationsInput>
  }

  export type UserCreateWithoutReceivedInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutReceivedInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutReceivedInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
  }

  export type UserCreateWithoutSentInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSentInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSentInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
  }

  export type InviteLinkCreateWithoutInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    role?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
    store: StoreCreateNestedOneWithoutInviteLinksInput
    creator: UserCreateNestedOneWithoutCreatedInviteLinksInput
    customRole?: CustomRoleCreateNestedOneWithoutInviteLinksInput
  }

  export type InviteLinkUncheckedCreateWithoutInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    createdBy: string
    token: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
  }

  export type InviteLinkCreateOrConnectWithoutInvitationsInput = {
    where: InviteLinkWhereUniqueInput
    create: XOR<InviteLinkCreateWithoutInvitationsInput, InviteLinkUncheckedCreateWithoutInvitationsInput>
  }

  export type StoreUpsertWithoutEmployeeInvitationsInput = {
    update: XOR<StoreUpdateWithoutEmployeeInvitationsInput, StoreUncheckedUpdateWithoutEmployeeInvitationsInput>
    create: XOR<StoreCreateWithoutEmployeeInvitationsInput, StoreUncheckedCreateWithoutEmployeeInvitationsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutEmployeeInvitationsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutEmployeeInvitationsInput, StoreUncheckedUpdateWithoutEmployeeInvitationsInput>
  }

  export type StoreUpdateWithoutEmployeeInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutEmployeeInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutReceivedInvitationsInput = {
    update: XOR<UserUpdateWithoutReceivedInvitationsInput, UserUncheckedUpdateWithoutReceivedInvitationsInput>
    create: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedInvitationsInput, UserUncheckedUpdateWithoutReceivedInvitationsInput>
  }

  export type UserUpdateWithoutReceivedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutSentInvitationsInput = {
    update: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type UserUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type InviteLinkUpsertWithoutInvitationsInput = {
    update: XOR<InviteLinkUpdateWithoutInvitationsInput, InviteLinkUncheckedUpdateWithoutInvitationsInput>
    create: XOR<InviteLinkCreateWithoutInvitationsInput, InviteLinkUncheckedCreateWithoutInvitationsInput>
    where?: InviteLinkWhereInput
  }

  export type InviteLinkUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: InviteLinkWhereInput
    data: XOR<InviteLinkUpdateWithoutInvitationsInput, InviteLinkUncheckedUpdateWithoutInvitationsInput>
  }

  export type InviteLinkUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutInviteLinksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInviteLinksNestedInput
    customRole?: CustomRoleUpdateOneWithoutInviteLinksNestedInput
  }

  export type InviteLinkUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreCreateWithoutEmployeeActivitiesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutEmployeeActivitiesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutEmployeeActivitiesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutEmployeeActivitiesInput, StoreUncheckedCreateWithoutEmployeeActivitiesInput>
  }

  export type UserCreateWithoutEmployeeActivitiesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutEmployeeActivitiesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutEmployeeActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeActivitiesInput, UserUncheckedCreateWithoutEmployeeActivitiesInput>
  }

  export type StoreUpsertWithoutEmployeeActivitiesInput = {
    update: XOR<StoreUpdateWithoutEmployeeActivitiesInput, StoreUncheckedUpdateWithoutEmployeeActivitiesInput>
    create: XOR<StoreCreateWithoutEmployeeActivitiesInput, StoreUncheckedCreateWithoutEmployeeActivitiesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutEmployeeActivitiesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutEmployeeActivitiesInput, StoreUncheckedUpdateWithoutEmployeeActivitiesInput>
  }

  export type StoreUpdateWithoutEmployeeActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutEmployeeActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutEmployeeActivitiesInput = {
    update: XOR<UserUpdateWithoutEmployeeActivitiesInput, UserUncheckedUpdateWithoutEmployeeActivitiesInput>
    create: XOR<UserCreateWithoutEmployeeActivitiesInput, UserUncheckedCreateWithoutEmployeeActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeActivitiesInput, UserUncheckedUpdateWithoutEmployeeActivitiesInput>
  }

  export type UserUpdateWithoutEmployeeActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StoreCreateWithoutInviteLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutInviteLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    customRoles?: CustomRoleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutInviteLinksInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutInviteLinksInput, StoreUncheckedCreateWithoutInviteLinksInput>
  }

  export type UserCreateWithoutCreatedInviteLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdCustomRoles?: CustomRoleCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedInviteLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdCustomRoles?: CustomRoleUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedInviteLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedInviteLinksInput, UserUncheckedCreateWithoutCreatedInviteLinksInput>
  }

  export type CustomRoleCreateWithoutInviteLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    store: StoreCreateNestedOneWithoutCustomRolesInput
    creator: UserCreateNestedOneWithoutCreatedCustomRolesInput
    vendors?: StoreVendorCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleUncheckedCreateWithoutInviteLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    createdBy: string
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutCustomRoleInput
  }

  export type CustomRoleCreateOrConnectWithoutInviteLinksInput = {
    where: CustomRoleWhereUniqueInput
    create: XOR<CustomRoleCreateWithoutInviteLinksInput, CustomRoleUncheckedCreateWithoutInviteLinksInput>
  }

  export type EmployeeInvitationCreateWithoutInviteLinkInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    store: StoreCreateNestedOneWithoutEmployeeInvitationsInput
    user: UserCreateNestedOneWithoutReceivedInvitationsInput
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
  }

  export type EmployeeInvitationUncheckedCreateWithoutInviteLinkInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    invitedBy: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
  }

  export type EmployeeInvitationCreateOrConnectWithoutInviteLinkInput = {
    where: EmployeeInvitationWhereUniqueInput
    create: XOR<EmployeeInvitationCreateWithoutInviteLinkInput, EmployeeInvitationUncheckedCreateWithoutInviteLinkInput>
  }

  export type EmployeeInvitationCreateManyInviteLinkInputEnvelope = {
    data: EmployeeInvitationCreateManyInviteLinkInput | EmployeeInvitationCreateManyInviteLinkInput[]
  }

  export type StoreUpsertWithoutInviteLinksInput = {
    update: XOR<StoreUpdateWithoutInviteLinksInput, StoreUncheckedUpdateWithoutInviteLinksInput>
    create: XOR<StoreCreateWithoutInviteLinksInput, StoreUncheckedCreateWithoutInviteLinksInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutInviteLinksInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutInviteLinksInput, StoreUncheckedUpdateWithoutInviteLinksInput>
  }

  export type StoreUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutCreatedInviteLinksInput = {
    update: XOR<UserUpdateWithoutCreatedInviteLinksInput, UserUncheckedUpdateWithoutCreatedInviteLinksInput>
    create: XOR<UserCreateWithoutCreatedInviteLinksInput, UserUncheckedCreateWithoutCreatedInviteLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedInviteLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedInviteLinksInput, UserUncheckedUpdateWithoutCreatedInviteLinksInput>
  }

  export type UserUpdateWithoutCreatedInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdCustomRoles?: CustomRoleUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCustomRoles?: CustomRoleUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CustomRoleUpsertWithoutInviteLinksInput = {
    update: XOR<CustomRoleUpdateWithoutInviteLinksInput, CustomRoleUncheckedUpdateWithoutInviteLinksInput>
    create: XOR<CustomRoleCreateWithoutInviteLinksInput, CustomRoleUncheckedCreateWithoutInviteLinksInput>
    where?: CustomRoleWhereInput
  }

  export type CustomRoleUpdateToOneWithWhereWithoutInviteLinksInput = {
    where?: CustomRoleWhereInput
    data: XOR<CustomRoleUpdateWithoutInviteLinksInput, CustomRoleUncheckedUpdateWithoutInviteLinksInput>
  }

  export type CustomRoleUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    store?: StoreUpdateOneRequiredWithoutCustomRolesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomRolesNestedInput
    vendors?: StoreVendorUpdateManyWithoutCustomRoleNestedInput
  }

  export type CustomRoleUncheckedUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    vendors?: StoreVendorUncheckedUpdateManyWithoutCustomRoleNestedInput
  }

  export type EmployeeInvitationUpsertWithWhereUniqueWithoutInviteLinkInput = {
    where: EmployeeInvitationWhereUniqueInput
    update: XOR<EmployeeInvitationUpdateWithoutInviteLinkInput, EmployeeInvitationUncheckedUpdateWithoutInviteLinkInput>
    create: XOR<EmployeeInvitationCreateWithoutInviteLinkInput, EmployeeInvitationUncheckedCreateWithoutInviteLinkInput>
  }

  export type EmployeeInvitationUpdateWithWhereUniqueWithoutInviteLinkInput = {
    where: EmployeeInvitationWhereUniqueInput
    data: XOR<EmployeeInvitationUpdateWithoutInviteLinkInput, EmployeeInvitationUncheckedUpdateWithoutInviteLinkInput>
  }

  export type EmployeeInvitationUpdateManyWithWhereWithoutInviteLinkInput = {
    where: EmployeeInvitationScalarWhereInput
    data: XOR<EmployeeInvitationUpdateManyMutationInput, EmployeeInvitationUncheckedUpdateManyWithoutInviteLinkInput>
  }

  export type StoreCreateWithoutCustomRolesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    integrationMappings?: IntegrationMappingCreateNestedManyWithoutStoreInput
    orders?: OrderCreateNestedManyWithoutStoreInput
    products?: ProductCreateNestedManyWithoutStoreInput
    admins?: StoreAdminCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutStoreInput
    owner: UserCreateNestedOneWithoutOwnedStoresInput
  }

  export type StoreUncheckedCreateWithoutCustomRolesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
    ownerId: string
    integrationMappings?: IntegrationMappingUncheckedCreateNestedManyWithoutStoreInput
    orders?: OrderUncheckedCreateNestedManyWithoutStoreInput
    products?: ProductUncheckedCreateNestedManyWithoutStoreInput
    admins?: StoreAdminUncheckedCreateNestedManyWithoutStoreInput
    vendors?: StoreVendorUncheckedCreateNestedManyWithoutStoreInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
    employeeInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutStoreInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutStoreInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutCustomRolesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutCustomRolesInput, StoreUncheckedCreateWithoutCustomRolesInput>
  }

  export type UserCreateWithoutCreatedCustomRolesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogCreateNestedManyWithoutAdminInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedCustomRolesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    phone?: string | null
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profilePhoto?: string | null
    balance?: number
    adminLogs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    managedStores?: StoreAdminUncheckedCreateNestedManyWithoutUserInput
    assignedAdmins?: StoreAdminUncheckedCreateNestedManyWithoutAssignedByUserInput
    ownedStores?: StoreUncheckedCreateNestedManyWithoutOwnerInput
    vendorStores?: StoreVendorUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviterInput
    employeeActivities?: EmployeeActivityUncheckedCreateNestedManyWithoutUserInput
    createdInviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedCustomRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCustomRolesInput, UserUncheckedCreateWithoutCreatedCustomRolesInput>
  }

  export type StoreVendorCreateWithoutCustomRoleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    store: StoreCreateNestedOneWithoutVendorsInput
    user: UserCreateNestedOneWithoutVendorStoresInput
  }

  export type StoreVendorUncheckedCreateWithoutCustomRoleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
  }

  export type StoreVendorCreateOrConnectWithoutCustomRoleInput = {
    where: StoreVendorWhereUniqueInput
    create: XOR<StoreVendorCreateWithoutCustomRoleInput, StoreVendorUncheckedCreateWithoutCustomRoleInput>
  }

  export type StoreVendorCreateManyCustomRoleInputEnvelope = {
    data: StoreVendorCreateManyCustomRoleInput | StoreVendorCreateManyCustomRoleInput[]
  }

  export type InviteLinkCreateWithoutCustomRoleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    role?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
    store: StoreCreateNestedOneWithoutInviteLinksInput
    creator: UserCreateNestedOneWithoutCreatedInviteLinksInput
    invitations?: EmployeeInvitationCreateNestedManyWithoutInviteLinkInput
  }

  export type InviteLinkUncheckedCreateWithoutCustomRoleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    createdBy: string
    token: string
    role?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
    invitations?: EmployeeInvitationUncheckedCreateNestedManyWithoutInviteLinkInput
  }

  export type InviteLinkCreateOrConnectWithoutCustomRoleInput = {
    where: InviteLinkWhereUniqueInput
    create: XOR<InviteLinkCreateWithoutCustomRoleInput, InviteLinkUncheckedCreateWithoutCustomRoleInput>
  }

  export type InviteLinkCreateManyCustomRoleInputEnvelope = {
    data: InviteLinkCreateManyCustomRoleInput | InviteLinkCreateManyCustomRoleInput[]
  }

  export type StoreUpsertWithoutCustomRolesInput = {
    update: XOR<StoreUpdateWithoutCustomRolesInput, StoreUncheckedUpdateWithoutCustomRolesInput>
    create: XOR<StoreCreateWithoutCustomRolesInput, StoreUncheckedCreateWithoutCustomRolesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutCustomRolesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutCustomRolesInput, StoreUncheckedUpdateWithoutCustomRolesInput>
  }

  export type StoreUpdateWithoutCustomRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutCustomRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutCreatedCustomRolesInput = {
    update: XOR<UserUpdateWithoutCreatedCustomRolesInput, UserUncheckedUpdateWithoutCreatedCustomRolesInput>
    create: XOR<UserCreateWithoutCreatedCustomRolesInput, UserUncheckedCreateWithoutCreatedCustomRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCustomRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCustomRolesInput, UserUncheckedUpdateWithoutCreatedCustomRolesInput>
  }

  export type UserUpdateWithoutCreatedCustomRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUpdateManyWithoutAdminNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCustomRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    adminLogs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    managedStores?: StoreAdminUncheckedUpdateManyWithoutUserNestedInput
    assignedAdmins?: StoreAdminUncheckedUpdateManyWithoutAssignedByUserNestedInput
    ownedStores?: StoreUncheckedUpdateManyWithoutOwnerNestedInput
    vendorStores?: StoreVendorUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviterNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutUserNestedInput
    createdInviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StoreVendorUpsertWithWhereUniqueWithoutCustomRoleInput = {
    where: StoreVendorWhereUniqueInput
    update: XOR<StoreVendorUpdateWithoutCustomRoleInput, StoreVendorUncheckedUpdateWithoutCustomRoleInput>
    create: XOR<StoreVendorCreateWithoutCustomRoleInput, StoreVendorUncheckedCreateWithoutCustomRoleInput>
  }

  export type StoreVendorUpdateWithWhereUniqueWithoutCustomRoleInput = {
    where: StoreVendorWhereUniqueInput
    data: XOR<StoreVendorUpdateWithoutCustomRoleInput, StoreVendorUncheckedUpdateWithoutCustomRoleInput>
  }

  export type StoreVendorUpdateManyWithWhereWithoutCustomRoleInput = {
    where: StoreVendorScalarWhereInput
    data: XOR<StoreVendorUpdateManyMutationInput, StoreVendorUncheckedUpdateManyWithoutCustomRoleInput>
  }

  export type InviteLinkUpsertWithWhereUniqueWithoutCustomRoleInput = {
    where: InviteLinkWhereUniqueInput
    update: XOR<InviteLinkUpdateWithoutCustomRoleInput, InviteLinkUncheckedUpdateWithoutCustomRoleInput>
    create: XOR<InviteLinkCreateWithoutCustomRoleInput, InviteLinkUncheckedCreateWithoutCustomRoleInput>
  }

  export type InviteLinkUpdateWithWhereUniqueWithoutCustomRoleInput = {
    where: InviteLinkWhereUniqueInput
    data: XOR<InviteLinkUpdateWithoutCustomRoleInput, InviteLinkUncheckedUpdateWithoutCustomRoleInput>
  }

  export type InviteLinkUpdateManyWithWhereWithoutCustomRoleInput = {
    where: InviteLinkScalarWhereInput
    data: XOR<InviteLinkUpdateManyMutationInput, InviteLinkUncheckedUpdateManyWithoutCustomRoleInput>
  }

  export type AdminLogCreateManyAdminInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    orderId?: string | null
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    storeId: string
  }

  export type StoreAdminCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    assignedBy?: string | null
  }

  export type StoreAdminCreateManyAssignedByUserInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    userId: string
  }

  export type StoreCreateManyOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    slug: string
    status?: string
    currency?: string
    domain?: string | null
    contactInfo?: string | null
    contactPhone?: string | null
    settings?: string | null
    logoUrl?: string | null
    bannerUrl?: string | null
    lowStockThreshold?: number
    criticalStockThreshold?: number
    enableStockAlerts?: boolean
    botToken?: string | null
    botUsername?: string | null
    botStatus?: string
    botWebhookUrl?: string | null
    botSettings?: string | null
    botCreatedAt?: Date | string | null
    botLastActive?: Date | string | null
  }

  export type StoreVendorCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    customRoleId?: string | null
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    storeId?: string | null
    orderId?: string | null
  }

  export type EmployeeInvitationCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    invitedBy: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    inviteLinkId?: string | null
  }

  export type EmployeeInvitationCreateManyInviterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    inviteLinkId?: string | null
  }

  export type EmployeeActivityCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    action: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type InviteLinkCreateManyCreatorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    token: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
  }

  export type CustomRoleCreateManyCreatorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
  }

  export type AdminLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneWithoutAdminLogsNestedInput
  }

  export type AdminLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    adminLogs?: AdminLogUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    store?: StoreUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    adminLogs?: AdminLogUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreAdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutAdminsNestedInput
    assignedByUser?: UserUpdateOneWithoutAssignedAdminsNestedInput
  }

  export type StoreAdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreAdminUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreAdminUpdateWithoutAssignedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutAdminsNestedInput
    user?: UserUpdateOneRequiredWithoutManagedStoresNestedInput
  }

  export type StoreAdminUncheckedUpdateWithoutAssignedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreAdminUncheckedUpdateManyWithoutAssignedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUpdateManyWithoutStoreNestedInput
    orders?: OrderUpdateManyWithoutStoreNestedInput
    products?: ProductUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integrationMappings?: IntegrationMappingUncheckedUpdateManyWithoutStoreNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    products?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    admins?: StoreAdminUncheckedUpdateManyWithoutStoreNestedInput
    vendors?: StoreVendorUncheckedUpdateManyWithoutStoreNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
    employeeInvitations?: EmployeeInvitationUncheckedUpdateManyWithoutStoreNestedInput
    employeeActivities?: EmployeeActivityUncheckedUpdateManyWithoutStoreNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutStoreNestedInput
    customRoles?: CustomRoleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    criticalStockThreshold?: IntFieldUpdateOperationsInput | number
    enableStockAlerts?: BoolFieldUpdateOperationsInput | boolean
    botToken?: NullableStringFieldUpdateOperationsInput | string | null
    botUsername?: NullableStringFieldUpdateOperationsInput | string | null
    botStatus?: StringFieldUpdateOperationsInput | string
    botWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    botSettings?: NullableStringFieldUpdateOperationsInput | string | null
    botCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botLastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoreVendorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutVendorsNestedInput
    customRole?: CustomRoleUpdateOneWithoutVendorsNestedInput
  }

  export type StoreVendorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreVendorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: StoreUpdateOneWithoutNotificationsNestedInput
    order?: OrderUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeInvitationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    store?: StoreUpdateOneRequiredWithoutEmployeeInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    inviteLink?: InviteLinkUpdateOneWithoutInvitationsNestedInput
  }

  export type EmployeeInvitationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inviteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeInvitationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inviteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeInvitationUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    store?: StoreUpdateOneRequiredWithoutEmployeeInvitationsNestedInput
    user?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
    inviteLink?: InviteLinkUpdateOneWithoutInvitationsNestedInput
  }

  export type EmployeeInvitationUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inviteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inviteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutEmployeeActivitiesNestedInput
  }

  export type EmployeeActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteLinkUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutInviteLinksNestedInput
    customRole?: CustomRoleUpdateOneWithoutInviteLinksNestedInput
    invitations?: EmployeeInvitationUpdateManyWithoutInviteLinkNestedInput
  }

  export type InviteLinkUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviteLinkNestedInput
  }

  export type InviteLinkUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomRoleUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    store?: StoreUpdateOneRequiredWithoutCustomRolesNestedInput
    vendors?: StoreVendorUpdateManyWithoutCustomRoleNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCustomRoleNestedInput
  }

  export type CustomRoleUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendors?: StoreVendorUncheckedUpdateManyWithoutCustomRoleNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCustomRoleNestedInput
  }

  export type CustomRoleUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntegrationMappingCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    source: string
    entityType: string
    localId: string
    externalId: string
  }

  export type OrderCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    status?: string
    totalAmount: number
    currency?: string
    customerInfo: string
    notes?: string | null
    paidAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    trackingNumber?: string | null
    carrier?: string | null
    deliveryNotes?: string | null
    cancellationReason?: string | null
    paymentProof?: string | null
    clientRequestId?: string | null
    customerId: string
  }

  export type ProductCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    categoryId?: string | null
  }

  export type StoreAdminCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    assignedBy?: string | null
  }

  export type StoreVendorCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
    customRoleId?: string | null
  }

  export type StockLogCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    productId: string
    variantId?: string | null
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
  }

  export type NotificationCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    orderId?: string | null
    userId: string
  }

  export type EmployeeInvitationCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    invitedBy: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
    inviteLinkId?: string | null
  }

  export type EmployeeActivityCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    action: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type InviteLinkCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    token: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
  }

  export type CustomRoleCreateManyStoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    permissions: string
    color?: string
    icon?: string | null
    isActive?: boolean
    createdBy: string
  }

  export type IntegrationMappingUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    localId?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
  }

  export type IntegrationMappingUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    localId?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
  }

  export type IntegrationMappingUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    localId?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    adminLogs?: AdminLogUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    adminLogs?: AdminLogUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    customerInfo?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProof?: NullableStringFieldUpdateOperationsInput | string | null
    clientRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreAdminUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutManagedStoresNestedInput
    assignedByUser?: UserUpdateOneWithoutAssignedAdminsNestedInput
  }

  export type StoreAdminUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreAdminUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreVendorUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutVendorStoresNestedInput
    customRole?: CustomRoleUpdateOneWithoutVendorsNestedInput
  }

  export type StoreVendorUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreVendorUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockLogUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutStockLogsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockLogsNestedInput
  }

  export type StockLogUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockLogUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    order?: OrderUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeInvitationUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    inviteLink?: InviteLinkUpdateOneWithoutInvitationsNestedInput
  }

  export type EmployeeInvitationUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inviteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeInvitationUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inviteLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeActivityUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutEmployeeActivitiesNestedInput
  }

  export type EmployeeActivityUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeActivityUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteLinkUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedInviteLinksNestedInput
    customRole?: CustomRoleUpdateOneWithoutInviteLinksNestedInput
    invitations?: EmployeeInvitationUpdateManyWithoutInviteLinkNestedInput
  }

  export type InviteLinkUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviteLinkNestedInput
  }

  export type InviteLinkUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomRoleUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    creator?: UserUpdateOneRequiredWithoutCreatedCustomRolesNestedInput
    vendors?: StoreVendorUpdateManyWithoutCustomRoleNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCustomRoleNestedInput
  }

  export type CustomRoleUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    vendors?: StoreVendorUncheckedUpdateManyWithoutCustomRoleNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCustomRoleNestedInput
  }

  export type CustomRoleUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    slug: string
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    sku?: string | null
    price: number
    stock?: number
    trackStock?: boolean
    isActive?: boolean
    images?: string | null
    storeId: string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUpdateManyWithoutProductNestedInput
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    orderId: string
    variantId?: string | null
  }

  export type ProductVariantCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    value: string
    price?: number | null
    stock?: number | null
    sku?: string | null
  }

  export type StockLogCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
    storeId: string
    variantId?: string | null
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutVariantNestedInput
    stockLogs?: StockLogUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockLogUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutStockLogsNestedInput
    variant?: ProductVariantUpdateOneWithoutStockLogsNestedInput
  }

  export type StockLogUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockLogUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyVariantInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    orderId: string
    productId: string
  }

  export type StockLogCreateManyVariantInput = {
    id?: string
    createdAt?: Date | string
    productId: string
    storeId: string
    changeType: string
    previousQty: number
    newQty: number
    changeQty: number
    reason?: string | null
    userId?: string | null
    orderId?: string | null
  }

  export type OrderItemUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type StockLogUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutStockLogsNestedInput
    store?: StoreUpdateOneRequiredWithoutStockLogsNestedInput
  }

  export type StockLogUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockLogUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    previousQty?: IntFieldUpdateOperationsInput | number
    newQty?: IntFieldUpdateOperationsInput | number
    changeQty?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminLogCreateManyOrderInput = {
    id?: string
    createdAt?: Date | string
    action: string
    details?: string | null
    adminId: string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    price: number
    productId: string
    variantId?: string | null
  }

  export type NotificationCreateManyOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    title: string
    message: string
    priority?: string
    channels: string
    data?: string | null
    readAt?: Date | string | null
    storeId?: string | null
    userId: string
  }

  export type AdminLogUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: UserUpdateOneRequiredWithoutAdminLogsNestedInput
  }

  export type AdminLogUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminLogUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    store?: StoreUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeInvitationCreateManyInviteLinkInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    invitedBy: string
    role?: string | null
    customRoleId?: string | null
    permissions?: string | null
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    rejectedAt?: Date | string | null
    message?: string | null
    status?: string
  }

  export type EmployeeInvitationUpdateWithoutInviteLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    store?: StoreUpdateOneRequiredWithoutEmployeeInvitationsNestedInput
    user?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
  }

  export type EmployeeInvitationUncheckedUpdateWithoutInviteLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeInvitationUncheckedUpdateManyWithoutInviteLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    customRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type StoreVendorCreateManyCustomRoleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    userId: string
    assignedBy?: string | null
    isActive?: boolean
    permissions?: string | null
  }

  export type InviteLinkCreateManyCustomRoleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: string
    createdBy: string
    token: string
    role?: string | null
    permissions?: string | null
    maxUses?: number
    usedCount?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    description?: string | null
  }

  export type StoreVendorUpdateWithoutCustomRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutVendorsNestedInput
    user?: UserUpdateOneRequiredWithoutVendorStoresNestedInput
  }

  export type StoreVendorUncheckedUpdateWithoutCustomRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreVendorUncheckedUpdateManyWithoutCustomRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteLinkUpdateWithoutCustomRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutInviteLinksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInviteLinksNestedInput
    invitations?: EmployeeInvitationUpdateManyWithoutInviteLinkNestedInput
  }

  export type InviteLinkUncheckedUpdateWithoutCustomRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: EmployeeInvitationUncheckedUpdateManyWithoutInviteLinkNestedInput
  }

  export type InviteLinkUncheckedUpdateManyWithoutCustomRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreCountOutputTypeDefaultArgs instead
     */
    export type StoreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductVariantCountOutputTypeDefaultArgs instead
     */
    export type ProductVariantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InviteLinkCountOutputTypeDefaultArgs instead
     */
    export type InviteLinkCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InviteLinkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomRoleCountOutputTypeDefaultArgs instead
     */
    export type CustomRoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomRoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreDefaultArgs instead
     */
    export type StoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreAdminDefaultArgs instead
     */
    export type StoreAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreAdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductVariantDefaultArgs instead
     */
    export type ProductVariantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductVariantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminLogDefaultArgs instead
     */
    export type AdminLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegrationMappingDefaultArgs instead
     */
    export type IntegrationMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegrationMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSessionDefaultArgs instead
     */
    export type UserSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RevokedTokenDefaultArgs instead
     */
    export type RevokedTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RevokedTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreVendorDefaultArgs instead
     */
    export type StoreVendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreVendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockLogDefaultArgs instead
     */
    export type StockLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeInvitationDefaultArgs instead
     */
    export type EmployeeInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeActivityDefaultArgs instead
     */
    export type EmployeeActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InviteLinkDefaultArgs instead
     */
    export type InviteLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InviteLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomRoleDefaultArgs instead
     */
    export type CustomRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomRoleDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}