import TelegramBot from 'node-telegram-bot-api';
import { apiService } from '../services/apiService';
import { userSessions } from '../utils/sessionManager';
import { logger } from '../utils/logger';

export async function handleStart(bot: TelegramBot, msg: TelegramBot.Message) {
  const chatId = msg.chat.id;
  const user = msg.from;

  if (!user) {
    await bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ.');
    return;
  }

  try {
    // Authenticate user with backend
    logger.debug(`Attempting authentication for user ${user.id}`);
    const authResponse = await apiService.authenticateUser(
      user.id.toString(),
      user.username,
      user.first_name,
      user.last_name
    );
    
    logger.debug(`Authentication successful:`, {
      userId: authResponse.user.id,
      role: authResponse.user.role,
      hasToken: !!authResponse.token,
      tokenPreview: authResponse.token ? authResponse.token.substring(0, 20) + '...' : 'none'
    });

    // Update user session
    logger.debug(`Updating session for telegramId ${user.id.toString()} with:`, {
      userId: authResponse.user.id,
      role: authResponse.user.role,
      hasToken: !!authResponse.token
    });
    
    userSessions.updateSession(user.id.toString(), {
      userId: authResponse.user.id,
      token: authResponse.token,
      role: authResponse.user.role,
    });
    
    // Verify session was saved
    const savedSession = userSessions.getSession(user.id.toString());
    logger.debug(`Session after update:`, {
      telegramId: savedSession.telegramId,
      userId: savedSession.userId,
      role: savedSession.role,
      hasToken: !!savedSession.token
    });

    const welcomeText = `
üéâ *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –Ω–∞—à Telegram –º–∞–≥–∞–∑–∏–Ω!*

–ü—Ä–∏–≤–µ—Ç, ${user.first_name || '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'}! üëã

üõçÔ∏è *–ß—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ –¥–µ–ª–∞—Ç—å:*
‚Ä¢ –ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ–≤–∞—Ä—ã —Ä–∞–∑–Ω—ã—Ö –º–∞–≥–∞–∑–∏–Ω–æ–≤
‚Ä¢ –ü–æ–∫—É–ø–∞—Ç—å —Ç–æ–≤–∞—Ä—ã –≤ –æ–¥–∏–Ω –∫–ª–∏–∫
‚Ä¢ –û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —Å–≤–æ–∏ –∑–∞–∫–∞–∑—ã
‚Ä¢ –ü–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å—Ç–∞—Ç—É—Å–µ

*–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –¥–ª—è –Ω–∞—á–∞–ª–∞:*
    `;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üè™ –ü—Ä–æ—Å–º–æ—Ç—Ä –º–∞–≥–∞–∑–∏–Ω–æ–≤', callback_data: 'store_list' }
        ],
        [
          { text: 'üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å', callback_data: 'balance_topup' }
        ],
        [
          { text: 'üë§ –ü—Ä–æ—Ñ–∏–ª—å', callback_data: 'profile_menu' },
          { text: '‚ùì –ü–æ–º–æ—â—å –∏ –∫–æ–Ω—Ç–∞–∫—Ç—ã', callback_data: 'help' }
        ]
      ]
    };

    // Add admin button if user is admin or owner
    if (['ADMIN', 'OWNER'].includes(authResponse.user.role)) {
      keyboard.inline_keyboard.push([
        { text: '‚öôÔ∏è –ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å', callback_data: 'admin_dashboard' },
        { text: 'ü§ñ –ë–æ—Ç—ã –º–∞–≥–∞–∑–∏–Ω–æ–≤', callback_data: 'bot_list' }
      ]);
    }

    await bot.sendMessage(chatId, welcomeText, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });

    logger.info(`User ${user.id} started bot, role: ${authResponse.user.role}`);

  } catch (error) {
    logger.error('Start handler error:', error);
    
    await bot.sendMessage(
      chatId,
      '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ —Å–∏—Å—Ç–µ–º—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ.'
    );
  }
}
