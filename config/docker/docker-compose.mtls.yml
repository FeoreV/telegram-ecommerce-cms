version: '3.8'

services:
  # Certificate Authority service
  ca-service:
    image: alpine:latest
    container_name: botrt-ca
    volumes:
      - ca_data:/ca
      - ./tls:/scripts
    command: |
      sh -c "
        apk add --no-cache openssl &&
        cd /scripts &&
        ./certificate-authority.sh &&
        ./generate-service-certs.sh backend &&
        ./generate-service-certs.sh bot &&
        ./generate-service-certs.sh frontend &&
        ./generate-service-certs.sh postgres &&
        ./generate-service-certs.sh redis &&
        cp -r /tmp/ca/* /ca/ &&
        echo 'Certificates generated successfully' &&
        sleep infinity
      "
    networks:
      - botrt-secure

  # Backend with mTLS
  backend:
    build:
      context: ../../backend
      dockerfile: Dockerfile
    container_name: botrt-backend-mtls
    depends_on:
      - ca-service
      - postgres-tls
      - redis-tls
      - vault
    environment:
      - NODE_ENV=production
      - TLS_ENABLED=true
      - TLS_CERT_PATH=/certs/backend.cert.pem
      - TLS_KEY_PATH=/certs/backend.key.pem
      - TLS_CA_PATH=/certs/ca.cert.pem
      - TLS_CLIENT_CERT_PATH=/certs/backend.client.cert.pem
      - TLS_CLIENT_KEY_PATH=/certs/backend.client.key.pem
      - TLS_REJECT_UNAUTHORIZED=true
      - TLS_MIN_VERSION=TLSv1.2
      - TLS_MAX_VERSION=TLSv1.3
      - USE_VAULT=true
      - VAULT_ADDR=https://vault:8200
      - DATABASE_URL=postgresql://telegram_user:telegram_pass@postgres-tls:5432/telegram_ecommerce?sslmode=require
      - REDIS_URL=rediss://redis-tls:6380
    volumes:
      - ca_data:/ca:ro
      - type: bind
        source: ca_data/services/backend
        target: /certs
        read_only: true
    ports:
      - "3001:3001"
    networks:
      - botrt-secure
    healthcheck:
      test: ["CMD", "curl", "-k", "--cert", "/certs/backend.client.cert.pem", "--key", "/certs/backend.client.key.pem", "https://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Bot service with mTLS
  bot:
    build:
      context: ../../bot
      dockerfile: Dockerfile
    container_name: botrt-bot-mtls
    depends_on:
      - ca-service
      - backend
    environment:
      - NODE_ENV=production
      - TLS_ENABLED=true
      - TLS_CLIENT_CERT_PATH=/certs/bot.client.cert.pem
      - TLS_CLIENT_KEY_PATH=/certs/bot.client.key.pem
      - TLS_CA_PATH=/certs/ca.cert.pem
      - TLS_REJECT_UNAUTHORIZED=true
      - API_URL=https://backend:3001
      - USE_VAULT=true
      - VAULT_ADDR=https://vault:8200
    volumes:
      - ca_data:/ca:ro
      - type: bind
        source: ca_data/services/bot
        target: /certs
        read_only: true
    networks:
      - botrt-secure

  # Frontend with TLS
  frontend:
    build:
      context: ../../frontend
      dockerfile: Dockerfile
    container_name: botrt-frontend-tls
    depends_on:
      - ca-service
      - backend
    environment:
      - NODE_ENV=production
      - HTTPS=true
      - SSL_CRT_FILE=/certs/frontend.cert.pem
      - SSL_KEY_FILE=/certs/frontend.key.pem
      - REACT_APP_API_URL=https://backend:3001
    volumes:
      - ca_data:/ca:ro
      - type: bind
        source: ca_data/services/frontend
        target: /certs
        read_only: true
    ports:
      - "3000:3000"
    networks:
      - botrt-secure

  # PostgreSQL with TLS
  postgres-tls:
    image: postgres:15-alpine
    container_name: botrt-postgres-tls
    depends_on:
      - ca-service
    environment:
      - POSTGRES_DB=telegram_ecommerce
      - POSTGRES_USER=telegram_user
      - POSTGRES_PASSWORD=telegram_pass
      - POSTGRES_INITDB_ARGS=--auth-host=cert
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ca_data:/ca:ro
      - type: bind
        source: ca_data/services/postgres
        target: /certs
        read_only: true
      - ./postgres/postgresql.conf:/etc/postgresql/postgresql.conf
      - ./postgres/pg_hba.conf:/etc/postgresql/pg_hba.conf
    command: >
      postgres
      -c ssl=on
      -c ssl_cert_file=/certs/postgres.cert.pem
      -c ssl_key_file=/certs/postgres.key.pem
      -c ssl_ca_file=/certs/ca.cert.pem
      -c ssl_crl_file=
      -c config_file=/etc/postgresql/postgresql.conf
      -c hba_file=/etc/postgresql/pg_hba.conf
    ports:
      - "5432:5432"
    networks:
      - botrt-secure
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U telegram_user -d telegram_ecommerce -h localhost"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Redis with TLS
  redis-tls:
    image: redis:7-alpine
    container_name: botrt-redis-tls
    depends_on:
      - ca-service
    volumes:
      - redis_data:/data
      - ca_data:/ca:ro
      - type: bind
        source: ca_data/services/redis
        target: /certs
        read_only: true
      - ./redis/redis.conf:/etc/redis/redis.conf
    command: >
      redis-server /etc/redis/redis.conf
      --tls-port 6380
      --port 0
      --tls-cert-file /certs/redis.cert.pem
      --tls-key-file /certs/redis.key.pem
      --tls-ca-cert-file /certs/ca.cert.pem
      --tls-auth-clients yes
      --tls-protocols "TLSv1.2 TLSv1.3"
      --tls-ciphers "ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS"
      --tls-ciphersuites "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256"
    ports:
      - "6380:6380"
    networks:
      - botrt-secure
    healthcheck:
      test: ["CMD", "redis-cli", "--tls", "--cert", "/certs/redis.client.cert.pem", "--key", "/certs/redis.client.key.pem", "--cacert", "/certs/ca.cert.pem", "-p", "6380", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Vault with TLS
  vault:
    image: vault:1.15.2
    container_name: botrt-vault-tls
    depends_on:
      - ca-service
    environment:
      - VAULT_ADDR=https://0.0.0.0:8200
      - VAULT_API_ADDR=https://0.0.0.0:8200
    volumes:
      - vault_data:/vault/data
      - ca_data:/ca:ro
      - type: bind
        source: ca_data/services/vault
        target: /certs
        read_only: true
      - ./vault/vault-tls.hcl:/vault/config/vault.hcl:ro
    command: vault server -config=/vault/config/vault.hcl
    ports:
      - "8200:8200"
    networks:
      - botrt-secure
    cap_add:
      - IPC_LOCK
    healthcheck:
      test: ["CMD", "vault", "status"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Nginx reverse proxy with mTLS termination
  nginx-mtls:
    image: nginx:alpine
    container_name: botrt-nginx-mtls
    depends_on:
      - ca-service
      - backend
      - frontend
    volumes:
      - ca_data:/ca:ro
      - type: bind
        source: ca_data/services/nginx
        target: /certs
        read_only: true
      - ./nginx/nginx-mtls.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl.conf:/etc/nginx/ssl.conf:ro
    ports:
      - "443:443"
      - "80:80"
    networks:
      - botrt-secure
    healthcheck:
      test: ["CMD", "curl", "-k", "https://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  ca_data:
    driver: local
  postgres_data:
    driver: local
  redis_data:
    driver: local
  vault_data:
    driver: local

networks:
  botrt-secure:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
